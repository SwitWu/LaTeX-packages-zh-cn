% -*- coding: utf-8 ; -*- 
\documentclass[dvipsnames]{article}% dvipsnames is for xcolor (loaded by Tikz, loaded by nicematrix)

%\usepackage{xltxtra}
%\usepackage[french]{babel}
%\frenchsetup{og = « , fg = »}

\usepackage{geometry}
\geometry{left=2.8cm,right=2.8cm,top=2.5cm,bottom=2.5cm,papersize={21cm,29.7cm}}

\usepackage{nicematrix}

\usepackage{tikz}
\usetikzlibrary{fit,patterns}

\usepackage{enumitem}
\usepackage{siunitx}
\usepackage{verbatim}

% We use \MakeShortVerb of shortvrb and not \DefineShortVerb of fancyvrb
% because we don't want the \dfrac{分子}{分母}contents of short verbatim colored in gray
\usepackage{shortvrb}
\MakeShortVerb{\|}

\usepackage{fancyvrb}
\fvset{commandchars=\~\#\@,formatcom=\color{gray}}

\usepackage{titlesec}
\titlespacing*{\section}{0pt}{6.5ex plus 1ex minus .2ex}{4.3ex plus .2ex}
\titlespacing*{\subsection}{0pt}{4.5ex plus 1ex minus .2ex}{2ex plus .2ex}

\usepackage{multicol}
\setlength{\columnseprule}{0.4pt}
\def\LetterAt{@}

\def\interitem{\vspace{7mm plus 2 mm minus 3mm}}
\def\emphase{\bgroup\color{RoyalPurple}\let\next=}

\usepackage{footnote}
\usepackage{booktabs}
\usepackage{varwidth}
%\usepackage[hyperfootnotes = false]{hyperref}
\usepackage[breaklinks,colorlinks,linkcolor=black,citecolor=black,urlcolor=black,bookmarksnumbered]{hyperref}

%%---------原文-------
%\hypersetup
% {
%   pdfinfo = 
%    {
%      Title = The package 'nicematrix' ,
%      Subject = A LaTeX package ,
%      Author = F. Pantigny 
%    }
% }
%%---------原文-------
%%---------译文-------
\hypersetup
  {
    pdfinfo = 
      {
        Title = nicematrix宏包 v5.13 帮助文档（中译版） ,
        Subject = LaTeX宏包 ,
        Author = F. Pantigny（著）zhangsming（译）
      }
  } 
%%---------译文-------

\NewDocumentEnvironment {scope} {} {} {}

\NewDocumentCommand {\pkg} {m} {\textsf{#1}}
\NewDocumentCommand {\cls} {m} {\textsf{#1}}

\setlength{\parindent}{2em}

%zhangsming
\def\tikzname{Ti\emph{k}Z}
\def\nicematrixfileversion{5.13}
\def\nicematrixfiledate{2021/3/23}
\def\translatedate{2021/3/28}
%\usepackage{syntonly}\syntaxonly
\usepackage{ctex}
\usepackage{float}
\renewcommand{\abstractname}{摘要}
\newcommand{\env}[1]{\textsf{#1}}
\usepackage{todonotes}
\usepackage{framed}
\usepackage{longdivision}
\usetikzlibrary{arrows.meta,calc,positioning,quotes}
\usepackage{graphicx}
\usepackage{zhnumber}

%译者注记数器
\newcounter{TranslatorNoteNumber}
\newcommand{\tnn}{\stepcounter{TranslatorNoteNumber}\theTranslatorNoteNumber }
%有框线译者注
%\newcommand{\zm}[1]{\begin{framed}\colorbox{red!30}{译者注\tnn}{#1}\end{framed}}
%有框线译者注,NoFrameTranslatorNote
\newcommand{\FTN}[1]{\begin{framed}\colorbox{red!30}{译者注\tnn.\hspace{.33em}}\hspace{.15em}{#1}\end{framed}}
%无框线译者注,FrameTranslatorNote
\newcommand{\NFTN}{\colorbox{red!30}{译者注\tnn.\hspace{.33em}}\hspace{.25em}}

%译者增补示例计数器
\newcounter{TranslatorExampleNumber}
\newcommand{\ten}{\stepcounter{TranslatorExampleNumber}\theTranslatorExampleNumber.}

%中文带圈脚注
\usepackage{circledsteps}
\usepackage{etoolbox}
\usepackage{graphicx}
\makeatletter
\def\nosuper@makefnmark{\hbox{\normalfont\@thefnmark\space}}
\patchcmd\@makefntext{\@makefnmark}{\nosuper@makefnmark}{}{}
\makeatother
\renewcommand\thefootnote{\resizebox{.85em}{.85em}{%
    \CircledTop[inner xsep=2pt,inner ysep=2pt]{\resizebox{1ex}{1ex}{\arabic{footnote}}}}}

%圈码计数器
\renewcommand{\cstep}{%
  \refstepcounter{cstepcnt}%
  \CircledTop{\footnotesize\arabic{cstepcnt}} %
}

\begin{document}
%\zihao{5}
%\VerbatimFootnotes
%%---------原文-------
%\title{The package \pkg{nicematrix}\thanks{This document corresponds to the version~\myfile
%\space of \pkg{nicematrix},
%at the date of~\myfiledate.}} \author{F. Pantigny \\ \texttt{fpantigny@wanadoo.fr}}
%%---------原文-------
%%---------译文-------
\pagenumbering{Roman}

\title{\pkg{nicematrix}宏包手册（中译版）\thanks{此文档是\pkg{nicematrix}~v\nicematrixfileversion（\nicematrixfiledate）帮助文档的中译版。\par 本文的最新版本发布在\  \url{https://gitee.com/zhangsming818/nicematrixmanualzh/}。}}
\author{F. Pantigny（著）\quad zhangsming（译） \\ \texttt{fpantigny@wanadoo.fr}（著）\texttt{zhangsming@foxmail.com}（译）}
\date{2021年3月23日（著）\quad 2021年3月28日 （译）}
%%---------译文-------

\maketitle

\[\begin{NiceArray}{*{6}{c}@{\hspace{6mm}}*{5}{c}}[nullify-dots]
  \CodeBefore
  \SubMatrix({2-7}{6-11})
  \SubMatrix({7-2}{11-6})
  \SubMatrix({7-7}{11-11})
  \Body
  &        &        &        &        &        &        &        & \color{blue}\scriptstyle C_j \\
  &        &        &        &        &        & b_{11} & \Cdots & b_{1j} & \Cdots & b_{1n} \\
  &        &        &        &        &        & \Vdots &        & \Vdots &        & \Vdots \\
  &        &        &        &        &        &        &        & b_{kj} \\
  &        &        &        &        &        &        &        & \Vdots \\
  &        &        &        &        &        & b_{n1} & \Cdots & b_{nj} & \Cdots & b_{nn} \\[3mm]
  & a_{11} & \Cdots &        &        & a_{1n} \\
  & \Vdots &        &        &        & \Vdots &        &        & \Vdots \\
  \color{blue}\scriptstyle L_i 
  & a_{i1} & \Cdots & a_{ik} & \Cdots & a_{in} & \Cdots &        & c_{ij} \\
  & \Vdots &        &        &        & \Vdots \\
  & a_{n1} & \Cdots &        &        & a_{nn}  \\
  \CodeAfter
  \begin{tikzpicture}[highlight/.style = {fill = red!15,
      blend mode = multiply,
      inner sep = 0pt,
      fit = #1}]
    \draw (9-4) circle (2.5mm);
    \draw (4-9) circle (2.5mm);
    \node [highlight = (9-2) (9-6)] { } ; 
    \node [highlight = (2-9) (6-9)] { } ;
    \draw [gray,shorten > = 1mm, shorten < = 1mm] ($(9-4.north)+(0,1mm)$) to [bend left] ($(4-9.west)+(-.1mm,0)$) ;
  \end{tikzpicture}
\end{NiceArray}\]

\addcontentsline{toc}{section}{目录}
\tableofcontents

\listoffigures

\listoftables

\clearpage

\phantomsection
\addcontentsline{toc}{section}{译者按}
\section*{译者按}

\bigskip

在\TeX /\LaTeX 中，相比文字内容而言，表格、数组和矩阵的排版较为复杂。\TeX 和\LaTeX 仅提供了基本的表格、数组和矩阵排版命令，如无框线表格环境 |tabbing|，有框线表格环境 |tabular|、|tabular*| ，以及数学模式下的表格环境 |array| 等，但这些命令和环境远难满足多种多样的需求。为了排版复杂的表格和矩阵，人们开发了多种多样的宏包。在这些宏包中，应用最广泛的当属 \pkg{array} 和 \pkg{amsmath}。

\pkg{array}宏包由 Frank Mittelbach  等人编写，主要对\LaTeX 的 |tabular|、|tabular*| 和 |array| 环境进行了改进和扩展。\pkg{amsmath} 由 Frank Mittelbach 
等5人编写，主要提供了 |matrix|、|pmatrix|、|bmatrix|、|Bmatrix|、|vmatrix| 和 |Vmatrix| 6种行间公式形式的矩阵环境。这些环境必须置于数学模式中，它们的使用方法类似于数组环境 |array|，但没有位置和列格式参数，默认各基本元素上下左右均居中对齐。

除\pkg{array} 和 \pkg{amsmath} 外，在排版表格、数组和矩阵时较为常用的宏包还有用于处理跨行（跨列）内容的 \pkg{multirow}，处理跨页的 \pkg{longtable} 和 \pkg{supertabular}，调整列宽的 \pkg{tabularx}，编写三线表的 \pkg{booktabs}，生成斜线表格的 \pkg{diagbox}，为表格着色的 \pkg{colortbl}，生成虚线框线的 \pkg{arydshln}，用于调整基本单元中内容与框线间距的 \pkg{cellspace}，使小数点对齐的 \pkg{dcolumn}，以及处理注释的 \pkg{tablefootnote} 等。除此之外，还有大量用于排版表格、数组、矩阵的宏包，不一而足。

如此纷繁复杂的宏包常常令初学者手足无措，但这些宏包大都仅能解决表格、数组和矩阵排版中的某一个或某几个问题，且相互之间还可能存在兼容性问题，有时连经验丰富的 \LaTeX er 也难以驾驭。

2010年11月12日，一个名为 \pkg{tabu} 的宏包被上传至 CTAN 网站上。\pkg{tabu} 主要基于 \pkg{array}、 \pkg{longtable} 及其他有关宏包，并大大扩展了 |tabular|、 |tabular*|、|tabularx| 和 |array| 等环境的功能，试图提供一个排版表格、数组和及矩阵的一揽子解决方案。自正式发布之日起，\pkg{tabu} 经历了三个多月的密集开发期。在此期间，不断修复 bug 、解耦依赖，并发布了18个版本，版本号从 v1.1 迭代至 v2.8。遗憾的是，自2011年2月26日起，\pkg{tabu} 停止了更新，直至今日，其版本号仍停留在 v2.8。由于 \pkg{tabu} 对所依赖宏包的部分内部命令进行了修改，而这些宏包多年来持续更新，因此 \pkg{tabu} 与其他宏包可能存在一些兼容性问题。由于原作者似乎已经失联，\LaTeX 项目组承担了 \pkg{tabu} 部分已知 bug 的紧急修复工作，并发布在 github 上\footnote{\url{https://github.com/tabu-fixed/tabu}}。综合来看， \pkg{tabu} 是一个功能较为完善的宏包，但由于其更新停滞、维护不及时，潜在的 bug 得不到持续、快速地修复，从兼容性角度考虑，在选用本宏包时应慎重。

2018年2月13日，François Pantigny 编写的 \pkg{nicematrix} 宏包在 CTAN 网站上发布。
\pkg{nicematrix} 也是一个排版表格、数组和矩阵的综合性宏包。它主要基于 |array| 、 |amsmath|和 \textsc{pgf} ，并在其基础上进行了大量扩展，主要的功能有：

\begin{enumerate}[label = \textbullet ]
  \item 可以方便地调整、设置行高、列宽；
  \item 提供多种阵列与外部元素的对齐方式；
  \item 支持合并单元格；
  \item 支持小数点、单位对齐（siunitx宏包的S型列）；
  \item 支持为单元格、合并单元格及行、列填充背景色（单色、交替色、“棋盘”色）；
  \item 可自定义框线样式，如虚线、颜色等；
  \item 支持表格中的注释，含脚注、表后注；
  \item 支持斜线表格（部分实现diagbox宏包功能）；
  \item 可绘制分块（子）矩阵；
  \item 支持三线表（booktabs宏包）、三分表（threeparttable宏包）；
  \item 可在阵列主体内容外部增加行和列（作为标签使用），外部行（列）可旋转并自动与阵列边缘对齐；
  \item 支持“轻语法"（light-syntax）；
  \item 支持阵列缩排（smallmatrix）；
  \item 支持自动生成矩阵（单元格模式填充）；
  \item 支持新定义列格式；
  \item 支持在阵列中使用 \tikzname 代码；
  \item 可引用单元格号、行号、列号、行线号、列线号等阵列元素；
  \item 提供开发者接口；
  \item ...
\end{enumerate}

综合来看， \pkg{nicematrix} 将多个相关宏包的主要功能进行集成，提供统一的命令，并尽可能保持与经典宏包 |array| 和 |amsmath| 的兼容，支持与 \tikzname 宏包协同工作，同时提供了开发者接口，使表格、数组和矩阵排版更顺畅。 当然，由于需求的多样性，期望仅使用 \pkg{nicematrix} 就能解决表格、数组和矩阵排版的所有问题也是不现实的，比如 \pkg{nicematrix} 就暂不支持跨页表格的排布，它对斜线表格的支持也不如 \pkg{diagbox} 宏包全面。

目前 \pkg{nicematrix} 宏包仍处于密集的开发阶段。自首次公开发布之日起，作者持续修复 bug 并引入新的功能，在3年多时间里已更新了44个版本（含首次发布），当前的最新版本是2021年3月23日发布的 v5.13。虽然 \pkg{nicematrix} 仍是很年轻的一个宏包，但值得关注并推荐。

目前国内已有关于 \pkg{nicematrix} 宏包的介绍性文章，但数量不多且不成系统。 \pkg{nicematrix} 宏包的帮助文档较为翔实，且配有大量非常实用的示例，不失为排版表格、数组和矩阵的一本好的参考资料。为便于查阅，译者对帮助文档进行了翻译。

本译文的原稿基于 |nicematrix.dtx| 文件，排版格式基于 |nicematrix-french.tex| 文件。在翻译过程中，译者力求忠于原文，参阅了大量有关资料，并根据个人理解增补了部分文字注释和代码及运行结果示例。文字部分的注释在开头以\colorbox{red!30}{译者注}标识，并根据与上下文的关系用框线或括号分隔；增补的代码及运行结果示例在上下方均以横线与原文分隔，并在上方横线中央以\colorbox{red!30}{译者增补示例}标识。增补的文字和示例均以阿拉伯数字全文顺序编号。译文中的章节序号、脚注编号均与原稿相同，页码与原稿可能不同，需参阅原稿时，应以章节序号或脚注编号检索。译者在翻译的同时，对原稿中个别疑似错情进行了订正，并以“译者注”的形式标注。为增加文档的可读性，对原稿中的部分格式进行了调整，主要是调整了部分抄录代码与上下文的间距、内部代码的缩进以及高亮部分，并尽可能使单元格内容分隔符“|&|”对齐。此外，译文还将原稿中涉及 |tikz| 宏包名称的样式统一改为 \tikzname ，将 |pgf| 宏包名称的样式统一为 \textsc{pgf}，将 |PDF| 名称的样式统一为 \textsc{PDF}。

由于译者水平有限，翻译部分既非“雅”也不“达”，可能还有不“信”的成分；增补部分大多是狗尾续貂，仅供个人备忘。关于本译文，如有任何疑问，请首先参阅 |nicematrix| 宏包帮助文档原文；如有错情，欢迎不吝赐教。关于宏包本身的疑问，请直接联系宏包作者。


译文中的“作者”指 |nicematrix| 宏包的作者，即 François Pantigny ，译者指 zhangsming。

另，从 CTAN 网站检索的结果看，除 \pkg{nicematrix} 外，François Pantigny 还开发有 \pkg{cascade}（数学式右侧加大括号）、 \pkg{witharrows}（数学式右侧加标签）和 \pkg{decision-table}（绘制决策表） 3 个宏包。这些宏包都很实用且持续更新，同样值得关注。

本译文的原稿如有更新，译文会尽量保持同步。

Happy NiceMatrixing!

\vspace*{2ex}

\hfill zhangsming@foxmail.com\hspace*{5em}

\hfill \translatedate \hspace*{7em}
\clearpage

%使用\LaTeX 3 编程。
%{\hfill\centering\LARGE\textcolor{red}{引\quad 言}\hfill}
\phantomsection
\addcontentsline{toc}{section}{引言}
\section*{引言}

表格（|table|）、数组（|array|）和矩阵（|matrix|）是
排版科技类文献中经常用到的元素。
从总体结构看，它们都是一个相对独立的矩形区域，在这个区域内，或同类、或相似，抑或对立的基本单元呈二维阵列状排布。
在层次结构上，它们都可以看作多个横向的“行”自上而下依次排布而成，
在纵向上，又可以将它们看作由多个纵向的“列”由左至右依次排布而成。
表格、数组和矩阵具有相同的总体结构和层次结构，
但在主要内容和具体表现形式上，它们都有各自的特点。为行文方便，本文将表格、数组和矩阵统称阵列，并将有关概念约定如下\footnote{注：此处的“概念”并非严格地定义，仅是为了本文行文方便而作的约定。}：

%表格通常以文本内容为主，并在部分或全部行和列的边缘绘制“框线”以分隔基本单元；矩阵主要以数学式为主要内容，并以圆括号“(\quad)”、方括号“[\quad]”、花括号“\{\quad\}”、单竖线“\textbar \quad \textbar”、双竖线“\textbardbl \quad \textbardbl”等符号将全部内容包含其中，并与外部内容进行分隔。

\begin{enumerate}
\item 阵列基本概念

阵列：集中排布在一个相对独立的矩形区域内基本单元的集合。根据主要内容及应用场景的不同，可分为表格、数组和矩阵。
  \begin{enumerate}
  \item 表格（table）：以文本为主要内容的一种阵列。表格内通常有根据需要绘制的用以分隔基本单元的线条。在主体阵列之外，还可能附属有标题、注释等其他元素。标题（如有）通常位于表格主体内容的上方，注释（如有）通常位于表格主体内容的下（后）方。有的注释可能未紧随表格，而排布在文档的其他区域，如页脚区、边注区等。
  \item 数组（array）：以数学式（或符号）为主要内容的一种表格。数组通常不设标题。
  \item 矩阵（matrix）：一种以数学式（或数学符号）为基本单元的一种表格，并通常以圆括号“|( )|”、方括号“|[ ]|”、花括号“|{ }|”、单竖线“\textbar \quad \textbar”、双竖线“\textbardbl \quad \textbardbl”等符号将全部内容包含其中，并与外部内容进行分隔。矩阵通常不设标题。
%  \par
%  {\bfseries{后文中的“表格”有时特指表格，在不引起岐义的情况下，有时也意同“阵列”，请根据上下文确定其具体含义。}}
  \end{enumerate}
\item 阵列结构有关概念
  \begin{enumerate}
  \item 单元格（cell）：组成阵列的基本单元。单元格内部又可细分为内容和内容周围的间距。
  \item 块（block）：呈矩形状排布的若干相邻单元格的集合，类似于 |Excel| 中“合并单元格”的概念。需要特别说明的是，块也可以由 1 个单元格组成。详见~p.\pageref{Block}。
  \par
  {\bfseries{后文中的“单元格”有时特指“单元格”，在不引起岐义的情况下，有时也指“单元格”和“块”的统称，请根据上下文确定其具体含义。}}
  \item 行（row）：阵列的子集，此子集内的基本单元在一个横向区域内左右依次排布。
  \item 列（column）：阵列的子集，此子集内的基本单元在一个纵向区域内上下依次排布。
  \item 外部行（exterior row）：在阵列主体区域之外扩展的行，常用于对阵列主体区域的补充或说明。
%  在本译文中，也称表外行。
    \begin{enumerate}
      \item 阵列上方外部行（first-row）：位于阵列首行之前（上方）的外部行。
      \item 阵列下方外部行（last-row）：位于阵列末行之后（下方）的外部行。
    \end{enumerate}
  \item 外部列（exterior column）：在阵列主体区域之外扩展的列，常用于对阵列主体区域的补充或说明。
%  在本译文中，也称表外列。
    \begin{enumerate}
      \item 阵列左侧外部列（first-column）：位于阵列首列之前（左侧）的外部列。
      \item 阵列右侧外部列（last-column）：位于阵列末列之后（右侧）的外部列。
    \end{enumerate}
  \end{enumerate}

关于阵列外部的行和列，详见~p.\pageref{zm:ExteriorRowAndColumn}。

阵列的结构模型见图~\ref{fig:ArrayStructureFig}。

\begin{figure}[H]
\centering
%%\vspace{2.5ex}
%\tikzset{highlightrow/.style={rectangle,
%    fill=red!15,
%    blend mode = multiply, 
%    rounded corners = 0 mm, 
%    inner sep=1pt,
%    fit = #1}}
%
%\tikzset{highlightcolumn/.style={rectangle,
%    fill=green!15,
%    blend mode = multiply, 
%    rounded corners = 0 mm, 
%    inner sep=1pt,
%    fit = #1}}
%
%\tikzset{highlightcolumn/.style={rectangle,
%    fill=green!15,
%    blend mode = multiply, 
%    rounded corners = 0 mm, 
%    inner sep=1pt,
%    fit = #1}}
%
%\tikzset{highlightfirstrow/.style={rectangle,
%    fill=purple!40,
%    blend mode = multiply, 
%    rounded corners = 0 mm, 
%    inner sep=1pt,
%    fit = #1}}
%
%\tikzset{highlightfirstcolumn/.style={rectangle,
%    fill=olive!40,
%    blend mode = multiply, 
%    rounded corners = 0 mm, 
%    inner sep=1pt,
%    fit = #1}}
%
%\tikzset{highlightlastrow/.style={rectangle,
%    fill=orange,
%    blend mode = multiply, 
%    rounded corners = 0 mm, 
%    inner sep=1pt,
%    fit = #1}}
%
%\tikzset{highlightlastcolumn/.style={rectangle,
%    fill=yellow,
%    blend mode = multiply, 
%    rounded corners = 0 mm, 
%    inner sep=1pt,
%    fit = #1}}
%
%\[\begin{pNiceMatrix}[name=ArrayStructure,first-row,last-row,first-col,last-col,nullify-dots,rules/color = blue,margin,extra-margin=2pt]
%  %  \renewcommand{\arraystretch}{.5}
%  & R_{01}    & \Cdots &        & R_{04}    &        \\
%  C_{10}    & a_{11} & \Block[draw]{}{a_{12}} & a_{13} & a_{14} & C_{15}    \\
%  \Vdots & a_{21} & a_{22} & a_{23} & a_{24} & \Vdots \\
%  & \Block[draw]{2-2}{A} &  & a_{33} & a_{34} &        \\
%  C_{40}    & \NotEmpty &  & a_{43} & a_{44} & C_{45}    \\
%  & R_{51}    & \Cdots &        & R_{54}    &   \\  
%  \CodeAfter {
%    \tikz \node [highlightrow = (2-1) (2-4)] {} ; 
%    \tikz \node [highlightcolumn = (1-3) (4-3)] {} ; 
%    \tikz \node [highlightfirstrow = (0-1) (0-4)] {} ;
%    \tikz \node [highlightfirstcolumn = (1-0) (4-0)] {} ;
%    \tikz \node [highlightlastrow = (5-1) (5-4)] {} ;
%    \tikz \node [highlightlastcolumn = (1-5) (4-5)] {} ;
%        \linespread{.8} 
%    \tikz \draw[black,Latex-] (4-|1) -- +(-8ex,0) node[anchor = east,align=center] {块\\（block）};
%  }
%\end{pNiceMatrix}\]
%\tikz[remember picture,overlay] {
%  \linespread{.8}
%  \draw[blue,black,Latex-] (ArrayStructure-1-2) -- +(0,6ex) node[anchor =  south]{单元格（cell）};
%  \draw[red!60,black,Latex-] (ArrayStructure-2-4) -- +(10ex,0) node[anchor =  west]{行（row）};
%  \draw[green,black,Latex-] (ArrayStructure-4-3) -- +(0,-6ex) node[anchor =  north]{列（column）};
%  \draw[purple!60,black,Latex-] (ArrayStructure-0-4) -- +(10ex,0) node[anchor =  west,align=left]{阵列上方外部行\\（first row）};
%  \draw[orange,black,Latex-] (ArrayStructure-5-4) -- +(10ex,0) node[anchor =  west,align=left]{阵列下方外部行\\（last row）};
%  \draw[olive!80,black,Latex-] (ArrayStructure-4-0) -- +(0,-10ex) node[anchor =  north,align=center]{阵列左侧外部列\\（first column）};
%  \draw[yellow,black,Latex-] (ArrayStructure-4-5) -- +(0,-10ex) node[anchor =  north,align=center]{阵列右侧外部列\\（last column）};
%}
\includegraphics{ArrayStructureFig}
\caption{nicematrix 中阵列结构模型示意图}
\label{fig:ArrayStructureFig}
\end{figure}

%在图~\ref{fig:ArrayStructureFig} 中，“A” 所在区域是由4个单元格合并而成，在 |nicematrix| 中称为“块”。

\item 阵列结构附属概念
\begin{enumerate}
\item 定界符（delimiter）：用以将阵列（通常是矩阵）作为一个整体与文档其他内容分隔的符号。定界符通常左右对称，常用的定界符类型如下：

\begin{center}
  \begin{NiceTabular}{ccl}\toprule
    定界符样式                     & 英文         & 助记  \\\midrule
    \verb|( )|                    & parentheses  & p \\
    \verb|[ ]|                    & brackets     & b \\
    \verb|{ }|                    & Brace        & B \\
    \textbar \quad \textbar       & vertical bar &v  \\
    \textbardbl \quad \textbardbl & Vertical bar & V \\\bottomrule
  \end{NiceTabular}
\end{center}

非对称、非常规定界符有关内容见~p.~\pageref{zm:非对称定界符}。

\item 框线（line）：阵列内部及四周用以分隔单元格、块、行、列的线条。框线既包含阵列中显式绘出的实体线条，也包含未实际绘出的“虚拟”线条。框线的属性主要有方向、型式、宽度、颜色、编号。
  \begin{enumerate}
  \item 方向（direction）：分横线（hline，也称行线）、竖线（vline，也称列线）、斜线（详见~p.~\pageref{zm:斜线}、p.~\pageref{zm:对角线}）。
  \item 型式（style）：含线条主体及线条两端的样式，如虚实、两端的箭头等。详见~p.~\pageref{Cdots}。
  \item 宽度（width）：指线条的粗细。有的线条会计入阵列的总体宽度和高度，有的则不计入。详见~p.~\pageref{zm:RulesWidthColor}。
  \item 颜色（color）：不言自明。详见~p.~\pageref{zm:RulesWidthColor}。
  \item 编号（number）：用于标识线条的数字序号。
  \end{enumerate}
\item 空白（space）：指单元格内容的边缘与其上下或左右框线之间的空白区域。
  \begin{enumerate}
  \item 水平空白：在列线（不论是否显式绘出）左右插入的空白，也可理解为列间距。详见~p.~\pageref{zm:arraycolsep}。
    \begin{enumerate}
      \item 阵列内部列间空白：在阵列内部列线（不含最外侧列线）左右分别插入的空白，可理解为列线与单元格内容左（右）侧之间的距离。
      \item 阵列整体两侧空白：在阵列两侧列线之外插入的空白，可理解为阵列作为一个整体与文档其他内容的左右间距。
    \end{enumerate}
  阵列水平（列间）空白见图~\ref{fig:阵列水平（列间）空白示意图}。
\newcommand{\myCellSpaceTopLimit}{1cm}
\newcommand{\myCellSpaceBottomLimit}{.8cm}
\setlength{\arraycolsep}{1.5cm}
\begin{figure}[htbp]
  \centering
  \[
  \begin{NiceMatrix}[name=CellSpace,cell-space-top-limit = \myCellSpaceTopLimit,cell-space-bottom-limit = \myCellSpaceBottomLimit,create-medium-nodes,create-large-nodes,hvlines,rules/color=gray,baseline=c,
    code-after = {\begin{tikzpicture}
        \node [blend mode = multiply,fill = lightgray!50,inner sep = 0 pt, fit = (1-1)] {} ;
        \node [blend mode = multiply,fill =  lightgray!50,inner sep = 0 pt,fit = (1-2)] {} ;
        \node [blend mode = multiply,fill =  lightgray!50,inner sep = 0 pt,fit = (2-1)] {} ;
        \node [blend mode = multiply,fill =  lightgray!50,inner sep = 0 pt,fit = (2-2)] {} ;
        %  列虚线（第1列外左侧）
        \draw[red,dashed] ($(1-|1)+(-\arraycolsep,0)$) -- ($(3-|1)+(-\arraycolsep,0)$);
        %  列虚线（第1列内左侧）
        \draw[red,dashed] ($(1-|1)+(\arraycolsep,0)$) -- ($(3-|1)+(\arraycolsep,0)$);
        %  列虚线（第1列内右侧）
        \draw[red,dashed] ($(1-|2)+(-\arraycolsep,0)$) -- ($(3-|2)+(-\arraycolsep,0)$);
        %  列虚线（第2列内左侧）  
        \draw[red,dashed] ($(1-|2)+(\arraycolsep,0)$) -- ($(3-|2)+(\arraycolsep,0)$);
        %  列虚线（第2列内右侧）  
        \draw[red,dashed] ($(1-|3)+(-\arraycolsep,0)$) -- ($(3-|3)+(-\arraycolsep,0)$);
        %  列虚线（第2列外右侧）  
        \draw[red,dashed] ($(1-|3)+(\arraycolsep,0)$) -- ($(3-|3)+(\arraycolsep,0)$);
        %  水平间距+箭头（第1列外左侧）
        \draw ($(1-|1)$) edge["水平\\空白" below,align=center,yshift=-\myCellSpaceTopLimit,blue,Latex-Latex]  ($(1-|1)+(-\arraycolsep,0)$);
        %  水平间距+箭头（第1列内左侧）
        \draw ($(1-|1)$) edge["水平\\空白" below,align=center,yshift=-\myCellSpaceTopLimit,blue,Latex-Latex]  ($(1-|1)+(\arraycolsep,0)$);
        %  水平间距+箭头（第1列内右侧）
        \draw ($(1-|2)$) edge["水平\\空白" below,align=center,yshift=-\myCellSpaceTopLimit,blue,Latex-Latex]  ($(1-|2)+(-\arraycolsep,0)$);
        %  水平间距+箭头（第2列内左侧）
        \draw ($(1-|2)$) edge["水平\\空白" below,align=center,yshift=-\myCellSpaceTopLimit,blue,Latex-Latex]  ($(1-|2)+(\arraycolsep,0)$);
        %  水平间距+箭头（第2列内右侧）
        \draw ($(1-|3)$) edge["水平\\空白" below,align=center,yshift=-\myCellSpaceTopLimit,blue,Latex-Latex]  ($(1-|3)+(-\arraycolsep,0)$);
        %  水平间距+箭头（第2列外右侧）
        \draw ($(1-|3)$) edge["水平\\空白" below,align=center,yshift=-\myCellSpaceTopLimit,blue,Latex-Latex]  ($(1-|3)+(\arraycolsep,0)$);
    \end{tikzpicture}}
    ]
    A & a + b \\
    a & B
  \end{NiceMatrix}
  \]
  \caption{阵列水平（列间）空白示意图}
  \label{fig:阵列水平（列间）空白示意图}
\end{figure}
  \item 垂直空白（cell-space-limits）：在单元格内容顶部和底部插入的的空白，也可理解为行间距。详见~p.~\pageref{cellspacelimits}。
    \begin{enumerate}
    \item 单元格顶部空白（cell-space-top-limit）：指在单元格内容顶部之上插入的空白，即单元格内容顶部与其上方行线之间的距离。
    \item 单元格底部空白（cell-space-bottom-limit）：指在单元格内容底部之下插入的空白，即单元格内容底部与其下方行线之间的距离。
    \end{enumerate}
  阵列垂直（行间）空白见图~\ref{fig:阵列垂直（行间）空白示意图}。
  \end{enumerate}

\begin{figure}[htbp]
  \centering
%  \[\begin{NiceMatrix}[name=HSpace,cell-space-top-limit = \myCellSpaceTopLimit,cell-space-bottom-limit = \myCellSpaceBottomLimit,create-medium-nodes,create-large-nodes,hvlines,rules/color=gray,
%    code-after = {\begin{tikzpicture}
%        \node [blend mode = multiply,fill = red!15,inner sep = 0 pt, fit = (1-1)] {} ;
%        \node [blend mode = multiply,fill = red!15,inner sep = 0 pt,fit = (1-2)] {} ;
%        \node [blend mode = multiply,fill = red!15,inner sep = 0 pt,fit = (2-1)] {} ;
%        \node [blend mode = multiply,fill = red!15,inner sep = 0 pt,fit = (2-2)] {} ;
%        %  蓝色行底线（第1行）
%        \draw[blue,dashed] ($(2-|1)+(0,\myCellSpaceBottomLimit)$) -- ($(2-|3)+(0,\myCellSpaceBottomLimit)$);
%        %  蓝色行底线（第2行）
%        \draw[blue,dashed] ($(3-|1)+(0,\myCellSpaceBottomLimit)$) -- ($(3-|3)+(0,\myCellSpaceBottomLimit)$);
%        %  红色行顶线（第1行）
%        \draw[red,dashed] ($(1-|1)+(0,-\myCellSpaceTopLimit)$) -- ($(1-|3)+(0,-\myCellSpaceTopLimit)$);
%        %  红色行顶线（第2行）
%        \draw[red,dashed] ($(2-|1)+(0,-\myCellSpaceTopLimit)$) -- ($(2-|3)+(0,-\myCellSpaceTopLimit)$);
%        %  红色箭头+标注（第1行），单元格顶部空白
%        \draw ($(1-|3)$) edge["单元格顶部空白" right,xshift=-.1cm,red,Latex-Latex]  ($(1-|3)+(0,-\myCellSpaceTopLimit)$);
%        %  红色箭头+标注（第2行），单元格顶部空白
%        \draw ($(2-|3)$) edge["单元格顶部空白" right,xshift=-.1cm,red,Latex-Latex]  ($(2-|3)+(0,-\myCellSpaceTopLimit)$);
%        %  蓝色箭头+标注（第1行），单元格底部空白
%        \draw ($(2-|3)$) edge["单元格底部空白" right,xshift=-.1cm,blue,Latex-Latex]  ($(2-|3)+(0,\myCellSpaceBottomLimit)$);
%        %  蓝色箭头+标注（第2行），单元格底部空白
%        \draw ($(3-|3)$) edge["单元格底部空白" right,xshift=-.1cm,blue,Latex-Latex]  ($(3-|3)+(0,\myCellSpaceBottomLimit)$);
%    \end{tikzpicture}}]
%    A & a + b \\
%    a & B\\
%  \end{NiceMatrix}
%  \]
  \includegraphics{./cellspacefig.pdf}
  \caption{阵列垂直（行间）空白示意图}
  \label{fig:阵列垂直（行间）空白示意图}
\end{figure}

\setlength{\arraycolsep}{5pt}

  \colorbox{red!30}{注意：} 在 |nicematrix| 中，列间空白与行间空白的构建方法有很大不同。列间空白是在列线左右插入空白，因此插入的空白不计处单元格内容本身的宽度，而行间空白是以单元格内容为基础在其上下插入空白，因此插入的空白会计入单元格内容自身的高度。
\end{enumerate}
\item 节点：\pkg{nicematrix} 中的专有概念，主要用于标识阵列内的某一特定的区域或具有特殊意义和用途的点。可分为面状节点和点状节点。面状节点主要有空（非空）节点、普通节点、中等节点和大节点，点状节点指 $i$ 节点。
  \begin{enumerate}
  \item 空节点（empty node）：\pkg{nicematrix} 将其视作“空”的面状节点（详见~p.~\pageref{empty-cells}）。
  \item 普通节点（normal node）：单元格里内容部分所占的矩形区域。普通节点的宽度为单元格内容的自然宽度，高度为单元格内容的自然高度加上行间空白，即高度含内容上下空白。详见~p.~\pageref{zm:NormalNodes}。
  \item 中等节点（medium node）：节点的高度、宽度分别取本行和本列的最大值。即中等节点的宽度与本列中宽度最大单元格的自然宽度相同，高度与本行中高度最大单元格的高度相同。详见~p.~\pageref{zm:中等节点和大节点}。
  \item 大节点（large node）：阵列中由行线和列线（不论是否显式绘出）相交进而限定的矩形区域。即含单元格内容上下空白（cell-space-limits）、列线左右空白（arraycolsep 或 tabcolsep）以及阵列左右的空白（ margin ），但不含阵列左右的扩展空白（extra-margin）。详见~p.~\pageref{zm:中等节点和大节点}。  
\begin{figure}[htbp]
  \centering
  \[
  \begin{pNiceMatrix}[
    code-after = {\begin{tikzpicture}
        [every node/.style = {blend mode = multiply,
          fill = red!15,
          inner sep = 0 pt }]
        \node [fit = (1-1)] {} ;
        \node [fit = (1-3)] {} ;
        \node [fit = (2-2)] {} ;
        \node [fit = (3-1)] {} ;
        \node [fit = (3-3)] {} ;
        \node [fit = (1-2)] {} ;
        \node [fit = (2-1)] {} ;
        \node [fit = (2-3)] {} ;
        \node [fit = (3-2)] {} ;
    \end{tikzpicture}}]
    \Block{1-1}<\large>{A} & a + b & a + b + c \\
    a & \mbox{普通节点}     & a + b  \\
    a & a     & a 
  \end{pNiceMatrix}
  %\]
  %\[
  \begin{pNiceMatrix}[
    create-medium-nodes,
    code-after = {\begin{tikzpicture}
        [every node/.style = {fill = red!15,
          blend mode = multiply,
          inner sep = 0pt},
        name suffix = -medium]
        \node [fit = (1-1)] {} ;
        \node [fit = (1-2)] {} ;
        \node [fit = (1-3)] {} ;
        \node [fit = (2-1)] {} ;
        \node [fit = (2-2)] {} ;
        \node [fit = (2-3)] {} ;
        \node [fit = (3-1)] {} ;
        \node [fit = (3-2)] {} ;
        \node [fit = (3-3)] {} ;
    \end{tikzpicture}}]
    \Block{1-1}<\large>{A} & a + b & a + b + c \\
    a & \mbox{中等节点}     & a + b  \\
    a & a     & a 
  \end{pNiceMatrix}
  %\]
  %\[
  \begin{pNiceMatrix}[
    create-large-nodes,margin,extra-margin=3pt,
    code-after = {\begin{tikzpicture}
        [every node/.style = {blend mode = multiply,
          inner sep = 0 pt},
        name suffix = -large]
        \node [fit = (1-1),fill = red!15] {} ;
        \node [fit = (1-3),fill = red!15] {} ;
        \node [fit = (2-2),fill = red!15] {} ;
        \node [fit = (3-1),fill = red!15] {} ;
        \node [fit = (3-3),fill = red!15] {} ;
        \node [fit = (1-2),fill = blue!15] {} ;
        \node [fit = (2-1),fill = blue!15] {} ;
        \node [fit = (2-3),fill = blue!15] {} ;
        \node [fit = (3-2),fill = blue!15] {} ;
    \end{tikzpicture}}]
    \Block{1-1}<\large>{A} & a + b & a + b + c \\
    a & \mbox{大节点}     & a + b  \\
    a & a     & a 
  \end{pNiceMatrix}
  \]
  \caption{nicematrix 中普通节点（左）、中等节点（中）、大节点（右）示意图}
  \label{zm:NormalMediumLargeNodesFigure}
\end{figure}
  \item $i$ 节点（intersection node）：行线和列线（无论是否显式绘出）的交点，也可以理解为单元格所占矩形区域四周的顶点。详见图~\ref{fig:i-node-number}、p.~\pageref{nodes-i}。
  \end{enumerate}

%todo
%\item 行高、列宽
%\begin{enumerate}
%  \item 行高：指相邻两个行线内侧（无论是否显式绘出）之间的距离。由上文分析可知，行高 = 单元格所在行高度最大单元格内容的自然高度 + 单元格顶部空白 + 单元格底部空白 + |\arraystretch|；
%  \item 列宽：指相邻两个列线（无论是否显式绘出）内侧之间的距离。由主文分析可知，列宽 = 单元格所在列宽度最大单元格内容的自然宽度 + 2 $\times$ 阵列内部列间空白。
%  \item 线宽计入阵列尺寸。
%\end{enumerate}
%\begin{enumerate}
%  \item 阵列高度：阵列上下两端
%  \item 阵列宽度：
%\end{enumerate}

\item 编号（number）：阵列中各元素的序号
  \begin{enumerate}
  \item 行号（row number）：自上而下编号，阵列上方外部行（first-row）的编号为 $0$；主体区域行的起始序号为  $1$ 。引用格式“ $i$ ”，主要用于阵列与外部元素对齐，详见~p.~\pageref{zm:行线对齐}。
  \item 列号（column number）：由左至右编号，阵列左侧外部列（first-column）的编号为 $0$；主体区域列的起始序号为  $1$ 。
  \item 单元格号（cell number）：表示单元格所在行号和列号，引用格式阵列外为“(\textsl{name}-$i$-$j$)”，阵列内为“($i$-$j$)”。其中，|name| 为阵列名称，$i$ 为单元格所在行号，$j$ 为单元格所在列号。详见~p.~\pageref{zm:单元格编号}。
  \item 块号（block number）：块内左上角单元格合并前所在行号、列号。
  \item 行线号（line number）：阵列主体区域行线的编号，从 1 开始。引用格式 “ |line|-$i$ ”，主要用于阵列与外部元素对齐，详见~p.~\pageref{zm:行号对齐}。
  \item 列线号（column number）：阵列主体区域列线的编号，从 1 开始。
  
  |nicematrix| 中行、行线、列、列线的编号方式见图~\ref{fig:numbers}。
  
    \begin{figure}[H]
    \tikzset{highlightrow/.style={rectangle,
        fill=red!15,
        blend mode = multiply, 
        rounded corners = 0 mm, 
        inner sep=1pt,
        fit = #1}}
    
    \tikzset{highlightcolumn/.style={rectangle,
        fill=green!15,
        blend mode = multiply, 
        rounded corners = 0 mm, 
        inner sep=1pt,
        fit = #1}}
    \centering
    %    \vspace{2ex}
    \[\begin{NiceArray}[name=numbers,first-row,last-row,first-col,last-col,nullify-dots,rules/color = gray,margin,extra-margin=2pt,hvlines]{cccc}
      %  \renewcommand{\arraystretch}{.5}
      0& 1    & 2 &  3      & 4    &  5      \\
      1    & a_{11} & a_{12} & a_{13} & a_{14} & C_{15}    \\
      2 & a_{21} & a_{22} & a_{23} & a_{24} & \Vdots \\
      3& a_{31} & a_{32} & a_{33} & a_{34} &        \\
      4    & a_{41} & a_{42} & a_{43} & a_{44} & C_{45}    \\
      5& R_{51}    & \Cdots &        & R_{54}    &   \\  
      \CodeAfter {
        %列线号
        \foreach \j in {1,...,5}
        \tikz   \draw[red,Latex-] (1-|\j) -- +(0,4ex) node[anchor =  south]{\j};
        %行线号
        \foreach \i in {1,...,5}
        \tikz   \draw[blue,Latex-] (\i-|5) -- +(8ex,0) node[anchor =  west]{\i};
        %行号
        \tikz \node [highlightrow = (0-0) (0-5)] {} ; 
        %列号
        \tikz \node [highlightcolumn = (0-0) (5-0)] {} ; 
      }
    \end{NiceArray}\]
    图例：淡绿色背景（\tikz \fill[green!30] (0,0) rectangle (2ex,1.5ex);） 区域内的数字表示行号，\\\hspace{3em}粉红色背景（\tikz \fill[red!30] (0,0) rectangle (2ex,1.5ex);）区域内的数字表示列号，\\\hspace{2.5em}红色数字为列线号，蓝色数字为行线号。
    \caption{nicematrix 中行、列、行线、列线编号示意图}
    \label{fig:numbers}
  \end{figure}
  
  \item $i$ 节点号：引用格式“ |(|$i$\verb+-|+$j$|)| ”，其中 $i$ 为节点所在行线号， $j$ 为节点所在列线号。如图~\ref{fig:i-node-number}~示。关于 $i$ 节点号更详细的内容，请参见~p.~\pageref{nodes-i}。
  
  \begin{figure}[H]
    \centering
    \vspace{4ex}
    \begin{NiceTabular}{ccc}[hvlines,rules/width=1pt,rules/color=gray,cell-space-limits = .5cm,columns-width = 2cm]
      &  &  \\
      &  &  \\
      &  &  \\
      \CodeAfter
      \begin{tikzpicture}
        \small
        \foreach \i in {1,2,3,4}
        \foreach \j in {1,2,3,4}
        { 
          \fill [red] (\i-|\j) circle (0.5mm) ; 
          \node [red,above right] at (\i-|\j) {(\i-\textbar\j)} ; 
        } 
      \end{tikzpicture}
    \end{NiceTabular}
  \caption{nicematrix 中 $i$ 节点编号示意图}
  \label{fig:i-node-number}
  \end{figure}
  
  \end{enumerate}
\item 对齐位置：阵列作为一个整体与外部元素进行对齐时的基线。
  \begin{enumerate}
  \item 阵列中某一行的基线；
  \item 阵列中的某一特定行线；
  \item 阵列的顶部（首行基线）、中部、底部（末行基线）。
  \end{enumerate}

详见~p.~\pageref{zm:阵列对齐位置}。
\end{enumerate}

\clearpage

%%---------原文-------
%\begin{abstract}
%The LaTeX package \pkg{nicematrix} provides new environments similar to the
%classical environments |{tabular}|, |{array}| and |{matrix}| of \pkg{array}
%and \pkg{amsmath} but with extended features. 
%\end{abstract}
%%---------原文-------

\pagenumbering{arabic}
\setcounter{footnote}{0}
\phantomsection
\addcontentsline{toc}{section}{摘要}
%%---------译文-------
\begin{abstract}
\pkg{nicematrix} 宏包提供了与 \pkg{array} 和 \pkg{amsmath} 宏包的经典环境|{tabular}|、|{array}| 和 |{matrix}| 相类似的新环境，但在其基础上进行了丰富的扩展。
\end{abstract}
%%---------译文-------


\vspace{1cm}

\hspace{1cm}
$\begin{bNiceArray}{cccc}[first-row,first-col,
                          code-for-first-col=\color{blue}\scriptstyle,
                          code-for-first-row=\color{blue}\scriptstyle,
                          columns-width = auto]
       & C_1     & C_2    & \Cdots  & C_n    \\
L_1    & a_{11}  & a_{12}  & \Cdots  & a_{1n} \\
L_2    & a_{21}  & a_{22}  & \Cdots  & a_{2n} \\
\Vdots & \Vdots & \Vdots  & \Ddots  & \Vdots \\
L_n    & a_{n1}  & a_{n2}  & \Cdots  & a_{nn} 
\end{bNiceArray}$
\hspace{2cm}
\begin{NiceTabular}[c]{lSSSS}%
[code-before = \rowcolor{red!15}{1-2} \rowcolors{3}{blue!15}{}]
\toprule
\Block{2-1}{Product} & \multicolumn{3}{c}{dimensions (cm)} & \Block{2-1}{\rotate Price} \\
\cmidrule(rl){2-4} 
 & L & l & h \\
\midrule
small    & 3   & 5.5  & 1   & 30    \\
standard & 5.5 & 8    & 1.5 & 50.5  \\
premium  & 8.5 & 10.5 & 2   & 80    \\
extra    & 8.5 & 10   & 1.5 & 85.5  \\
special  & 12  & 12   & 0.5 & 70    \\
\bottomrule
\end{NiceTabular}



\vspace{1cm}
%%---------原文-------
%The package \pkg{nicematrix} is entirely contained in the file
%|nicematrix.sty|. This file may be put in the current directory or in a
%|texmf| tree. However, the best is to install \pkg{nicematrix} with a TeX
%distribution as MiKTeX or TeXlive.
%%---------原文-------
%%---------译文-------
\pkg{nicematrix}宏包的功能全部在 |nicematrix.sty| 文件中实现。
该文件可以放置在当前目录或 |texmf| 目录树中。
作者建议使用 MiXTeX 或 TeXlive 等 TeX 发行版安装本宏包。
%%---------译文-------

\bigskip
%%---------原文-------
%\emph{Remark}: If you use LaTeX via Internet with, for example, Overleaf, you
%can upload the file |nicematrix.sty| in the repertory of your 
%project in order to take full advantage of the latest version de
%\pkg{nicematrix}.\footnote{The latest version of the file
%\verb|nicematrix.sty| may be downloaded from the \textsc{svn} server of
%TeXLive:\newline
%\small
%\url{https:www.tug.org/svn/texlive/trunk/Master/texmf-dist/tex/latex/nicematrix/nicematrix.sty}}
%%---------原文-------
%%---------译文-------
\emph{注：}如果通过 Internet 使用 LaTeX（如 Overleaf ），可以在项目目录中上传 |nicematrix.sty| 文件，以使用最新版本的 \pkg{nicematrix} 。
\footnote{最新版本的 |nicematrix.sty| 可以在TeXLive下载：\newline
  \small
  \url{https:www.tug.org/svn/texlive/trunk/Master/texmf-dist/tex/latex/nicematrix/nicematrix.sty}}
%%---------译文-------

\bigskip
%%---------原文-------
%This package can be used with |xelatex|, |lualatex|, |pdflatex| but also by
%the classical workflow |latex|-|dvips|-|ps2pdf| (or Adobe Distiller).
%\textsl{However, the file nicematrix.dtx of the present documentation should
%be compiled with XeLaTeX.}
%%---------原文-------
%%---------译文-------
\pkg{nicematrix}宏包可以用 |xelatex| 、|lualatex| 和 |pdflatex| 引擎编译，也可以使用经典的编译流程 |latex| - |dvips| - |ps2pdf|（或 Adobe Distiller）。\textsl{但是，本文档的源文件 nicematrix.dtx 文件只能使用 XeLaTeX 进行编译。}
%%---------译文-------

\bigskip
%%---------原文-------
%This package requires and \textbf{loads} the packages \pkg{l3keys2e},
%\pkg{array}, \pkg{amsmath}, \pkg{pgfcore} and the module \pkg{shapes} of
%\textsc{pgf} (\pkg{tikz}, which is a layer over \textsc{pgf} is \emph{not}
%loaded). The final user only has to load the package with
%|\usepackage{nicematrix}|.
%%---------原文-------
%%---------译文-------
本宏包依赖并自动载入 \pkg{l3keys2e} 、\pkg{array}、\pkg{amsmath}、\pkg{pgfcore}等宏包和 \textsc{pgf} 宏包的 \pkg{shapes} 模块（不加载\tikzname）。用户只需使用 |\usepackage{nicematrix}| 命令即可载入本宏包。
%%---------译文-------

\bigskip
%%---------原文-------
%The idea of \pkg{nicematrix} is to create \textsc{pgf} nodes under the cells
%and the positions of the rules of the tabular created by \pkg{array} and to
%use these nodes to develop new features. As usual with \textsc{pgf}, the
%coordinates of these nodes are written in the |.aux| to be used on the next
%compilation and that's why \pkg{nicematrix} may need \textbf{several
%compilations}. 
%%---------原文-------
%%---------译文-------
\pkg{nicematrix} 的基本思想是利用 \pkg{array} 宏包生成阵列的单元格（cell）和框线位置，利用 \textsc{pgf} 在单元格下层生成节点（node），并利用这些位置和节点进一步开发新的功能。由于 \textsc{pgf} 将节点坐标存储于 |.aux| 文件中用于再次编译，因此使用了 \pkg{nicematrix} 宏包的源文件可能需要\textbf{多次}编译才能正确输出结果。
%%---------译文-------

\bigskip
%%---------原文-------
%Most features of \pkg{nicematrix} may be used without explicit use of
%\textsc{pgf} or Tikz (which, in fact, is not loaded by default).
%%---------原文-------
%%---------译文-------
无需显式载入 \textsc{pgf} 或 \tikzname （默认不加载），就可以使用\pkg{nicematrix}宏包的绝大部分功能。
%%---------译文-------

\bigskip
%%---------原文-------
%A command |\NiceMatrixOptions| is provided to fix the options (the
%scope of the options fixed by this command is the current TeX group: they are
%semi-global).
%%---------原文-------
%%---------译文-------
\pkg{nicematrix} 提供了 |\NiceMatrixOptions| 命令用于对各种选项进行设置（此命令影响的范围是当前的 TeX 组，它们是半全局的）。
%%---------译文-------

%\noindent\hrulefill\NFTN\hrulefill
\bigskip
\NFTN “半全局”应指会影响当前文档内命令后的所有阵列，也即如果在导言区使用 |\NiceMatrixOptions| 命令，会影响整个文档，如果在正文区使用，影响范围从当前位置直至文末。 |\NiceMatrixOptions| 不能在 |nicematrix| 的环境中直接使用，但可以通过变通的方法将 |\NiceMatrixOptions| 的作用范围限制在一个环境内。具体方法是使用 |xparse| 宏包的 |\NewDocumentEnvironment| 命令新建一个环境，这也是本文档作者采用的方法。具体代码如下：

|\NewDocumentEnvironment {scope} {} {} {}|

%\medskip
%\noindent\hrulefill




\newpage
%\section{The environments of this package} 
\section[nicematrix宏包提供的环境]{\pkg{nicematrix}宏包提供的环境}


%The package \pkg{nicematrix} defines the following new environments.
\pkg{nicematrix}宏包定义了以下14种新环境：

\medskip
\begin{ttfamily}
\setlength{\tabcolsep}{3mm}
\begin{tabular}{llll}
\{NiceTabular\}  & \{NiceArray\}  & \{NiceMatrix\}   \\
\{NiceTabular*\} & \{pNiceArray\} & \{pNiceMatrix\}  \\
               & \{bNiceArray\} & \{bNiceMatrix\}  \\
               & \{BNiceArray\} & \{BNiceMatrix\}  \\
               & \{vNiceArray\} & \{vNiceMatrix\}  \\
               & \{VNiceArray\} & \{VNiceMatrix\}  
\end{tabular}
\end{ttfamily}


\medskip

%The environments |{NiceArray}|, |{NiceTabular}| and |{NiceTabular*}| are
%similar to the environments |{array}|, |{tabular}| and |{tabular*}| of the
%package \pkg{array} (which is loaded by \pkg{nicematrix}).
|{NiceArray}|、|{NiceTabular}| 和 |{NiceTabular*}| 环境分别与 \pkg{array}  宏包（\pkg{nicematrix} 默认载入）中的 |{array}|、|{tabular}| 和 |{tabular*}| 环境相类似。

\medskip
%The environments |{pNiceArray}|, |{bNiceArray}|, etc. have no equivalent in
%\pkg{array}. 
|{pNiceArray}| 和 |{bNiceArray}| 在\pkg{array} 宏包中无对应环境。

\medskip
%The environments |{NiceMatrix}|, |{pNiceMatrix}|, etc. are similar to the
%corresponding environments of \pkg{amsmath} (which is loaded by
%\pkg{nicematrix}): |{matrix}|, |{pmatrix}|, etc. 
|{NiceMatrix}|、|{pNiceMatrix}| 等环境分别与 \pkg{amsmath} 宏包（\pkg{nicematrix}默认载入） 中的 |{matrix}|、|{pmatrix}| 等环境相类似。

\begin{framed}
\NFTN 上述 14 个环境主要用于生成单个阵列。尽管未在此处明确列出，但实际上 |nicematrix| 还提供有 |NiceMatrixBlock| 环境，用于生成阵列“块”。|NiceMatrixBlock| 的典型应用场景之一是使多个矩阵的列宽相同，其用法见~p.~\pageref{zm:NiceMatrixBlock1}、p.~\pageref{zm:NiceMatrixBlock2}。
\end{framed}

\medskip

%All the environments of the package \pkg{nicematrix} accept, between square
%brackets, an optional list of \textsl{key=value} pairs. \textbf{There must be
%no space before the opening bracket (|[|) of this list of options.}
\pkg{nicematrix} 宏包提供的所有环境均可接受以 “[\texttt{<选项> = <值>}]”形式给出的参数列表。\textbf{需要注意的是左方括号“|[|”前不能有空格}。

\bigskip
%\textbf{Important}
\textbf{重要提示}

%Before the version 5.0, it was mandatory to use, for technical reasons, the 
%letters |L|, |C| et |R| instead of |l|, |c| et |r| in the preambles of the
%environments of \pkg{nicematrix}. If we want to be able to go on using these
%letters, \pkg{nicematrix} must be loaded with the option |define-L-C-R|.
在v5.0之前，由于技术原因，在 |nicematrix| 环境的导言区中只能使用 |L|、|C| 和 |R|（表示列对齐方式） ，而不能用 |l|、|c| 和 |r|。 如果需要继续使用 |L|、|C| 和 |R|，则必须在加载 |nicematrix| 时使用 |define-L-C-R| 选项。
%\bigskip

\begin{Verbatim}
\usepackage[define-L-C-R]{nicematrix}
\end{Verbatim}

%\section{The vertical space between the rows}
\section{行间垂直空白（vertical space between the rows）}
\label{cellspacelimits}

%It's well known that some rows of the arrays created by default with LaTeX
%are, by default, too close to each other. Here is a classical example.
众所周知，默认情况下使用 LaTeX 创建的阵列的某些行的间距过小。一个典型的例子如下：

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=9cm]
$\begin{pmatrix}
  \frac12 & -\frac12 \\
  \frac13 &  \frac14 \\
\end{pmatrix}$
\end{BVerbatim}
$\begin{pmatrix}
\frac12 & -\frac12 \\
\frac13 & \frac14 \\
\end{pmatrix}$
\bigskip

%Inspired by the package \pkg{cellspace} which deals with that problem, the
%package \pkg{nicematrix} provides two keys |cell-space-top-limit| and
%|cell-space-bottom-limit| similar to the parameters |\cellspacetoplimit| and
%|\cellspacebottomlimit| of \pkg{cellspace}.
解决上述问题的一种方法是在单元格内容上方和（或）下方插入空白，如 \pkg{cellspace} 宏包定义的 |\cellspacetoplimit| 和 |\cellspacebottomlimit| 两个参数。
受 \pkg{cellspace} 的启发， |nicematrix| 提供了 |cell-space-top-limit| （行顶部最小间距） 和 |cell-space-bottom-limit| （行底部最小间距）两个选项解决行间垂直间距过小的问题。

\FTN{ |cell-space-top-limit| 指的是单元格内容与其上方行线（不论是否显式绘出）之间的最小间距；|cell-space-bottom-limit| 指的是单元格内容与其下方行线（不论是否显式绘出）之间的最小间距。之所以称“最小间距”，是由于同一行不同单元格的内容高度可能不同，只有高度最大的单元格内容与其上（下）方行线之间的距离等于参数设定的值，其余单元格内容与上（下）行线间距可能比参数值大。

如下例矩阵中左上角的元素 “1” ，它的高度明显小于右侧分数的高度，因此它与上方行线的间距小于通过 |cell-space-top-limit| 选项设定的最小间距“$0.5$ cm”，与下方行线的间距也小于通过 |cell-space-bottom-limit| 选项设定的最小间距 “$5$~pt”。}

\noindent\hrulefill\colorbox{red!30}{译者增补示例\ten}\hrulefill

\medskip
\begin{BVerbatim}[baseline=c,boxwidth=11cm]
\NiceMatrixOptions{~emphase#cell-space-top-limit = 0.5cm@,%
  ~emphase#cell-space-bottom-limit = 5pt@}
$\begin{pNiceMatrix}    \hline
  1       & -\frac12 \\ \hline
  \frac13 & -\frac13 \\ \hline
  \frac14 & -\frac14 \\ \hline
\end{pNiceMatrix}$
\end{BVerbatim}
\begin{scope}
\NiceMatrixOptions{cell-space-top-limit = 0.5cm,%
  cell-space-bottom-limit = 5pt}
$\begin{pNiceMatrix}
  \hline
  1       & -\frac12 \\
  \hline
  \frac13 & -\frac13 \\
  \hline
  \frac14 & -\frac14 \\
  \hline
\end{pNiceMatrix}$
\end{scope}

\medskip

\noindent\rule{\linewidth}{0.4pt}

\bigskip

使用 |cell-space-limits| 选项可以同时设置上述两个参数的值。

为与 |array| 和 |amsmath| 宏包保持相同的输出效果， |nicematrix| 中 |cell-space-top-limit|、|cell-space-top-limit| 和 |cell-space-limits| 选项的默认值都是 $0$~pt。建议将上述值设为 $1$~pt，具体可使用 |\NiceMatrixOptions| 命令进行设置。\footnote{需要指出的是，上述参数也适用于 \pkg{siunitx} 宏包的 |S| 型列，而 \pkg{cellspace}不能作用于 \pkg{siunitx} 宏包的 |S| 型列。}

\medskip
\begin{Verbatim}
  \NiceMatrixOptions{~emphase#cell-space-limits = 1pt@}
\end{Verbatim}

\begin{BVerbatim}[baseline=c,boxwidth=11cm]
$\begin{pNiceMatrix}
  \frac12 & -\frac12 \\
  \frac13 & \frac14 \\
\end{pNiceMatrix}$
\end{BVerbatim}
\begin{scope}
\NiceMatrixOptions{ cell-space-limits = 1pt }
$\begin{pNiceMatrix}
\frac12 & -\frac12 \\
\frac13 & \frac14 \\
\end{pNiceMatrix}$
\end{scope}


\bigskip
%\section{The vertical position of the arrays}
\section{阵列的垂直位置（vertical position of the arrays）}
\label{zm:阵列对齐位置}

%The package \pkg{nicematrix} provides a option |baseline| for the vertical
%position of the arrays. This option takes in as value an integer which is the
%number of the row on which the array will be aligned.
\pkg{nicematrix} 宏包提供了 |baseline| 选项用于指定将阵列作为一个整体与阵列外部元素对齐时的基线。|baseline| 选项的值可以是：

$\bullet$ 整数，表示阵列中的行号。
\label{zm:行号对齐}

\FTN{在阵列主体区域中，行自上而下编号，起始行号为 1 。阵列上方外部行的编号为0，但不能作为对齐基线使用。}

\medskip
\begin{BVerbatim}[baseline=c,boxwidth=9cm]
$A = \begin{pNiceMatrix}[~emphase#baseline=2@]
  \frac{1}{\sqrt{1+p^2}} & p & 1-p \\
  1                      & 1 & 1 \\
  1                      & p & 1+p
\end{pNiceMatrix}$
\end{BVerbatim}
$A = \begin{pNiceMatrix}[baseline=2]
\frac{1}{\sqrt{1+p^2}} & p & 1-p \\
1 & 1 & 1 \\
1 & p & 1+p
\end{pNiceMatrix}$

\medskip

%It's also possible to use the option |baseline| with one of the special values
%|t|, |c| or |b|. These letters may also be used absolutely like the option of
%the environments |{tabular}| and |{array}| of \pkg{array}. The initial value
%of |baseline| is~|c|. 

$\bullet$ |t|、|c| 或 |b|，分别表示对齐基线为阵列的顶部（top）、中部（center）和底部（bottom）。

\FTN{在阵列中，作为对齐基线的顶部指的是主体区域首行的基线，底部指的是主体区域末行的基线，中部不一定是精确某一行（的基线），而是指阵列在纵向上的中心位置。在下例的矩阵中，左上角第 1 个元素是使用长除法宏包 \pkg{longdivision} 生成的，它的高度明显大于同一行的其他元素。这个例子可以直观地说明当 |baseline = t| 时，阵列对齐基线的位置。其他对齐基线位置请自行测试。}

\noindent\hrulefill\colorbox{red!30}{译者增补示例\ten}\hrulefill

\medskip
\begin{BVerbatim}[baseline=t,boxwidth=9cm]
%\usepackage{longdivision}
$A = \begin{pNiceMatrix}[~emphase#baseline=t@]
  \intlongdivision{100}{22} & p & 1-p \\
  1                         & 1 & 1 \\
  1                         & p & 1+p\\
  \frac{1}{\sqrt{1+p^2}}    & p & 1
\end{pNiceMatrix}$
\end{BVerbatim}
$A = \begin{pNiceMatrix}[baseline=t]
\intlongdivision{100}{22} & p & 1-p \\
1 & 1 & 1 \\
1 & p & 1+p\\
\frac{1}{\sqrt{1+p^2}} & p & 1
\end{pNiceMatrix}$
\medskip

\noindent\rule{\linewidth}{0.4pt}

\medskip

与 \pkg{array} 宏包中的 |{tabular}| 和 |{array}| 环境类似，\pkg{nicematrix} 宏包中表示阵列对齐的位置 |t|、|c| 和 |b| 也可直接作为环境的参数。

\medskip
%In the following example, we use the option |t| (equivalent to |baseline=t|)
%immediately after an |\item| of list. One should remark that the presence of a
%|\hline| at the beginning of the array doesn't prevent the alignment of the
%baseline with the baseline of the first row (with |{tabular}| or |{array}| of
%\pkg{array}, one must use |\firsthline|.
在下例中，在列表环境中的列表项 |\item| 之后立即使用选项 |t|（等效于 |baseline = t|）。
应该指出的是，在阵列开头的行线命令 |\hline| 并不能阻止基线与第一行基线的对齐方式（当使用 |array| 宏包中的 |{tabular}| 或 |{array}| 环境时，必须使用 |\firsthline| ）。 

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=9cm]
\begin{enumerate}
  \item an item
  \smallskip
  \item \renewcommand{\arraystretch}{1.2}
  $\begin{NiceArray}~emphase#[t]@{lcccccc}
    \hline
    n   & 0 & 1 & 2 & 3 & 4  & 5 \\
    u_n & 1 & 2 & 4 & 8 & 16 & 32 
    \hline
  \end{NiceArray}$
\end{enumerate}
\end{BVerbatim}
%
\begin{minipage}{5cm}
\begin{enumerate}
\item an item
\smallskip
\item \renewcommand{\arraystretch}{1.2}
$\begin{NiceArray}[t]{lcccccc}
\hline
n   & 0 & 1 & 2 & 3 & 4  & 5  \\
u_n & 1 & 2 & 4 & 8 & 16 & 32 \\
\hline
\end{NiceArray}$
\end{enumerate}
\end{minipage}

\bigskip
%However, it's also possible to use the tools of \pkg{booktabs}: |\toprule|,
%|\bottomrule|, |\midrule|, etc.\par\nobreak
三线表宏包 \pkg{booktabs} 中的 |\toprule|、|\bottomrule| 和 |\midrule| 命令也可以在 \pkg{nicematrix} 的环境中直接使用。

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=9cm]
\begin{enumerate}
  \item an item
  \smallskip
  \item 
    $\begin{NiceArray}[t]{lcccccc}
      ~emphase#\toprule@
      n   & 0 & 1 & 2 & 3 & 4  & 5 \\
      ~emphase#\midrule@
      u_n & 1 & 2 & 4 & 8 & 16 & 32 
      ~emphase#\bottomrule@
    \end{NiceArray}$
\end{enumerate}
\end{BVerbatim}
\begin{minipage}{5cm}
  \begin{enumerate}
    \item an item
    \smallskip
    \item 
    $\begin{NiceArray}[t]{lcccccc}
      \toprule
      n   & 0 & 1 & 2 & 3 & 4  & 5  \\
      \midrule
      u_n & 1 & 2 & 4 & 8 & 16 & 32 \\
      \bottomrule
    \end{NiceArray}$
  \end{enumerate}
\end{minipage}

\bigskip
%It's also possible to use the key |baseline| to align a matrix on an
%horizontal rule (drawn by |\hline|). In this aim, one should give the value
%|line-|\textsl{i} where \textsl{i} is the number of the row following the
%horizontal rule.
$\bullet$ |line-|\textsl{i}，表示对齐基线为编号为 $i$ 的行线（下例中由 |\hline| 命令绘制）。
\label{zm:行线对齐}

\FTN{行线编号由 |nicematrix| 内部自动生成，无论是否显式绘出。行线自上而下编号，起始序号为 $1$ ，即第 $1$ 行顶部横线的编号为 $1$ ， 第 $2$ 行顶部横线的编号为 $2$ ，依此类推，详见~p~\pageref{fig:numbers}。}

\smallskip
\begin{Verbatim}
    \NiceMatrixOptions{cell-space-limits=1pt}
\end{Verbatim}

\smallskip
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
  $A=\begin{pNiceArray}{cc|cc}[~emphase#baseline=line-3@]
    \dfrac1A & \dfrac1B & 0 & 0 \\
    \dfrac1C & \dfrac1D & 0 & 0 \\
    \hline
    0        & 0        & A & B \\
    0        & 0        & D & D \\
  \end{pNiceArray}$
\end{BVerbatim}
\begin{scope}
  \NiceMatrixOptions{cell-space-limits=1pt}
  \raisebox{-5mm}{$A=\begin{pNiceArray}{cc|cc}[baseline=line-3]
      \dfrac1A & \dfrac1B & 0 & 0 \\
      \dfrac1C & \dfrac1D & 0 & 0 \\
      \hline
      0 & 0 & A & B \\
      0 & 0 & D & D \\
    \end{pNiceArray}$}
\end{scope}

%\section{The Blocks}
\section{块（blocks）}
\label{Block}

\subsection{概述}

%In the environments of \pkg{nicematrix}, it's possible to use the command
%|\Block| in order to place an element in the center of a rectangle of merged
%cells of the array.
在\pkg{nicematrix}的环境中，可以使用 |\Block| 命令将一个矩形区域内的多个的单元格合并为一个“块”（block），并使“块”内的内容在水平和垂直方向上均居中。

\FTN{“块”的概念与 |Excel| 软件中的“合并单元格”概念相类似。它们的区别在于“合并单元格”一般由多个单元格合并而成，而“块”可以仅由 $1$ 个单元格组成。}

%The command |\Block| must be used in the upper leftmost cell of the array with
%two arguments. 
|\Block| 命令必须在待合并区域左上角的单元格使用，并带有 $2$ 个参数：

\begin{itemize}
%\item The first argument is the size of the block with the syntax
%$i$\verb|-|$j$ where $i$ is the number of rows of the block and $j$ its number
%of columns. 
\item 第 1 个参数的形式为“$i$\verb|-|$j$”，表示“块”的大小。其中“$i$”是“块”占据的行数，“$j$”是“块”占据的列数。

%If this argument is empty, its default
%value is |1-1|. If the number of rows is not specified, or equal to |*|, the
%block extends until the last row (idem for the columns).
如果此参数为空，则其默认值为“|1-1|”。 如果未指定行数或行数等于“|*|”，则表示从当前行合并至阵列的最后一行。列参数与行参数的行为相同。

\FTN{\texttt{\textbackslash Block} 命令的默认值 |1-1| 表示将 1 行 1 列的区域（即当前单元格）视为 1 个“块”。这在某些场合下具有特殊用途。}

%\item The second argument is the content of the block. It's possible to use
%|\\| in that content to have a content on several lines. In |{NiceTabular}|
%the content of the block is composed in text mode whereas, in the other
%environments, it is composed in math mode.
\item 第 2 个参数表示“块”的内容。可以在参数中使用硬换行命令（“|\\|”），使“块”内产生多行排布的效果。 在 |{NiceTabular}| 环境中，“块”的内容按文本模式排布，在其他环境中，“块”的内容按数学模式排布。
\end{itemize}

\interitem
%Here is an example of utilisation of the command |\Block| in mathematical matrices.
以下是在矩阵中使用 |\Block| 命令生成“块”的示例。

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=11cm]
$\begin{bNiceArray}{ccc|c}[margin]
  ~emphase#\Block{3-3}{A}@ &               &   & 0      \\
                 & \hspace*{1cm} &   & \Vdots \\
                 &               &   & 0      \\
  \hline
  0              & \Cdots        & 0 & 0
\end{bNiceArray}$
\end{BVerbatim}
$\begin{bNiceArray}{ccc|c}[margin]
\Block{3-3}{A} & & & 0 \\
& \hspace*{1cm} & & \Vdots \\
& & & 0 \\
\hline
0 & \Cdots& 0 & 0
\end{bNiceArray}$

\bigskip
%One may wish to raise the size of the ``$A$'' placed in the block of the
%previous  example. Since this element is composed in math mode, it's not
%possible to use directly a command like |\large|, |\Large| and |\LARGE|.
%That's why the command |\Block| provides an option between angle brackets to
%specify some TeX code which will be inserted before the beginning of the
%math mode.\footnote{This argument between angular brackets may also be used to
%insert a command of font such as |\bfseries| when the command |\\| is used in
%the content of the block.}
有时希望调整（如增大）“块”中内容的大小，如上例中的 $A$ ，但在数学模式下无法直接使用|\large|、|\Large| 和 |\LARGE| 等调整字符大小的命令。
针对这种情况， |\Block| 命令允许在指定待合并区域所占的行数和列数后，在尖括号（ “|< >| ”）内填入\TeX/\LaTeX 代码，这些代码将在数学模式开始之前执行。\footnote{当在“块”的内容中使用硬换行命令“ |\\| ”时，也可以使用尖括号在其中插入诸如 |\bfseries| 之类的字体命令。}

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=11cm]
$\begin{bNiceArray}{ccc|c}[margin]
\Block{3-3}~emphase#<\LARGE>{A}@ &               &   & 0 \\
                       & \hspace*{1cm} &   & \Vdots \\
                       &               &   & 0 \\
\hline
0 & \Cdots             & 0             & 0
\end{bNiceArray}$
\end{BVerbatim}
$\begin{bNiceArray}{ccc|c}[margin]
\Block{3-3}<\LARGE>{A} & & & 0 \\
& \hspace*{1cm} & & \Vdots \\
& & & 0 \\
\hline
0 & \Cdots& 0 & 0
\end{bNiceArray}$

\bigskip
%It's possible to set the horizontal position of the block with one of the keys
%%|l|, |c| and |r|.
可以使用 |l|、|c| 和 |r| 选项设置“块”中内容的水平位置。

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=11.5cm]
$\begin{bNiceArray}{ccc|c}[margin]
  \Block~emphase#[r]@{3-3}<\LARGE>{A} &               &   & 0      \\
                            & \hspace*{1cm} &   & \Vdots \\
                            &               &   & 0      \\
  \hline
  0                         & \Cdots        & 0 & 0
\end{bNiceArray}$
\end{BVerbatim}
$\begin{bNiceArray}{ccc|c}[margin]
\Block[r]{3-3}<\LARGE>{A} & & & 0 \\
& \hspace*{1cm} & & \Vdots \\
& & & 0 \\
\hline
0 & \Cdots& 0 & 0
\end{bNiceArray}$

\interitem
% In fact, the command |\Block| accepts as first optional argument (between
% square brackets) a list of couples key-value. The available keys are as
% follows:
事实上，|\Block| 命令后可紧跟一对方括号，在方括号内是可选项列表。具体的选项有：
\begin{itemize}
% \item the keys |l|, |c| and |r| are used to fix the horizontal position of the
% content of the block, as explained previously;
\item |l|、|c| 和 |r|，表示“块”中内容的水平对齐方式；
% \item the key |fill| takes in as value a color and fills the block with that
% color;
\item |fill[=<颜色>]|，表示使用给定的颜色对“块”进行着色（填充背景色）；
% \item the key |draw| takes in as value a color and strokes the frame of the
% block with that color (the default value of that key is the current color of
% the rules of the array);
\item |draw[=<颜色>]|，表示使用给定的颜色绘制“块”的边框，默认值与阵列框线的当前颜色相同；
% \item the key |color| takes in as value a color and apply that color the
% content of the block but draws also the frame of the block with that color;
\item |color=<颜色>|，表示使用给定的颜色绘制“块”的边框并填充背景色；
\NFTN{|fill| 和|draw| 的参数是可选参数，|color| 的参数是必选参数。}
% \item the key |line-width| is the width (thickness) of the frame (this key
% should be used only when the key |draw| is in force);
\item |line-width|，设置“块”框线的宽度（粗细），仅当使用 |draw| 命令时才有效；
% \item \colorbox{yellow!50}{\textbf{New 5.12}}\enskip the key |rounded-corners|
% requires rounded corners (for the frame drawn by |draw| and the shape drawn by
% |fill|) with a radius equal to the value of that key (the default value is
% 4~pt\footnote{This value is the initial value of the \emph{rounded corners} of
% Tikz.}).
\item \colorbox{yellow!50}{\textbf{v5.12新增}} |rounded-corners=[<圆角半径长度>]|，表示使用 |draw| 选项绘制边框和使用 |fill| 选项填充颜色时的圆角半径。默认值是~4~pt\footnote{4~pt 是 \tikzname 中圆角半径（\emph{rounded corners}）的默认值。}。
% \item \colorbox{yellow!50}{\textbf{New 5.13}}\enskip the key |borders| provides
% the ability to draw only some borders of the blocks; the value of that key is
% a (comma-separated) list of elements covered by |left|, |right|, |top| and
% |bottom|. 
\item \colorbox{yellow!50}{\textbf{v5.13新增}} 可以使用 |borders| 选项指定绘制“块”四周部分或全部的框线，
|borders| 选项可取的值有 |left|、|right|、|top| 和 |bottom|，多个值之间使用英文逗号“,”分隔。

%todo 增加示例

\end{itemize}

\interitem
%{\bfseries One must remark that, by default, the commands |\Blocks| don't create space}.
%There is exception only for the blocks mono-row and the blocks mono-column as
%explained just below.
{\bfseries 需要指出的是，默认情况下 |\Block| \textnormal{（\NFTN{原文中为 \texttt{\textbackslash Blocks} ，疑为笔误。}）}命令产生的“块”的大小与合并前各子单元格的大小之和相同，它不会产生比各子单元格之和更大的区域。}
如果想要扩大“块”的大小，应首先扩大合并前子单元格的大小。

\medskip
%In the following example, we have had to enlarge by hand the columns 2 and 3
%(with the construction |wc{...}| of \pkg{array}).
在下例中，使用 \pkg{array} 宏包的 |wc{...}| 命令手动设置了第 2 列和第 3 列的宽度，进而扩大了“块”的大小。

\bigskip
\begin{BVerbatim}
\begin{NiceTabular}~emphase#{cwc{2cm}wc{3cm}c}@
rose      & tulipe & marguerite & dahlia \\
violette  
&~emphase#\Block[draw=red,fill=red!15,rounded-corners]{2-2}
{\LARGE De très jolies fleurs}@
& & souci \\
pervenche &      &          & lys \\
arum      & iris & jacinthe & muguet 
\end{NiceTabular}
\end{BVerbatim}


\medskip
\begin{center}
\begin{NiceTabular}{cwc{2cm}wc{3cm}c}
rose      & tulipe & marguerite & dahlia \\
violette  & 
\Block[draw=red,fill=red!15,rounded-corners]{2-2}{\LARGE De très jolies fleurs}  & & souci \\
pervenche & & & lys \\
arum      & iris & jacinthe & muguet 
\end{NiceTabular}
\end{center}

\medskip

%\subsection{The mono-column blocks}
\subsection{单列“块”（mono-column blocks）}

\FTN{单列“块”，顾名思义，指由同一列中的若干连续相邻单元格合并而成的“块”，类似于 |Excel| 中的单列多行合并单元格。}

%The mono-column blocks have a special behaviour.
单列“块”具有以下特性：
\begin{itemize}
%\item The natural width of the contents of these blocks is taken into account
%for the width of the current column.
\item 列的宽度由本列所有单元格中宽度最大的单元格确定；
%\item The specification of the horizontal position provided by the type of
%column (|c|, |r| or |l|) is taken into account for the blocks.
\item 可以用 |l|、|c| 和 |r| 选项设置“块”的水平居中方式；

%\item The specifications of font specified for the column by a construction
%|>{...}| in the preamble of the array are taken into account for the
%mono-column blocks of that column (this behaviour is probably expected).
\item 可以在环境的导言区使用 |>{...}| 设置“块”的字体格式。
\end{itemize}

\medskip
%\begin{scope}
\hfuzz=10cm
\begin{BVerbatim}[baseline=c,boxwidth=12cm]
\begin{NiceTabular}{~LetterAt{}~emphase#>{\bfseries}lr@~LetterAt{}} \hline
  \Block{2-1}{John}    & 12 \\
                       & 13 \\ \hline
  Steph                &  8 \\ \hline
  \Block{3-1}{Sarah}   & 18 \\
                       & 17 \\
                       & 15 \\ \hline
  Ashley               & 20 \\ \hline
  Henry                & 14 \\ \hline
  \Block{2-1}{Madison} & 15 \\
                       & 19 \\ \hline
\end{NiceTabular}
\end{BVerbatim}
\begin{NiceTabular}{@{}>{\bfseries}lr@{}}[baseline=c]
  \hline
\Block{2-1}{John}    & 12 \\
                     & 13 \\ \hline
Steph                &  8 \\ \hline
\Block{3-1}{Sarah}   & 18 \\
                     & 17 \\
                     & 15 \\ \hline
Ashley               & 20 \\ \hline
Henry                & 14 \\ \hline
\Block{2-1}{Madison} & 15 \\
                     & 19 \\ \hline
\end{NiceTabular}
%\end{scope}

%\subsection{The mono-row blocks}
\subsection{单行“块”（mono-row blocks）}

\FTN{单行“块”，顾名思义，指由同一行中的若干连续相邻单元格合并而成的“块”，类似于 |Excel| 中的单行多列合并单元格。}

%For the mono-row blocks, the natural height and depth are taken into account
%for the height and depth of the current row (as does a standard |\multicolumn|
%of LaTeX).

对于单行“块”，其高度与合并前各子单元格中高度最大的单元格相同，其宽度为合并前各子单元格的宽度之和（与 \pkg{array} 宏包的 |\multicolumn| 命令相同）。

%\subsection{The mono-cell blocks}
\subsection{单元格“块”（mono-cell blocks）}
\label{subsec:mono-cell-block}
\FTN{单元格“块”指由 1 个单元格构成的“块”。}
%A mono-cell block inherits all the properties of the mono-row blocks and
%mono-column blocks.
单元格“块”继承了单列“块”和单行“块”的所有特性。

\medskip
%At first sight, one may think that there is no point using a mono-cell block.
%However, there are some good reasons to use such a block.
单元格“块”仅由 1 个单元格组成，但它不是 1 个普通的单元格，有很多特殊的应用场景：

\begin{itemize}
%\item It's possible to use the command |\\| in a (mono-cell) block.
\item 可以在单元格“块”中使用硬换行命令“|\\|”；

%\item It's possible to use the option of horizontal alignment of the block in
%derogation of the type of column given in the preamble of the array.
\item 可以单独指定与整列不同的水平对齐方式；

% \item It's possible do draw a frame around the cell with the key |draw| of the
% command |\Block| and to fill the background with rounded corners with the keys
% |fill| and |rounded-corners|.\footnote{If one simply wishes to color the
% background of a unique celle, there is no point using the command |\Block|:
% it's possible to use the command |\cellcolor| (when the key |colortbl-like| is
% used).}
\item 可以在 |\Block| 后使用 |draw| 选项为“块”绘制框线，使用 |fill| 选项为“块”填充背景色，使用 |rounded-corners| 选项使绘制框线和填充背景色时由默认的直角矩形变为圆角矩形。\footnote{如果仅仅是为某一单元格设置底色，不必使用 |\textbackslash Block| 命令，可在开启 |colortbl-like| 选项后使用 |colortbl-like| 命令。}
\end{itemize}

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
\begin{NiceTabular}{cc}
  \toprule
    Writer & ~emphase#\Block[l]{}{year\\ of birth}@ \\
    \midrule
    Hugo   & 1802 \\
    Balzac & 1799 \\
    \bottomrule
\end{NiceTabular}
\end{BVerbatim}
\begin{NiceTabular}{cc}
\toprule
Writer & \Block[l]{}{year\\ of birth} \\
\midrule
Hugo & 1802 \\
Balzac & 1799 \\
\bottomrule
\end{NiceTabular}

\medskip
%We recall that if the first mandatory argument of |\Block| is left blank, the
%block is mono-cell.\footnote{One may consider that the default value of the
%first mandatory argument of |\Block| is |1-1|.}
上例中， |\Block| 命令的第 1 个必选参数没有显式指定，则代表这个“块”是一个单元格“块”。\footnote{可以认为 |\textbackslash Block| 命令第 1 个必选参数的默认值是 |1-1| 。}

\NFTN 单元格“块”的另一个应用示例见~p.~\pageref{code-after} 。
%\subsection{A small remark}
\subsection{本节注记（remark）}
%One should remark that the horizontal centering of the contents of the blocks
%is correct even when an instruction such as |!{\qquad}| has been used in the
%preamble of the array in order to increase the space between two columns (this
%is not the case with |\multicolumn|). In the following example, the header
%``First group'' is correctly centered.
需要指出的是，即便在环境的导言中使用了诸如 |!{\qquad}| 之类增加两列之间空白的命令，“块”中的内容也会保持水平居中（ |\multicolumn| 不会正确居中）。 

下例中，分别在 1 、 2 列之间和 4 、 5 列之间使用了 |!{\qquad}| 命令以增加它们的间距，表头中的 “First group” （位于单行“块”内）仍能正确居中。 

\medskip
\begin{center}
\fvset{commandchars=\~\#\+}
\begin{BVerbatim}
\begin{NiceTabular}{@{}c!{\qquad}ccc~emphase#!{\qquad}+ccc@{}}
  \toprule
  & ~emphase#\Block{1-3}{First group}+ & & & \Block{1-3}{Second group} \\
  Rank & 1A    & 1B    & 1C    & 2A    & 2B    & 2C \\
  \midrule
  1    & 0.657 & 0.913 & 0.733 & 0.830 & 0.387 & 0.893\\
  2    & 0.343 & 0.537 & 0.655 & 0.690 & 0.471 & 0.333\\
  3    & 0.783 & 0.885 & 0.015 & 0.306 & 0.643 & 0.263\\
  4    & 0.161 & 0.708 & 0.386 & 0.257 & 0.074 & 0.336\\
  \bottomrule
\end{NiceTabular}
\end{BVerbatim}
\end{center}

\medskip
\begin{center}
\begin{NiceTabular}{@{}c!{\qquad}ccc!{\qquad}ccc@{}}
\toprule
& \Block{1-3}{First group} & & & \Block{1-3}{Second group} \\
Rank & 1A & 1B & 1C & 2A & 2B & 2C \\
\midrule
1 & 0.657 & 0.913 & 0.733 & 0.830 & 0.387 & 0.893\\
2 & 0.343 & 0.537 & 0.655 & 0.690 & 0.471 & 0.333\\
3 & 0.783 & 0.885 & 0.015 & 0.306 & 0.643 & 0.263\\
4 & 0.161 & 0.708 & 0.386 & 0.257 & 0.074 & 0.336\\
\bottomrule
\end{NiceTabular}
\end{center}

%\section{The rules}
\section{框线（rules）}

%The usual techniques for the rules may be used in the environments of
%\pkg{nicematrix} (excepted |\vline|). However, there is some small differences
%with the classical environments.
在 \pkg{nicematrix} 中，框线的绘制与 \pkg{array}、\pkg{amsmath} 等经典宏包中的用法基本相同（ |\vline| 除外），但也有一些区别。

\bigskip
%\subsection{Some differences with the classical environments}
\subsection{与经典环境中框线的不同}

%\subsubsection{The vertical rules}
\subsubsection{垂直框线（vertical rules）}

%In the environments of \pkg{nicematrix}, the vertical rules specified by
%\verb+|+ in the preambles of the environments are never broken, even by an
%incomplete row or by a double horizontal rule specified by |\hline\hline|
%(there is no need to use \pkg{hhline}).

\pkg{nicematrix} 的诸环境中，在导言区以 “\verb+|+” 指定的垂直框线会保持连续，而不会被不完整的行或双行线“|\hline \hline|”打断（双行线命令无需载入 \pkg{hhline} 宏包）。

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
\begin{NiceTabular}{|c|c|} \hline
  First & Second \\ ~emphase#\hline\hline@
  Peter \\ \hline
  Mary  & George\\ \hline
\end{NiceTabular}
\end{BVerbatim}
\begin{NiceTabular}{|c|c|}[c] \hline
First & Second \\ \hline\hline
Peter \\ \hline
Mary  & George \\ \hline
\end{NiceTabular}


\bigskip
%v 5.12
%However, the vertical rules are not drawn in the blocks.
%v 5.13
%However, the vertical rules are not drawn in the blocks (created by |\Block|:
% cf.~p.~\pageref{Block}). 
%todo v 5.13 此处可能缺示例

从上例中可以看出，垂直框线没有被双行线打断。

\bigskip
%If you use \pkg{booktabs} (which provides |\toprule|, |\midrule|,
%|\bottomrule|, etc.) and if you really want to add vertical rules (which is
%not in the spirit of \pkg{booktabs}), you should notice that the vertical rules
%drawn by \pkg{nicematrix} are compatible with \pkg{booktabs}.
如果 \pkg{booktabs} 宏包提供的 |\toprule|、|\midrule| 和 |\bottomrule| 命令绘制三线表，并且确需绘制垂直框线（尽管这与 \pkg{booktabs} 宏包的设计理念相悖）， 你会发现 \pkg{nicematrix} 宏包与 \pkg{booktabs} 宏包协同工作良好，绘制的垂直框线不会被打断。

\FTN{在 |array| 环境中，\pkg{booktabs} 宏包的竖线会被横线打断，如下例示。}

\noindent\hrulefill\colorbox{red!30}{译者增补示例\ten}\hrulefill

\medskip
\begin{BVerbatim}[baseline=c,boxwidth=10.5cm]
$\begin{array}{|c|ccc|}\toprule
  a & b & c & d \\ \midrule
  1 & 2 & 3 & 4 \\
  1 & 2 & 3 & 4 \\ \bottomrule
\end{array}$
\end{BVerbatim}
$\begin{array}{|c|ccc|}
\toprule
a & b & c & d \\
\midrule
1 & 2 & 3 & 4 \\
1 & 2 & 3 & 4 \\
\bottomrule
\end{array}$

\medskip
\noindent\hrulefill

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=10.5cm]
  $\begin{NiceArray}{~emphase#|cccc|@} \toprule
  a & b & c & d \\ \midrule
  1 & 2 & 3 & 4 \\
  1 & 2 & 3 & 4 \\ \bottomrule
\end{NiceArray}$
\end{BVerbatim}
$\begin{NiceArray}{|c|ccc|}
\toprule
a & b & c & d \\
\midrule
1 & 2 & 3 & 4 \\
1 & 2 & 3 & 4 \\
\bottomrule
\end{NiceArray}$

\bigskip
%However, it's still possible to define a specifier (named, for instance, |I|)
%to draw vertical rules with the standard behaviour of \pkg{array}.
为保持与 \pkg{array} 宏包的兼容性，可以定义一个标识符，如 |I| ，使其绘制的竖线与 \pkg{array} 宏包中的竖线相同，即它可以被双行线或三线表中的行线打断。

\begin{Verbatim}
\newcolumntype{I}{!{\vrule}}
\end{Verbatim}

%However, in this case, it is probably more clever to add a command
%|\OnlyMainNiceMatrix| (cf. p.~\pageref{OnlyMainNiceMatrix}):
在上例中，更“聪明”的做法是新增一个命令 |\OnlyMainNiceMatrix| (参见~p.~\pageref{OnlyMainNiceMatrix}):
\begin{Verbatim}
\newcolumntype{I}{!{\OnlyMainNiceMatrix{\vrule}}}
\end{Verbatim}


\bigskip
%\subsubsection{The command \textbackslash cline}
\subsubsection{独立横线 --- \texttt{\textbackslash}cline 命令}
\label{remark-cline}

%The horizontal and vertical rules drawn by |\hline| and the specifier
%``\verb+|+'' make the array larger or wider by a quantity equal to the width
%of the rule (with \pkg{array} and also with \pkg{nicematrix}).

阵列的框线本身都有一定的宽度（粗细）。默认情况下， \pkg{array} 和 \pkg{nicematrix} 宏包中使用 |\hline| 绘制的水平行线和通过``\verb+|+''标识符指定的垂直列线都会计入阵列的整体高度和宽度。即尽管内容完全相同，有框线阵列与无框线阵列的总高度与总宽度也不相同。

\smallskip
%For historical reasons, this is not the case with the command |\cline|, as
%shown by the following example.
由于历史原因， |\cline| 命令绘制的水平横线不会计入阵列高度，即 |\cline| 命令不会使阵列的高度增加。

\medskip
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
\setlength{\arrayrulewidth}{2pt}
\begin{tabular}{cccc} \hline
  A & B & C & D \\ ~emphase#\cline{2-2}@
  A & B & C & D \\ \hline
\end{tabular}
\end{BVerbatim}
\begin{scope}
\setlength{\arrayrulewidth}{2pt}
\begin{tabular}[c]{cccc}
\hline
A & B & C & D \\
\cline{2-2}
A & B & C &D \\
\hline
\end{tabular}
\end{scope}

\medskip
%In the environments of \pkg{nicematrix}, this situation is corrected (it's
%still possible to go to the standard behaviour of |\cline| with the key |standard-cline|).
在 \pkg{nicematrix} 的诸环境中，用 |\cline| 命令绘制的水平横线默认会计入阵列总高度，同时可通过开启 |standard-cline| 选项使 |\cline| 命令不计入阵列总高度。

\medskip
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
\setlength{\arrayrulewidth}{2pt}
\begin{NiceTabular}{cccc} \hline
  A & B & C & D \\ ~emphase#\cline{2-2}@
  A & B & C & D \\ \hline
\end{NiceTabular}
\end{BVerbatim}
\begin{scope}
\setlength{\arrayrulewidth}{2pt}
\begin{NiceTabular}[c]{cccc}
\hline
A&B&C&D \\
\cline{2-2}
A&B&C&D \\
\hline
\end{NiceTabular}
\end{scope}


%\subsection{The thickness and the color of the rules}
\subsection{框线的宽度（粗细）和颜色}
\label{zm:RulesWidthColor}

%The environments of \pkg{nicematrix} provide a key |rules/width| to set the
%width (in fact the thickness) of the rules in the current environment. In
%fact, this key merely sets the value of the length |\arrayrulewidth|.
在 \pkg{nicematrix} 的环境中，可以使用 |rules/width| 选项设置框线的粗细（宽度）。在 \pkg{nicematrix} 宏包内部， |rules/width| 选项是通过设置 \pkg{array} 宏包提供的 |\arrayrulewidth| 参数的值进而调整框线的粗细（宽度）。

%\smallskip
%It's well known that \pkg{colortbl} provides the command |\arrayrulecolor| in
%order to specify the color of the rules.
众所周知，框线的颜色可以通过 \pkg{colortbl} 宏包提供的 |\arrayrulecolor| 命令设置。

%\bigskip
%With \pkg{nicematrix}, it's possible to specify the color of the rules even
%when \pkg{colortbl} is not loaded. For sake of compatibility, the command is
%also named |\arrayrulecolor|. The environments of \pkg{nicematrix} also
%provide a key |rules/color| to fix the color of the rules in the current
%environment.

\pkg{nicematrix} 中，即便不载入 \pkg{colortbl} 宏包也可以设置框线的颜色。为了保持兼容性，\pkg{nicematrix} 中也可以通过 |\arrayrulecolor|命令设置框线颜色。在 \pkg{nicematrix} 中，还可以通过 |rules/color| 选项设置当前环境中框线的颜色。

\bigskip
\begin{scope}
\hfuzz=10cm
\begin{BVerbatim}[baseline=c,boxwidth=9.5cm]
\begin{NiceTabular}{|ccc|}[~emphase#rules/color=[gray]{0.9},rules/width=1pt@]
  \hline
  rose   & tulipe & lys \\
  arum   & iris   & violette \\
  muguet & dahlia & souci \\
  \hline
\end{NiceTabular}
\end{BVerbatim}
\begin{NiceTabular}{|ccc|}[rules/color=[gray]{0.9},rules/width=1pt]
\hline
rose & tulipe & lys \\
arum & iris & violette \\
muguet & dahlia & souci \\
\hline
\end{NiceTabular}
\end{scope}

\medskip
%If one wishes to define new specifiers for columns in order to draw vertical
%rules (for example with a specific color or thicker than the standard rules),
%he should consider the command |\OnlyMainNiceMatrix| described on
%page~\pageref{OnlyMainNiceMatrix}.
如果希望为列定义新的标识符以绘制垂直框线，如使用特定颜色或比标准框线更粗的框线，可以考虑使用 |\OnlyMainNiceMatrix| 命令，详见~p.~\pageref{OnlyMainNiceMatrix}。

% \subsection{The command \textbackslash Hline}
\subsection{\texttt{\textbackslash}Hline命令}

% We have said that the vertical rules specified by a symbol ``\verb+|+'' in the
% preamble (for the environments with preamble, of course) are not drawn in the
% blocks.\footnote{Those blocks are those created by the commands \verb|\Block|
% and |\multicolumn| but also those implicitely determined by the continuous
% dotted lines (created by \verb|\Cdots|, etc.).} 
前文提及，在阵列导言区以 “\verb+|+” 指定的垂直框线不会在“块”内部绘制。
\footnote{这里的“块”包含由 |\textbackslash Block| 和 |\textbackslash multicolumn| 等命令创建的显式块，
也包括由虚线命令（如 |\textbackslash Cdots| 等）创建的隐式块。}
\smallskip

% \colorbox{yellow!50}{\textbf{New 5.13}}\enskip In order to have horizontal
% rules with the same behaviour, \pkg{nicematrix} provides the command |\Hline|.
为使水平框线具有同样的行为，\pkg{nicematrix} 提供了 |\Hline| 命令。
%\todo 此处应增加示例。

%\subsection{The keys hlines and vlines}
\subsection{分别绘制全部行线和全部列线（hlines 和 vlines 选项）}

%The key |hlines| draws all the horizontal rules and the key |vlines| draws all
%the vertical rules excepted in the blocks (and the virtual blocks determined
%by dotted lines). In fact, in the environments with delimiters (as
%|{pNiceMatrix}| or |{bNiceArray}|) the exteriors rules are not drawn (as
%expected).

% The key |hlines| draws all the horizontal rules and the key |vlines| draws all
% the vertical rules excepted in the blocks, created by |\Block| and the virtual
% blocks determined by dotted lines: |\Cdots|, |\Vdots|, etc.. In fact, in the
% environments with delimiters (as |{pNiceMatrix}| or |{bNiceArray}|) the
% exteriors rules are not drawn (as expected).

|hlines| 选项用于绘制阵列中全部的水平行线， |vlines| 选项用于绘制阵列中全部的垂直框线，但不能绘制“块”内部及内部有数学省略号（...，由 |\Cdots|、 |\Vdots| 等命令生成）的虚拟“块”内部的水平和垂直框线。
此外，在有定界符的环境中，如 |{pNiceMatrix}| 和 |{bNiceArray}| 等， |hlines| 和 |vlines| 不绘制最外侧的框线。

\medskip
\begin{BVerbatim}[baseline=c,boxwidth=10.6cm]
$\begin{pNiceMatrix}[~emphase#vlines@,rules/width=0.2pt]
  1 & 2 & 3 & 4 & 5 & 6 \\
  1 & 2 & 3 & 4 & 5 & 6 \\
  1 & 2 & 3 & 4 & 5 & 6 
\end{pNiceMatrix}$
\end{BVerbatim}
$\begin{pNiceMatrix}[vlines,rules/width=0.2pt]
1 & 2 & 3 & 4 & 5 & 6 \\
1 & 2 & 3 & 4 & 5 & 6 \\
1 & 2 & 3 & 4 & 5 & 6 
\end{pNiceMatrix}$

\bigskip
% \colorbox{yellow!50}{\textbf{New 5.13}}\enskip It's possible to provide to the
% key |vlines| a (comma-separated) list of numbers, which are the numbers of the
% vertical rules to draw. The key |hlines| has a similar behaviour.

\colorbox{yellow!50}{\textbf{v5.13 新增}}  可以为 |vlines| 和 |hlines| 选项指定数值，
表示需绘制的行线和列线号，多个行（列）线号之间用英文逗号（,）分隔。

%\todo 此处应增加示例

%\subsection{The key hvlines}
\subsection{同时绘制全部行线和全部列线（hvlines选项）}
\label{hvlines}

%The key |hvlines| draws all the vertical and horizontal rules (excepted
%in the blocks and the virtual blocks determined by dotted lines and excepted
%the rules corresponding of the frame of the blocks using the key |draw| which
%are drawn with their own characteristics).


|hvlines| 可以绘制所有的水平和垂直框线，但不包括以下3种情况：

1. “块”内部的框线；

2. 使用省略号标识的虚拟“块”内部的框线；

3. 已使用 |draw| 选项绘制的框线。

\medskip
\begin{Verbatim}
\setlength{\arrayrulewidth}{1pt}
\begin{NiceTabular}{cccc}[~emphase#hvlines@,rules/color=blue]
  rose      & tulipe                               & marguerite & dahlia \\
  violette  & \Block[draw=red]{2-2}{\LARGE fleurs} &            & souci  \\
  pervenche &                                      &            & lys    \\
  arum      & iris                                 & jacinthe   & muguet
\end{NiceTabular}
\end{Verbatim}

\begin{center}
\setlength{\arrayrulewidth}{1pt}
\begin{NiceTabular}{cccc}[hvlines,rules/color=blue]
rose      & tulipe & marguerite & dahlia \\
violette  & \Block[draw=red]{2-2}{\LARGE fleurs}  & & souci \\
pervenche & & & lys \\
arum      & iris & jacinthe & muguet 
\end{NiceTabular}
\end{center}

%\subsection{The key hvlines-except-corners}
\subsection{绘制除“空角”外的全部行线和列线（hvlines-except-corners）}
\label{except-corners}


%The key |hvlines-except-corners| draws all the horizontal and vertical rules,
%excepted in the blocks (and the virtual blocks determined by dotted lines) and
%excepted in the empty corners. 
|hvlines-except-corners| 可以绘制除以下3种情况外的所有水平和垂直框线：
 
1. “块”内部的框线；

2. 使用省略号标示的虚拟“块”内部的框线；

3. “空角”区域内的单元格框线。

\medskip
\begin{Verbatim}
\begin{NiceTabular}{*{6}{c}}[~emphase#hvlines-except-corners@,cell-space-top-limit=3pt]
    &                &   &   & A \\
    &                & A & A & A \\
    &                &   & A \\
    &                & A & A & A & A \\
  A & A              & A & A & A & A \\
  A & A              & A & A & A & A \\
    & \Block{2-2}{B} &   & A \\
    &                &   & A \\
    & A              & A & A \\
\end{NiceTabular}
\end{Verbatim}
%
\begin{center}
\begin{NiceTabular}{*{6}{c}}[hvlines-except-corners,cell-space-top-limit=3pt]
 &   &   &   & A \\
 &   & A & A & A \\
 &   &   & A \\
 &   & A & A & A & A \\
A & A & A & A & A & A \\
A & A & A & A & A & A \\
 & \Block{2-2}{B} & & A \\
 &   &   & A \\
 & A & A & A \\
\end{NiceTabular}
\end{center}

%As we can see, an ``empty corner'' is composed by the reunion of all the empty
%rectangles starting from the cell actually in the corner of the array.
从上例中可以看出，\pkg{nicematrix} 中的“空角”指阵列四角附近内容连续为空的矩形区域。

\bigskip
%It's possible to give as value to the key |\hvlines-except-corners| a list of
%the corners to take into consideration. The corners are designed by |NW|,
%|SW|, |NE| and |SE| (\emph{north west}, \emph{south west}, \emph{north east}
%and \emph{south east}).
可以通过给选项 |\hvlines-except-corners| 赋予特定的值，指定不绘制某一方向上“空角”的框线。值具体可以是|NW|、|SW|、|NE| 和 |SE|，分别代表西北（\emph{north west}）、西南（\emph{south west}）、东北（\emph{north east}）和东南（\emph{south east}）。

\bigskip
\begin{BVerbatim}[boxwidth=10.5cm,baseline=c]
\begin{NiceTabular}{*{6}{c}}%
 [~emphase#hvlines-except-corners=NE@,cell-space-top-limit=3pt]
  1\\
  1 & 1\\
  1 & 2 &  1\\
  1 & 3 &  3 &  1\\
  1 & 4 &  6 &  4 & 1\\
  1 & 5 & 10 & 10 & 5 & 1
\end{NiceTabular}
\end{BVerbatim}
\begin{NiceTabular}{*{6}{c}}[c,hvlines-except-corners=NE,cell-space-top-limit=3pt]
1\\
1&1\\
1&2&1\\
1&3&3&1\\
1&4&6&4&1\\
1&5&10&10&5&1
\end{NiceTabular}

\bigskip
% $\triangleright$ The concept of corner is also used by the command
% |\arraycolor| in the |\CodeBefore| which takes in as option a key
% |except-corners|: cf.~p.~\pageref{arraycolor}.
$\triangleright$ 在 |\CodeBefore| 中的 |\arraycolor| 命令也可以使用 |except-corners| 选项，
详见~p.~\pageref{arraycolor}。

%\subsection{The command \textbackslash diagbox}
\subsection{阵列中的斜线 --- \texttt{\textbackslash}diagbox 命令}
\label{zm:斜线}

%The command |\diagbox| (inspired by the package \pkg{diagbox}), allows, when
%it is used in a cell, to slash that cell diagonally downwards.\footnote{The
%author of this document considers that type of construction as graphically
%poor.}.
|\diagbox| 命令用于绘制“斜线”单元格\footnote{\pkg{nicematrix} 宏包的作者认为“斜线”单元格很不美观。（原文如此）}。该命令主要受 \pkg{diagbox} 宏包的启发。


\medskip
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
$\begin{NiceArray}{*{5}{c}}[hvlines]
  ~emphase#\diagbox{x}{y}@ & e & a & b & c \\
  e              & e & a & b & c \\
  a              & a & e & c & b \\
  b              & b & c & e & a \\
  c              & c & b & a & e 
\end{NiceArray}$
\end{BVerbatim}
$\begin{NiceArray}{*{5}{c}}[hvlines]
\diagbox{x}{y}  & e & a & b & c \\
e & e & a & b & c \\
a & a & e & c & b \\
b & b & c & e & a \\
c & c & b & a & e 
\end{NiceArray}$

\medskip
%It's possible to use the command |\diagbox| in a |\Block|.
斜线表命令 |\diagbox| 不仅可以在单个单元格内使用，也可以在“块”内部使用。

\FTN{\pkg{nicematrix} 仅支持在 1 个单元格（或“块”）内绘制 1 条斜线。\pkg{diagbox} 宏包可以在 1 个单元格内绘制 2 条斜线，还支持灵活配置斜线的属性，共有 15 个参数可供配置。}

%\subsection{Dotted rules}
\subsection{虚线框线（dotted rules）}

%In the environments of the package \pkg{nicematrix}, it's possible to use
%the command |\hdottedline| (provided by \pkg{nicematrix}) which is a
%counterpart of the classical commands |\hline| and |\hdashline| (the latter is
%a command of \pkg{arydshln}).

在 \pkg{nicematrix} 的诸环境中，可以使用 |\hdottedline| 命令（由 \pkg{nicematrix} 提供）绘制虚线框线（ \pkg{arydshln} 宏包的 |\hdashline| 命令也可用于绘制虚线框线）。%\footnote{译者注： \pkg{arydshln} 宏包支持对斜线的样式（如虚线中线与空白的宽度等）进行个性化配置。}

\medskip
\begin{BVerbatim}[baseline=c,boxwidth=9.5cm]
\begin{pNiceMatrix}
  1  & 2  & 3  & 4  & 5 \\
  ~emphase#\hdottedline@
  6  & 7  & 8  & 9  & 10 \\
  11 & 12 & 13 & 14 & 15 
\end{pNiceMatrix}
\end{BVerbatim}
$\begin{pNiceMatrix}
1 & 2 & 3 & 4 & 5 \\
\hdottedline
6 & 7 & 8 & 9 & 10 \\
11 & 12 & 13 & 14 & 15 
\end{pNiceMatrix}$


\bigskip
%In the environments with an explicit preamble (like |{NiceTabular}|,
%|{NiceArray}|, etc.), it's possible to draw a vertical dotted line with the
%specifier ``|:|''.
在带有可选参数的环境中，如 |{NiceTabular}|、|{NiceArray}| 等，可以通过英文冒号 “|:|”绘制垂直虚线。

\medskip
\begin{BVerbatim}[baseline=c,boxwidth=9.5cm]
\left(\begin{NiceArray}{cccc~emphase#:@c}
  1  & 2  & 3  & 4  & 5 \\
  6  & 7  & 8  & 9  & 10 \\
  11 & 12 & 13 & 14 & 15
\end{NiceArray}\right)
\end{BVerbatim}
$\left(\begin{NiceArray}{cccc:c}
1  & 2 & 3 & 4 & 5 \\
6  & 7 & 8 & 9 & 10 \\
11 & 12 & 13 & 14 & 15 
\end{NiceArray}\right)$

\bigskip
%It's possible to change in \pkg{nicematrix} the letter used to specify a
%vertical dotted line with the option |letter-for-dotted-lines| available in
%|\NiceMatrixOptions|. Thus released, the letter ``|:|'' can be used otherwise
%(for example by the package \pkg{arydshln}\footnote{However, one should remark
%that the package \pkg{arydshln} is not fully compatible with
%\pkg{nicematrix}.}). 

由于 \pkg{arydshln}宏包默认使用 “:” 标示垂直虚线框线，为防止产生冲突，可以在 \pkg{nicematrix} 的 |\NiceMatrixOptions| 中使用 |letter-for-dotted-lines| 自定义虚线的标识符，以释放冒号“:”
\footnote{需要说明的是，\pkg{arydshln} 宏包与 \pkg{nicematrix} 并不完全兼容}。

\bigskip
% \emph{Remark}: In the package \pkg{array} (on which the package
% \pkg{nicematrix} relies), horizontal and vertical rules make the array larger
% or wider by a quantity equal to the width of the rule\footnote{In fact, with
% \pkg{array}, this is true only for |\hline| and ``"|"'' but not for |\cline|:
% cf p.~\pageref{remark-cline}}. In \pkg{nicematrix}, the dotted lines drawn by
% |\hdottedline| and ``|:|'' do likewise.


\emph{提示}：在 \pkg{array} 宏包中，水平框线和垂直框线的宽度（粗细）会计入表格的总高度和总宽度\footnote{准确地说， |\textbackslash hline| 和 \texttt{\textbar} 绘制的框线会计入表格的总体尺寸，而 |\textbackslash cline| 命令绘制的水平框线不计入表格总高度（详见p.~\pageref{remark-cline}）。}。在 \pkg{nicematrix} 中，使用 |\textbackslash hdottedline| 和 ``|:|''绘制的虚线框线会计入表格的总体高度及宽度。
%
%
%
%\section{The color of the rows and columns}
\section{行和列的颜色}

%\subsection{Use of colortbl}
\subsection{表格着色宏包 colortbl 存在的问题}

\FTN{|colortbl| 宏包提供了一组颜色设置命令,可分别用于设
置表格中列、行和单元格的背景颜色以及表格线的颜色。载入 |colortbl| 宏包的方法有2种：}
%We recall that the package \pkg{colortbl} can be loaded directly with
%|\usepackage{colortbl}| or by loading \pkg{xcolor} with the key |table|:
%|\usepackage[table]{xcolor}|. 
可以直接使用 |\usepackage {colortbl}|  加载 \pkg{colortbl} 宏包，
也可以通过在加载 \pkg{xcolor} 宏包时指定 |table| 选项，
即使用 |\usepackage[table]{xcolor}| 加载 \pkg{colortbl} 宏包。

\medskip
%Since the package \pkg{nicematrix} is based on \pkg{array}, it's possible to
%use \pkg{colortbl} with \pkg{nicematrix}.
由于 \pkg{nicematrix} 基于 \pkg{array} 宏包，
因此，在 \pkg{nicematrix} 中也可以使用 \pkg{colortbl} 宏包。

\medskip
%However, there is two drawbacks:
但是， \pkg{nicematrix} 中使用 \pkg{colortbl} 宏包存在 2 个问题：
\begin{itemize}
%\item The package \pkg{colortbl} patches \pkg{array}, leading to some
%incompatibilities (for instance with the command |\hdotsfor|).
\item \pkg{colortbl} 宏包对 \pkg{array} 打了补丁，
与 \pkg{nicematrix} 的个别命令不兼容，如 |\hdotsfor| 命令；

%\item The package \pkg{colortbl} constructs the array row by row, alterning
%colored rectangles, rules and contents of the cells. The resulting
%\textsc{pdf} is difficult to interpret by some \textsc{pdf} viewers and may
%lead to artefacts on the screen.
\item 由于 \pkg{colortbl} 在构建 \textsc{pdf} 文件时存在一些问题，某些 \textsc{pdf} 阅读器难以正确地解析使用 \pkg{colortbl} 生成的 \textsc{pdf} 文件：
\begin{itemize}
%\item Some rules seem to disappear. This is because many PDF viewers give
%priority to graphical element drawn posteriorly (which is in the spirit of the
%``painting model'' of PostScript and PDF). Concerning this problem, MuPDF
%(which is used, for instance, by SumatraPDF) gives better results than Adobe
%Reader).
\item 部分框线无法正确显示。这是由于对大多数 \textsc{pdf} 阅读器而言，
图像元素在最后构建（这是也是 PostScript 和 \textsc{pdf} ``painting model'' 的固有特性）。
针对上述问题，MuPDF （SumatraPDF 内部调用的就是MuPDF）对 \textsc{pdf} 文件的呈现效果要好于 Adobe Reader。
%\item A thin white line may appear between two cells of the same color. This
%phenomenon occurs when each cell is colored with its own instruction |fill|
%(the PostScript operator |fill| noted |f| in PDF). This is the case with
%\pkg{colortbl}: each cell is colored on its own, even when |\columncolor| or
%|\rowcolor| is used.
\item 相邻单元格间可能出现细微的白线。
这是由于 \pkg{colortbl} 是对各个单元格逐一使用 |fill| （PostScript 的 |fill| 操作，在 \textsc{pdf} 中以 |f| 表示）命令着色，
即便使用 |\columncolor| 或
|\rowcolor| 命令也是如此。

%As for this phenomenon, Adobe Reader gives better results than MuPDF.
在这种情况下，Adobe Reader 的最终呈现效果要好于 MuPDF。
\end{itemize}

%The package \pkg{nicematrix} provides tools to avoid those problems.
 \pkg{nicematrix} 解决了上述问题。
\end{itemize}

% \subsection{The tools of nicematrix in the \textbackslash CodeBefore}
\subsection{\texttt{\textbackslash}CodeBefore 工具}

%The package \pkg{nicematrix} provides some tools (independent of
%\pkg{colortbl}) to draw the colored panels first, and, then, the content
%of the cells and the rules. This strategy is more conform to the ``painting
%model'' of the formats PostScript and \textsc{pdf} and is more suitable for
%the \textsc{pdf} viewers. However, it requires several compilations.
与\pkg{colortbl} 宏包不同，\pkg{nicematrix} 着色的机制是首先对单元格（panel）着色，
而后对单元格内容和框线着色。这种机制更符合 PostScript 和 \textsc{pdf} ``painting model'' 的固有特性，因此生成的 \textsc{pdf} 文件与 \textsc{pdf} 阅读器兼容性更好，
但需要多次编译。


\medskip
%The extension \pkg{nicematrix} provides a key |code-before| for some code that
%will be executed before the drawing of the tabular. 
% \medskip
\pkg{nicematrix} 提供了 |code-before| 选项用于设定在阵列绘制前执行的代码。

% \colorbox{yellow!50}{\textbf{New 5.12}}\enskip An alternative syntax is
% provided: it's possible to put the content of that |code-before| between the
% keywords |\CodeBefore| and |\Body| at the beginning of the environment.

\colorbox{yellow!50}{\textbf{v5.12新增}}\enskip 
可以将 |code-before| 的内容放在阵列中的 |\CodeBefore| 和 |\Body| 之间。

\bigskip
\begin{Verbatim}
\begin{pNiceArray}{~textsl#preamble@}
  ~emphase#\CodeBefore@
  ~textsl#instructions of the code-before@
  ~emphase#\Body@
  ~textsl#contents of the environnement@
\end{pNiceArray}
\end{Verbatim}
%

% New commands are available in that |\CodeBefore|: |\cellcolor|,
% |\rectanglecolor|, |\rowcolor|, |\columncolor|, |\rowcolors|,
% |\chessboardcolors| and |arraycolor|.\footnote{Remark that, in the
% \verb|\CodeBefore|, PGF/Tikz nodes of the form ``\verb+(i-|j)+'' are also
% available to indicate the position to the potential rules:
% cf.~p.~\pageref{nodes-i}.}

在  |\CodeBefore| 中，可以使用 |\cellcolor|、 |\rectanglecolor|、 |\rowcolor|、
|\columncolor|、 |\rowcolors|、|\chessboardcolors| 和 |\arraycolor| 命令。
\footnote{需要指出，在 |\textbackslash CodeBefore| 中，可以使用 \texttt{(i-\textbar j)} 的形式引用行列线（不论是否显式绘出）交点对应的 \textsc{pgf}/\tikzname nodes 节点，见~p.~\pageref{nodes-i}。}
\label{code-before}

\medskip
%All these commands accept an optional argument (between square brackets and
%in first position) which is the color model for the specification of the colors.
上述着色命令都可以紧跟 1 个在方括号内的可选参数，用于指定着色时使用的颜色模式。

\FTN{“颜色模式”的取值是 |xcolor| 宏包支持的模式，如 RGB、rgb、cmyk、hsb等。默认使用“颜色表达式”模式，常用的表达式记法有：颜色！百分数（半色调）、颜色！百分数！颜色（混合色）、 -颜色（互补色）等。关于颜色模式，详见 |xcolor| 宏包手册。}

\medskip
\begin{itemize}
%\item The command |\cellcolor| takes its name from the command |\cellcolor| of
%\pkg{colortbl}.
\item |\cellcolor| 命令用于对单个单元格进行着色，其名称源于 \pkg{colortbl} 宏包。

%This command takes in as mandatory arguments a color and a list of cells, each
%of which with the format $i$-$j$ where $i$ is the number of the row and $j$ the
%number of the colummn of the cell.
它有 2 个必选参数，第 1 个是颜色，第 2 个是需着色的单元格列表。
单个单元格以“ $i$-$j$ ”的形式指定，其中 $i$ 表示行号，$j$ 表示列号。
多个单元格之间用英文逗号（,）分隔。

\medskip
\begin{scope}
\hfuzz=10cm
\begin{BVerbatim}[boxwidth=10cm,baseline=c]
\begin{NiceTabular}{|c|c|c|}
  \CodeBefore
    ~emphase#\cellcolor[HTML]{FFFF88}{3-1,2-2,1-3}@
  \Body
    \hline
    a & b & c \\ \hline
    e & f & g \\ \hline
    h & i & j \\ \hline
\end{NiceTabular}
\end{BVerbatim}
\begin{NiceTabular}{|c|c|c|}
  \CodeBefore
    \cellcolor[HTML]{FFFF88}{3-1,2-2,1-3}
  \Body
  \hline
  a & b & c \\ \hline
  e & f & g \\ \hline
  h & i & j \\ \hline
\end{NiceTabular}
\end{scope}

\bigskip

\NFTN{以下是在 |code-before| 选项中使用 |xcolor| 宏包 |cmyk| 颜色模式的一个示例。}

\hrulefill\colorbox{red!30}{译者增补示例\ten}\hrulefill

\medskip
\begin{BVerbatim}[boxwidth=10cm,baseline=c]
  \begin{NiceTabular}{|c|c|c|}[code-before =
  ~emphase#\cellcolor[cmyk]{0,0,1,0.5}{3-1,2-2,1-3}@] 
  \hline
  a & b & c \\ \hline
  e & f & g \\ \hline
  h & i & j \\ \hline
  \end{NiceTabular}
\end{BVerbatim}
\begin{NiceTabular}{|c|c|c|}[code-before = \cellcolor[cmyk]{0,0,1,0.5}{3-1,2-2,1-3}]
  \hline
  a & b & c \\ \hline
  e & f & g \\ \hline
  h & i & j \\ \hline
\end{NiceTabular}

\medskip
\hrulefill

\bigskip
%\item The command |\rectanglecolor| takes three mandatory arguments. The first
%is the color. The second is the upper-left cell of the rectangle and the third
%is the lower-right cell of the rectangle.
\item |\rectanglecolor| 命令用于对矩形区域进行着色。
该命令有 3 个必选参数，
第 1 个是颜色，
第 2 个是待着色矩形区域左上角单元格的位置，
第 3 个是待着色矩形区域右下角单元格的位置。


\medskip
\begin{scope}
\hfuzz=10cm
\begin{BVerbatim}[boxwidth=10cm,baseline=c]
\begin{NiceTabular}{|c|c|c|}
  \CodeBefore
    ~emphase#\rectanglecolor{blue!15}{2-2}{3-3}@
  \Body
\hline
a & b & c \\ \hline
e & f & g \\ \hline
h & i & j \\ \hline
\end{NiceTabular}
\end{BVerbatim}
\begin{NiceTabular}{|c|c|c|}
  \CodeBefore
    \rectanglecolor{blue!15}{2-2}{3-3}
  \Body
    \hline
    a & b & c \\ \hline
    e & f & g \\ \hline
    h & i & j \\ \hline
\end{NiceTabular}
\end{scope}



\bigskip
%\item The command |\rowcolor| takes its name from the command |\rowcolor| of
%\pkg{colortbl}. Its first mandatory argument is the color and the second is a
%comma-separated list of rows or interval of rows with the form $a$-$b$ (an
%interval of the form $a$- represent all the rows from the row $a$ until the end).
\item |\rowcolor| 命令用于对行进行着色，其名称源于 \pkg{colortbl} 宏包，。
它有 2 个必选参数，第 1 个是颜色，第 2 个是需要着色的行。
在指定行时，可以用 1 个整数指定单行，可以用“ $a$-$b$ ”指定连续多行，
还可以用“ $a$- ”指定从某一行开始直至最后一行之间的矩形区域。多个行参数间用英文逗号（,）分隔。

\medskip
\begin{scope}
\hfuzz = 10cm
\begin{BVerbatim}[boxwidth=9cm,baseline=c]
$\begin{NiceArray}{lll}[hvlines] 
  \CodeBefore
    ~emphase#code-before = \rowcolor{red!15}{1,3-5,8-}@
  \Body
    a_1    & b_1    & c_1 \\
    a_2    & b_2    & c_2 \\
    a_3    & b_3    & c_3 \\   
    a_4    & b_4    & c_4 \\
    a_5    & b_5    & c_5 \\
    a_6    & b_6    & c_6 \\
    a_7    & b_7    & c_7 \\
    a_8    & b_8    & c_8 \\
    a_9    & b_9    & c_9 \\
    a_{10} & b_{10} & c_{10} \\
\end{NiceArray}$
\end{BVerbatim}
$\begin{NiceArray}{lll}[baseline=4,hvlines] 
\CodeBefore 
\rowcolor{red!15}{1,3-5,8-}
\Body
a_1 & b_1 & c_1 \\
a_2 & b_2 & c_2 \\
a_3 & b_3 & c_3 \\
a_4 & b_4 & c_4 \\
a_5 & b_5 & c_5 \\
a_6 & b_6 & c_6 \\
a_7 & b_7 & c_7 \\
a_8 & b_8 & c_8 \\
a_9 & b_9 & c_9 \\
a_{10} & b_{10} & c_{10} \\
\end{NiceArray}$
\end{scope}


\bigskip
%\item The command |\columncolor| takes its name from the command
%|\columncolor| of \pkg{colortbl}. Its syntax is similar to the syntax of
%|\rowcolor|.
\item  |\columncolor| 命令用于对列进行着色，其名称源于 \pkg{colortbl} 宏包。语法与 |\rowcolor| 命令类似。

\bigskip
%\item The command |\rowcolors| (with a \emph{s}) takes its name from the
%command |\rowcolors| of \pkg{xcolor}\footnote{The command |\rowcolors| of
%\pkg{xcolor} is available when \pkg{xcolor} is loaded with the option~|table|.
%That option also loads the package \pkg{colortbl}.}. The \emph{s} emphasizes
%the fact that there is \emph{two} colors. This command colors alternately the
%rows of the tabular with the tow colors (provided in second and third
%argument), beginning with the row whose number is given in first (mandatory)
%argument.
%
%In fact, the first (mandatory) argument is, more generally, a comma separated
%list of intervals describing the rows involved in the action of |\rowcolors|
%(an interval of the form $i$|-| describes in fact the interval of all the rows
%of the tabular, beginning with the row~$i$).

\item |\rowcolors| （注意末尾的 “s”）命令用于使用 2 种颜色对行进行交替着色，其名称来源于 \pkg{xcolor} 宏包。
\footnote{在\pkg{xcolor} 中使用 |\textbackslash rowcolors| 命令应使用 |\textbackslash usepackage[table]{xcolor}| 载入宏包， 这个命令也会同时载入 \pkg{colortbl} 宏包。}
|\rowcolors| 命令有 3 个必选参数和 2 个可选参数。

\FTN{|\textblank rowcolor| 命令的形式是：\par
\hspace{-2em}|\textbackslash rowcolors||[颜色模式]\{着色区域\}\{颜色1\}\{颜色2\}[cols=.../restart/respect-block]|}

第 1 个必选参数表示需交替着色的行区域的列表，
第 2 个必选参数表示交替着色中的第 1 种颜色，
第 3 个必选参数表示交替着色中的第 2 种颜色。

交替着色的行列表项的形式有多种，
单个数字 $i$ 表示从第 $i$ 行开始直至阵列末行；“
$i-j$ ”表示从第 $i$ 至 $j$ 行；
可以用逗号（,）分隔多个列表项。

\bigskip
%The last argument of |\rowcolors| is an optional list of pairs key-value (the
%optional argument in the first position corresponds to the colorimetric
%space). The available keys are |cols|, |restart| and |respect-blocks|.
|\rowcolors| 命令的最后 1 个参数是一个可选参数列表，取值可以是 |cols|、|restart| 和 |respect-blocks|。

%\FTN{原文中的“可选参数列表”后，在括号内还有一句话：“the optional argument in the first position corresponds to the colorimetric space)”，暂不明其含义。}
\begin{itemize}
%\item The key |cols| describes a set of columns. The command |\rowcolors| will
%color only the cells of these columns. The value is a comma-separated list of
%intervals of the form $i$-$j$.
\item |cols| 选项表示交替着色的列（默认所有列全部交替着色）。列的指定方法与行相同。
%\item With the key |restart|, each interval of rows (specified by the first
%mandatory argument) begins with the same color.\footnote{Otherwise, the color
%of a given row relies only upon the parity of its number.}
\item |restart| 选项表示交替着色的行列表中，每个列表项均从第 1 个颜色开始着色。\footnote{如不设置 |restart| 选项，给定行的颜色仅取决于行的编号。}
%\item With the key |respect-blocks| the ``rows'' alternately colored may extend over
%several rows if they have to incorporate blocks (created with the command
%|\Block|: cf.~p.~\pageref{Block}).
\item |respect-blocks| 选项表示将使用 |\Block| 命令（详见~p.~\pageref{Block}）创建的“块”视作 1 个单元格进行着色。
\end{itemize}


\medskip
\begin{scope}
\hfuzz=10cm
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
\begin{NiceTabular}{clr}[hvlines]
  \CodeBefore
    ~emphase#\rowcolors{2}{blue!10}{}[cols=2-3,restart]@
  \Body
    \Block{1-*}{Results} \\
    \Block{2-1}{A} & John    & 12 \\
                   & Stephen & 8 \\
    \Block{4-1}{B} & Sarah   & 18 \\
                   & Ashley  & 20 \\
                   & Henry   & 14 \\
                   & Madison & 15
\end{NiceTabular}
\end{BVerbatim}
\begin{NiceTabular}{clr}[hvlines,baseline=2]
\CodeBefore
\rowcolors{2}{blue!10}{}[cols=2-3,restart]
\Body
\Block{1-*}{Results} \\
\Block{2-1}{A} & John    & 12 \\
               & Stephen & 8 \\
\Block{4-1}{B} & Sarah   & 18 \\
               & Ashley  & 20 \\
               & Henry   & 14 \\
               & Madison & 15
\end{NiceTabular}
\end{scope}

\vspace{1cm}
\begin{scope}
\hfuzz=10cm
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
\begin{NiceTabular}{lr}[hvlines]
  \CodeBefore
    ~emphase#\rowcolors{1}{blue!10}{}[respect-blocks]@
  \Body
    \Block{2-1}{John}    & 12 \\
                         & 13 \\
    Steph                &  8 \\
    \Block{3-1}{Sarah}   & 18 \\
                         & 17 \\
                         & 15 \\
    Ashley               & 20 \\
    Henry                & 14 \\
    \Block{2-1}{Madison} & 15 \\
                         & 19
\end{NiceTabular}
\end{BVerbatim}
\begin{NiceTabular}{lr}[hvlines,baseline=c]
\CodeBefore
 \rowcolors{1}{blue!10}{}[respect-blocks]
\Body
\Block{2-1}{John}    & 12 \\
                    & 13 \\
Steph                &  8 \\
\Block{3-1}{Sarah}   & 18 \\
                    & 17 \\
                    & 15 \\
Ashley               & 20 \\
Henry                & 14 \\
\Block{2-1}{Madison} & 15 \\
                    & 19
\end{NiceTabular}
\end{scope}


\bigskip
%\item The command |\chessboardcolors| takes in as mandatory arguments two colors
%and it colors the cells of the tabular in quincunx with these colors.
\item |\chessboardcolors| 表示对阵列中所有的行和列进行“棋盘”着色。它有 2 个必选参数，分别表示“棋盘”里的 2 种颜色。

\medskip
\begin{scope}
\hfuzz=10cm
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
$\begin{pNiceMatrix}[r,margin]
  \CodeBefore
    ~emphase#\chessboardcolors{red!15}{blue!15}@
  \Body
     1 & -1 & 1 \\
    -1 &  1 & -1 \\
     1 & -1 & 1
\end{pNiceMatrix}$
\end{BVerbatim}
$\begin{pNiceMatrix}[r,baseline=1, margin]
  \CodeBefore 
    \chessboardcolors{red!15}{blue!15}
  \Body
    1  & -1 & 1 \\
    -1 & 1  & -1 \\
    1  & -1 & 1
\end{pNiceMatrix}$
\end{scope}

\medskip
%We have used the key |r| which aligns all the columns rightwards (cf. p.~\pageref{key-R}).
还可以使用 |r| 选项指定所有列的对齐方式为右对齐，详见~p.~\pageref{key-R}。

% \item \colorbox{yellow!50}{\textbf{New 5.13}}\enskip 
% The command |\arraycolor| takes in as mandatory argument a color and color
% the whole tabular with that color (excepted the potential exterior rows and
% columns: cf.~p.~\pageref{exterior}). This command is useful thanks to its key
% |except-corners| (in the third argument, which is a optional argument between
% square brackets). The definition of these ``corners'' has been given
% p.~\pageref{except-corners} when we have presented the key
% |hvlines-except-corners|.
%
\colorbox{yellow!50}{\textbf{v5.13 新增}} 命令 |\arraycolor| 接受一种颜色作为强制参数，并用该颜色对整个阵列进行着色（不含可能的外部行和外部列，详见~p~\pageref {exterior}）。 |\arraycolor| 命令也可以指定 |except-corners| 选项（详见~p~\pageref{except-corners} 中 |hvlines-except-corners| 有关内容）。

\label{arraycolor}
% 
%
\medskip
\begin{BVerbatim}[boxwidth=10cm,baseline=c]
\begin{NiceTabular}{*{6}{c}}[cell-space-top-limit=3pt]
\CodeBefore
 ~emphase#\arraycolor{blue!10}[except-corners=NE]@
\Body
1\\
1 & 1\\
1 & 2 & 1\\
1 & 3 & 3 & 1\\
1 & 4 & 6 & 4  &1\\
1 & 5 & 10& 10 & 5 & 1
\end{NiceTabular}
\end{BVerbatim}
\begin{NiceTabular}{*{6}{c}}[cell-space-top-limit=3pt]
\CodeBefore
  \arraycolor{blue!10}[except-corners=NE]
\Body
1\\
1&1\\
1&2&1\\
1&3&3&1\\
1&4&6&4&1\\
1&5&10&10&5&1 
\end{NiceTabular}

\end{itemize}



\bigskip
%One should remark that these commands are compatible with the commands of
%\pkg{booktabs} (|\toprule|, |\midrule|, |\bottomrule|, etc). However,
%\pkg{booktabs} is not loaded by \pkg{nicematrix}.
上述命令与 \pkg{booktabs} 提供的|\toprule|、|\midrule| 和 |\bottomrule|等命令兼容。（ \pkg{nicematrix} 不载入 \pkg{booktabs} 宏包。）

\medskip
\begin{scope}
\hfuzz=10cm
\begin{BVerbatim}[baseline=c,boxwidth=8cm]
\begin{NiceTabular}[c]{lSSSS}
  \CodeBefore
    \rowcolor{red!15}{1-2} 
    \rowcolors{3}{blue!15}{}
  \Body
    ~emphase#\toprule@
    \Block{2-1}{Product} &
    \Block{1-3}{dimensions (cm)} & & & 
    \Block{2-1}{\rotate Price} \\
    ~emphase#\cmidrule(rl){2-4}@ & L & l & h \\
    ~emphase#\midrule@
    small    & 3   & 5.5  & 1   & 30  \\
    standard & 5.5 & 8    & 1.5 & 50.5\\
    premium  & 8.5 & 10.5 & 2   & 80  \\
    extra    & 8.5 & 10   & 1.5 & 85.5\\
    special  & 12  & 12   & 0.5 & 70  \\
    ~emphase#\bottomrule@
\end{NiceTabular}
\end{BVerbatim}
\begin{NiceTabular}[c]{lSSSS}
\CodeBefore
\rowcolor{red!15}{1-2} 
\rowcolors{3}{blue!15}{}
\Body
\toprule
\Block{2-1}{Product} & 
\Block{1-3}{dimensions (cm)} & & & 
\Block{2-1}{\rotate Price} \\
\cmidrule(rl){2-4} 
& L & l & h \\
\midrule
small    & 3   & 5.5  & 1   & 30  \\
standard & 5.5 & 8    & 1.5 & 50.5\\
premium  & 8.5 & 10.5 & 2   & 80  \\
extra    & 8.5 & 10   & 1.5 & 85.5\\
special  & 12  & 12   & 0.5 & 70  \\
\bottomrule
\end{NiceTabular}
\end{scope}


\medskip 
%We have used the type of column |S| of \pkg{siunitx}.
在上例中，使用了 \pkg{siunitx} 宏包提供的 |S| 型列以使各单元内的小数点整体对齐。


%\subsection{Color tools with the syntax of colortbl}
\subsection{以 colortbl 宏包语法为单元格着色}

%It's possible to access the preceding tools with a syntax close to the syntax
%of \pkg{colortbl}. For that, one must use the key |colortbl-like| in the
%current environment.\footnote{As for now, this key is \emph{not} available in |\NiceMatrixOptions|.}
在上述命令中，如需使用与 \pkg{colortbl} 宏包相似的语法，可在环境的导言中使用 |colortbl-like| 选项。\footnote{在当前版本（v \nicematrixfileversion），暂不支持在 |\textbackslash NiceMatrixOptions| 中设置 |colortbl-like| 选项。}

%There are three commands available (they are inspired by \pkg{colortbl} but
%are \emph{independent} of \pkg{colortbl}):
与 \pkg{colortbl} 宏包语法相似的命令有 3 个（这种语法受 \pkg{colortbl} 宏包启发，但不依赖于 \pkg{colortbl}），分别是：
\begin{itemize}
%\item |\cellcolor| which colorizes a cell;
\item |\cellcolor| 命令用于为单个单元格进行着色；
%\item |\rowcolor| which must be used in a cell and which colorizes the end of
%the row;
\item |\rowcolor| 命令必须在某一单元格中使用，表示对当前行中从当前单元格开始直至行末的单元进行着色；\label{zm:rowcolor}
%\item |\columncolor| which must be used in the preamble of the environment
%with the same syntax as the corresponding command of
%\pkg{colortbl} (however, unlike the command |\columncolor| of \pkg{colortbl},
%this command |\columncolor| can appear within another command, itself used in the
%preamble of the array). 
\item |\columncolor| 命令用于对列进行着色，必须在环境的导言区使用，语法与 \pkg{colortbl} 宏包中 |\columncolor| 命令的语法相同。与 \pkg{colortbl} 宏包中 |\columncolor| 命令不同的是，|nicematrix| 宏包中 |\columncolor| 命令可以在数组环境中使用。
\end{itemize}

\medskip
\begin{Verbatim}
\NewDocumentCommand { \Blue } { } { ~emphase#\columncolor{blue!15}@ }
\begin{NiceTabular}[colortbl-like]{>{\Blue}c>{\Blue}cc} 
  \toprule
  ~emphase#\rowcolor{red!15}@
  Last name & First name & Birth day       \\
  \midrule
  Achard    & Jacques    & 5 juin 1962     \\
  Lefebvre  & Mathilde   & 23 mai 1988     \\
  Vanesse   & Stephany   & 30 octobre 1994 \\
  Dupont    & Chantal    & 15 janvier 1998 \\
  \bottomrule
\end{NiceTabular}
\end{Verbatim}


\begin{center}
\NewDocumentCommand { \Blue } { } { \columncolor{blue!15} }
\begin{NiceTabular}[colortbl-like]{>{\Blue}c>{\Blue}cc} 
\toprule
\rowcolor{red!15}
Last name & First name & Birth day \\
\midrule
Achard  & Jacques & 5 juin 1962 \\
Lefebvre & Mathilde & 23 mai 1988 \\
Vanesse & Stephany & 30 octobre 1994 \\
Dupont & Chantal & 15 janvier 1998 \\
\bottomrule
\end{NiceTabular}
\end{center}

\NFTN 关于 |\rowcolor| 命令的另一个示例见~p.~\pageref{zm:rowcolor2} 。
%
%
%\section{The width of the columns}
\section{列的宽度（width of the columns）}
\label{width}

%In the environments with an explicit preamble (like |{NiceTabular}|,
%|{NiceArray}|, etc.), it's possible to fix the width of a given column with
%the standard letters |w| and |W| of the package \pkg{array}.
与\pkg{array} 宏包类似，\pkg{nicematrix} 支持在带有选项的环境中，如 |{NiceTabular}| 和 |{NiceArray}| 等， 以 |w| 和 |W| 的形式为列指定宽度。

\medskip
\begin{BVerbatim}[baseline=c,boxwidth=8cm]
\begin{NiceTabular}{~emphase#Wc{2cm}@cc}[hvlines]
  Paris  & New York & Madrid \\
  Berlin & London   & Roma   \\
  Rio    & Tokyo    & Oslo 
\end{NiceTabular}
\end{BVerbatim}
\begin{NiceTabular}{Wc{2cm}cc}[hvlines]
Paris  & New York & Madrid \\
Berlin & London   & Roma   \\
Rio    & Tokyo    & Oslo 
\end{NiceTabular}


\bigskip
%In the environments of \pkg{nicematrix}, it's also possible to fix the \emph{minimal}
%width of all the columns of an array directly with the key |columns-width|.
在 \pkg{nicematrix} 的环境中，还可以通过 |columns-width| 选项设置列的\emph{最小}宽度。

\medskip
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
$\begin{pNiceMatrix}[~emphase#columns-width = 1cm@]
  1  & 12 & -123 \\
  12 & 0  & 0    \\
  4  & 1  & 2 
\end{pNiceMatrix}$
\end{BVerbatim}
$\begin{pNiceMatrix}[columns-width = 1cm]
1  & 12 & -123 \\
12 & 0  & 0    \\
4  & 1  & 2 
\end{pNiceMatrix}$

\medskip
%Note that the space inserted between two columns (equal to 2 |\tabcolsep| in
%|{NiceTabular}| and to 2 |\arraycolsep| in the other environments)
%is not suppressed (of course, it's possible to suppress this space by setting
%|\tabcolsep| or |\arraycolsep| equal to $0$~pt before the environment).
需要指出的是，上述通过 |columns-width| 设置的列\emph{最小}宽度不含在列间插入的水平空白。
在 |{NiceTabular}| 环境中，列间的空白宽度为 2 倍 |\tabcolsep| ，
在其他环境中，列间的空白等于2 倍 |\arraycolsep|。
如不需要这些列间空白，可在环境选项中将 |\tabcolsep| 或 |\arraycolsep| 设置为 $0$~pt。

\bigskip
%It's possible to give the special value |auto| to the option |columns-width|:
%all the columns of the array will have a width equal to the widest cell of the
%array.\footnote{The result is achieved with only one compilation (but PGF/Tikz
%will have written informations in the |.aux| file and a message requiring a
%second compilation will appear).}\par\nobreak
还可以将 |columns-width| 的设定为 |auto| ，表示表格所有列的宽度与表格中最宽单元格的宽度相同。\footnote{尽管 \textsc{pgf}/\tikzname 会将有关信息写入 |.aux| 文件，并提示需再次编译，但实际上一次编译即可达成“等宽列”的效果。}


\medskip
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
$\begin{pNiceMatrix}[~emphase#columns-width = auto@]
  1  & 12 & -123 \\
  12 & 0  &    0 \\
  4  & 1  &    2
\end{pNiceMatrix}$
\end{BVerbatim}
$\begin{pNiceMatrix}[columns-width = auto]
1  & 12 & -123 \\
12 & 0  & 0    \\
4  & 1  & 2 
\end{pNiceMatrix}$

\bigskip
%Without surprise, it's possible to fix the minimal width of the columns of all
%the matrices of a current scope with the command
%|\NiceMatrixOptions|.\par\nobreak
也可以通过 |\NiceMatrixOptions| 指定一定范围内所有表格中列的最小宽度。

\FTN{在文档导言区使用 \textsf{\textbackslash NiceMatrixOptions} 命令，会影响文档的全部内容；\par 在文档正文区使用 \textsf{\textbackslash NiceMatrixOptions} 命令，会影响其后的所有内容。}

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=8cm]
~emphase#\NiceMatrixOptions{columns-width=10mm}@
$\begin{pNiceMatrix}
  a & b \\ c      & d
\end{pNiceMatrix}
= 
\begin{pNiceMatrix}
  1 & 1245 \\ 345 & 2
\end{pNiceMatrix}$
\end{BVerbatim}
\begin{scope}
\NiceMatrixOptions{columns-width=10mm}
$\begin{pNiceMatrix}
a & b \\
c & d 
\end{pNiceMatrix}
= 
\begin{pNiceMatrix}
1   & 1245 \\
345 & 2 
\end{pNiceMatrix}$
\end{scope}


\bigskip
%But it's also possible to fix a zone where all the matrices will have their
%columns of the same width, equal to the widest cell of all the matrices. This
%construction uses the environment |{NiceMatrixBlock}| with the option
%|auto-columns-width|\footnote{At this time, this is the only usage of the
%environment |{NiceMatrixBlock}| but it may have other usages in the future.}.
%The environment |{NiceMatrixBlock}| has no direct link with the command
%|\Block| presented previously in this document (cf.~p.~\pageref{Block}).
\label{sec:}
有时，我们仅仅希望在一个确定的范围内的多个矩阵的列宽相同。针对这种需求，可以使用 |{NiceMatrixBlock}| 环境，并开启 |auto-columns-width| 选项\footnote{这是当前 |{NiceMatrixBlock}| 环境的主要应用场景，将来它还可以有更多用途。}。
需要说明的，这里的 |{NiceMatrixBlock}| 环境与前文中的“块”命令 |\Block| （~p.~\pageref{Block}）没有直接的联系。

\label{zm:NiceMatrixBlock1}

\medskip
\begin{BVerbatim}[baseline=c,boxwidth=8.5cm]
~emphase#\begin{NiceMatrixBlock}[auto-columns-width]@
  $\begin{array}{c}
    \begin{bNiceMatrix}
      9 & 17      \\ -2  & 5
    \end{bNiceMatrix} \\ \\
    \begin{bNiceMatrix}
      1 & 1245345 \\ 345 & 2
    \end{bNiceMatrix}
  \end{array}$
~emphase#\end{NiceMatrixBlock}@
\end{BVerbatim}
\begin{NiceMatrixBlock}[auto-columns-width]
$\begin{array}{c}
  \begin{bNiceMatrix}
  9 & 17 \\ -2 & 5 
  \end{bNiceMatrix} \\ \\
  \begin{bNiceMatrix}
  1   & 1245345 \\  345 & 2 
  \end{bNiceMatrix}
\end{array}$
\end{NiceMatrixBlock}

%v5.12中有下列内容，v5.13中删除
%\medskip
%%\textbf{Several compilations may be necessary to achieve the job.}
%\textbf{|{NiceMatrixBlock}| 环境需要多次编译才能生成正确的结果。}

\colorbox{red!30}{译者注\tnn } 关于 |NiceMatrixBlock| 的另1个示例见~p.~\pageref{zm:NiceMatrixBlock2}。

%\bigskip
% \section{The exterior rows and columns}
\section{外部行和外部列（ exterior rows and columns）}
\label{zm:ExteriorRowAndColumn}

%The options |first-row|, |last-row|, |first-col| and |last-col| allow the
%composition of exterior rows and columns in the environments of
%\pkg{nicematrix}.
%\label{exterior}
在 \pkg{nicematrix} 的环境中，可以使用 |first-row| 、 |last-row| 、 |first-col| 和 |last-col| 在阵列主体区域之外绘制外部行和列。
\label{exterior}

%A potential ``first row'' (exterior) has the number $0$ (and not $1$). Idem
%for the potential ``first column''. 
在这些外部的行和列中，阵列左侧外部列（ |first-col| ）和阵列上方外部行（ |first-row|）的编号都是 $0$ 。表格主体区域行和列的编号都从 $1$ 开始。

\begin{Verbatim}
$\begin{pNiceMatrix}[~emphase#first-row,last-row,first-col,last-col@,nullify-dots]
         & C_1    & \Cdots &        & C_4    &        \\
  L_1    & a_{11} & a_{12} & a_{13} & a_{14} & L_1    \\
  \Vdots & a_{21} & a_{22} & a_{23} & a_{24} & \Vdots \\
         & a_{31} & a_{32} & a_{33} & a_{34} &        \\
  L_4    & a_{41} & a_{42} & a_{43} & a_{44} & L_4    \\
         & C_1    & \Cdots &        & C_4    &     
\end{pNiceMatrix}$
\end{Verbatim}

\[\begin{pNiceMatrix}[first-row,last-row,first-col,last-col,nullify-dots]
       & C_1    & \Cdots &        & C_4    &        \\
L_1    & a_{11} & a_{12} & a_{13} & a_{14} & L_1    \\
\Vdots & a_{21} & a_{22} & a_{23} & a_{24} & \Vdots \\
       & a_{31} & a_{32} & a_{33} & a_{34} &        \\
L_4    & a_{41} & a_{42} & a_{43} & a_{44} & L_4    \\
       & C_1    & \Cdots &        & C_4    &     
\end{pNiceMatrix}\]

\medskip
%The dotted lines have been drawn with the tools presented p.~\pageref{Cdots}.
上例中，外部行（列）均使用了虚线框线。关于虚线框线，请参见~p.~\pageref{Cdots} 。

\bigskip
%We have several remarks to do.
关于阵列的外部行和外部列，有几点需要说明：
\begin{itemize}[beginpenalty=10000]
%\item For the environments with an explicit preamble (i.e. |{NiceTabular}|,
%|{NiceArray}| and its variants), no letter must be given in that preamble for
%the potential first column and the potential last column: they will
%automatically (and necessarily) be of type |r| for the first column and |l|
%for the last one.\footnote{The users wishing exteriors columns with another
%type of alignment should consider the command |\SubMatrix| available in the
%|\CodeAfter| (cf.~p.~\pageref{sub-matrix}).}
\item 在有选项的环境中，如 |{NiceTabular}| 、 |{NiceArray}| 等，
左侧外部列的内容默认靠右对齐，右侧外部列的内容默认靠左对齐。
\footnote{如需修改表外列的对齐方式，可以在 |\textbackslash CodeAfter| 中通过  |\textbackslash SubMatrix| 指定，详见~p.~\pageref{sub-matrix}。}
%\item One may wonder how \pkg{nicematrix} determines the number of rows and
%columns which are needed for the composition of the ``last row'' and ``last
%column''.
\item 在\pkg{nicematrix} 中，确定右侧外部列和下方外部行编号的方法如下：
\begin{itemize}
%\item For the environments with explicit preamble, like |{NiceTabular}| and
%|{pNiceArray}|, the number of columns can obviously be computed from the
%preamble.
\item 在有导言区的环境中，如 |{NiceTabular}| 、|{pNiceArray}| 等，
可以方便地从导言中计算出阵列内列的数量。

%\item When the option |light-syntax| (cf. p. \pageref{light-syntax}) is used,
%\pkg{nicematrix} has, in any case, to load the whole body of the environment
%(and that's why it's not possible to put verbatim material in the array with
%the option |light-syntax|). The analysis of this whole body gives the number
%of rows (but not the number of columns).
\item 当启用 |light-syntax| 选项（详见~p.~\pageref{light-syntax}）后，
\pkg{nicematrix} 将整个表格的内容一次性全部载入（这也是不能在启用 |light-syntax| 选项的 |array| 环境中使用抄录内容的原因），并对内容进行分析，得出行数（不是列数）。

%\item In the other cases, \pkg{nicematrix} compute the number of rows and
%columns during the first compilation and write the result in the |aux| file
%for the next run.
\item 除上述 2 种情况外， \pkg{nicematrix} 在第 1 次编译时会计算行数和列数，
并将结果写入 |.aux| 文件中用于再次编译。

%\textsl{However, it's possible to provide the number of the last row and the
%number of the last column as values of the options |last-row| and |last-col|,
%tending to an acceleration of the whole compilation of the document.} That's
%what we will do throughout the rest of the document.
\textsl{通过上述分析可知，如果事先指定 |last-row| 和 |last-col|的具体数值，可以加快文档的编译速度。}
示例见下。
\end{itemize}
\end{itemize}

\bigskip
%It's possible to control the appearance of these rows and columns with options
%|code-for-first-row|, |code-for-last-row|, |code-for-first-col| and
%|code-for-last-col|. These options specify tokens that will be inserted before
%each cell of the corresponding row or column. 
外部行和列的样式也可以自定义。具体可通过 |code-for-first-row|、 |code-for-last-row|、 |code-for-first-col| 和 |code-for-last-col| 进行设置。
这些选项将被用于在相应行或列的每个单元格之前插入指定的内容。

\FTN{ |code-for-first-row|、 |code-for-last-row|、 |code-for-first-col| 和 |code-for-last-col| 用于设置外部行（列）的整体效果，似不支持对外部行（列）中每一个单元格的格式进行设置。}

\begin{Verbatim}
\NiceMatrixOptions{~emphase#code-for-first-row@ = \color{red},
                   ~emphase#code-for-first-col@ = \color{blue},
                   ~emphase#code-for-last-row@  = \color{green},
                   ~emphase#code-for-last-col@  = \color{magenta}}
$\begin{pNiceArray}{cc|cc}[first-row,last-row=5,first-col,last-col,nullify-dots]
         & C_1    & \Cdots &        & C_4    &        \\
  L_1    & a_{11} & a_{12} & a_{13} & a_{14} & L_1    \\
  \Vdots & a_{21} & a_{22} & a_{23} & a_{24} & \Vdots \\
  \hline
         & a_{31} & a_{32} & a_{33} & a_{34} &        \\
  L_4    & a_{41} & a_{42} & a_{43} & a_{44} & L_4    \\
         & C_1    & \Cdots &        & C_4    &     
\end{pNiceArray}$
\end{Verbatim}

\begin{scope}
\NiceMatrixOptions{code-for-first-row = \color{red},
                  code-for-first-col = \color{blue},
                  code-for-last-row = \color{green},
                  code-for-last-col = \color{magenta}}
\begin{displaymath}
\begin{pNiceArray}{cc|cc}[first-row,last-row=5,first-col,last-col,nullify-dots]
      & C_1    & \multicolumn1c{\Cdots} &        & C_4    &        \\
L_1    & a_{11} & a_{12} & a_{13} & a_{14} & L_1    \\
\Vdots & a_{21} & a_{22} & a_{23} & a_{24} & \Vdots \\
\hline
      & a_{31} & a_{32} & a_{33} & a_{34} &        \\
L_4    & a_{41} & a_{42} & a_{43} & a_{44} & L_4    \\
      & C_1    & \multicolumn1c{\Cdots} &        & C_4    &     
\end{pNiceArray}
\end{displaymath}
\end{scope}


%\emph{Remarks}
\emph{提示：}
\begin{itemize}[beginpenalty=10000]
%\item As shown in the previous example, the horizontal and vertical rules
%doesn't extend in the exterior rows and columns.
\item 如上例所示，阵列内的水平和垂直框线不会延伸至阵列外的行和列。

%However, if one wishes to define new specifiers for columns in order to draw
%vertical rules (for example thicker than the standard rules), he should
%consider the command |\OnlyMainNiceMatrix| described on
%page~\pageref{OnlyMainNiceMatrix}.
如需为列定制新的标识符以绘制垂直框线（如绘制比标准线宽更粗的垂直框线），
可以考虑使用 |\OnlyMainNiceMatrix| 命令，
详见~p.~\pageref{OnlyMainNiceMatrix} 。

%\item A specification of color present in |code-for-first-row| also applies to
%a dotted line draw in this exterior ``first row'' (excepted if a value has
%been given to |xdots/color|). Idem for the other exterior rows and columns.
\item 在上例中， |code-for-first-row| 指定的字符颜色也可应用于该表外行中的虚线。虚线的颜色也可以用 |xdots/color| 选项单独指定。其余阵列外部行（列）同 |code-for-first-row|。

%\item Logically, the potential option |columns-width| (described
%p.~\pageref{width}) doesn't apply to the ``first column'' and ``last column''.
\item 逻辑上，最小列宽选项 |columns-width| （详见~p.~\pageref{width}）不会应用于阵列外的行和列。

%\item For technical reasons, it's not possible to use the option of the
%command |\\| after the ``first row'' or before the ``last row''. The placement
%of the delimiters would be wrong. If you are looking for a workaround,
%consider the command |\SubMatrix| in the |\CodeAfter| described
%p.~\pageref{sub-matrix}. 
\item 由于技术原因，阵列上方的外部行（``first row''）之后和下方的外部行（``last row''）之前不能使用硬换行命令“ |\\| ”。
如果确需使用，可以考虑在 |\CodeAfter| 中使用  |\SubMatrix|（详见~p.~\pageref{sub-matrix}）。
\end{itemize}

%\section{The continuous dotted lines}
\section{阵列中的虚线（continuous dotted lines）}
\label{Cdots}
%Inside the environments of the package \pkg{nicematrix}, new commands are
%defined: |\Ldots|, |\Cdots|, |\Vdots|, |\Ddots|, and |\Iddots|. These commands
%are intended to be used in place of |\dots|, |\cdots|, |\vdots|, |\ddots| and
%|\iddots|.\footnote{The command |\iddots|, defined in \pkg{nicematrix}, is a
%variant of |\ddots| with dots going forward. If |mathdots| is loaded, the
%version of |mathdots| is used. It corresponds to the command |\adots| of
%\pkg{unicode-math}.} 
%\newcounter{fniddots} 
%\setcounter{fniddots}{\thefootnote}
\pkg{nicematrix} 中定义了 |\Ldots| 、 |\Cdots| 、 |\Vdots| 、 |\Ddots| 和 |\Iddots| 等虚线命令，分别用于替代 |\dots| 、 |\cdots| 、 |\vdots| 、 |\ddots| 和 |\iddots|。\footnote{|nicematrix| 中定义的 |\textbackslash iddots| 命令是 |\textbackslash ddots| 命令的一个变体。如果载入了 \pkg{mathdots} 宏包，则使用该宏包中的 |\textbackslash ddots| 。它相当于 \pkg{unicode-math} 宏包中的 |\textbackslash adots| 命令（\NFTN： \pkg{unicode-math} 似乎没有  |\textbackslash adots| 命令）。}

\smallskip
%Each of them must be used alone in the cell of the array and it draws a dotted
%line between the first non-empty cells\footnote{The precise definition of a
%``non-empty cell'' is given below (cf. p.~\pageref{empty-cells}).} on both
%sides of the current cell. Of course, for |\Ldots| and |\Cdots|, it's an
%horizontal line; for |\Vdots|, it's a vertical line and for |\Ddots| and
%|\Iddots| diagonal ones. It's possible to change the color of these lines
%with the option |color|.\footnote{It's also possible to change the color of
%all theses dotted lines with the option |xdots/color| (\textsl{xdots} to
%remind that it works for |\Cdots|, |\Ldots|, |\Vdots|, etc.): cf. p.
%\pageref{customisation}.}\par\nobreak  
上述绘制虚线的命令必须在一个单元格（或“块”）内使用，它们可以自动延伸至该虚线两端的第一个非空单元格\footnote{“非空”单元格的定义详见~p.~\pageref{empty-cells}。}。
|\Ldots| 和 |\Cdots| 用于绘制横向虚线， |\Vdots| 用于绘制垂直虚线， |\Ddots| 和 |\Iddots| 用于绘制对角虚线。\footnote{每种虚线的颜色都可以用 |color| 选项指定，也可以用 |xdots/color|  选项指定所有虚线的颜色（详见~p.~\pageref{customisation}）。}\par\nobreak


\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
\begin{bNiceMatrix}
  a_1      & \Cdots &        & & a_1    \\
  \Vdots   & a_2    & \Cdots & & a_2    \\
           & \Vdots & \Ddots[color=red] \\
  \\
  a_1      & a_2    &        & & a_n 
\end{bNiceMatrix}
\end{BVerbatim}
$\begin{bNiceMatrix}
a_1      & \Cdots &        & & a_1    \\
\Vdots   & a_2    & \Cdots & & a_2    \\
        & \Vdots & \Ddots[color=red] \\
\\
a_1      & a_2    &        & & a_n 
\end{bNiceMatrix}$

\interitem 
%In order to represent the null matrix, one can use the following
%codage:\par\nobreak
空矩阵（null matrix）可以使用以下代码生成：\par\nobreak

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
\begin{bNiceMatrix}
  0      & \Cdots & 0      \\
  \Vdots &        & \Vdots \\
  0      & \Cdots & 0 
\end{bNiceMatrix}
\end{BVerbatim}
$\begin{bNiceMatrix}
0      & \Cdots & 0      \\
\Vdots &        & \Vdots \\
0      & \Cdots & 0 
\end{bNiceMatrix}$

\bigskip
%However, one may want a larger matrix. Usually, in such a case, the users of
%LaTeX add a new row and a new column. It's possible to use the same method
%with \pkg{nicematrix}:\par\nobreak 
上例中矩阵的尺寸偏小，如果想要生成更大一点的空矩阵，可以在矩阵中插入行和列。如下所示：\par\nobreak 

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
\begin{bNiceMatrix}
  0      & \Cdots & \Cdots & 0      \\
  \Vdots &        &        & \Vdots \\
  \Vdots &        &        & \Vdots \\
  0      & \Cdots & \Cdots & 0 
\end{bNiceMatrix}
\end{BVerbatim}
$\begin{bNiceMatrix}
0      & \Cdots & \Cdots & 0      \\
\Vdots &        &        & \Vdots \\
\Vdots &        &        & \Vdots \\
0      & \Cdots & \Cdots & 0 
\end{bNiceMatrix}$

\bigskip
%In the first column of this exemple, there are two instructions |\Vdots| but,
%of course, only one dotted line is drawn.
上例中，在首列、末列、首行和末行分别内使用了 2 个绘制虚线的命令（  |\Vdots| 和 |\Cdots| ），但最终在相应行（列）都只绘制了 1 条虚线。

\bigskip
%In fact, in this example, it would be possible to draw the same matrix more
%easily with the following code:\par\nobreak
事实上，上例中的空矩阵可以用更简洁的代码绘制：\par\nobreak

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
\begin{bNiceMatrix}
  0       & \Cdots &        & 0      \\
  \Vdots  &        &        &        \\
          &        &        & \Vdots \\
  0       &        & \Cdots & 0 
\end{bNiceMatrix}
\end{BVerbatim}
$\begin{bNiceMatrix}
0       & \Cdots &        & 0      \\
\Vdots  &        &        &        \\
       &        &        & \Vdots \\
0       &        & \Cdots & 0 
\end{bNiceMatrix}$

\FTN{“列简洁的代码”在上例中的具体体现是在空矩阵最外侧的行和列中，均只使用了 1 个绘制虚线的命令|\textbackslash Vdots|。}

\bigskip 
%There are also other means to change the size of the matrix. Someone might
%want to use the optional argument of the command~|\\| for the vertical
%dimension and a command~|\hspace*| in a cell for the horizontal
%dimension.\footnote{In \pkg{nicematrix}, one should use |\hspace*| and not
%|\hspace| for such an usage because \pkg{nicematrix} loads \pkg{array}. One
%may also remark that it's possible to fix the width of a column by using the
%environment |{NiceArray}| (or one of its variants) with a column of type~|w|
%or~|W|: see p.~\pageref{width}} 
还有其他方法可以更改矩阵的大小。 如使用命令 |\\[<高度>]| 以增加垂直尺寸，用 |\hspace*| 命令增加水平尺寸。\footnote{在 \pkg{nicematrix} 中，应使用 |\textbackslash hspace*| 命令而不是 |\textbackslash hspace| 命令，因为后者在 \pkg{nicematrix} 所依赖的 \pkg{array} 宏包中被使用。同时，还应注意在 |{NiceArray}| （及其变体）环境中还可以使用 |w| 或 |W| 选项指定列的宽度，详见~p.~\pageref{width}。}

%However, a command~|\hspace*| might interfer with the construction of the
%dotted lines. That's why the package \pkg{nicematrix} provides a
%command~|\Hspace| which is a variant of |\hspace| transparent for the dotted
%lines of \pkg{nicematrix}.\par\nobreak
由于 |\hspace*| 命令会干扰虚线的构建， \pkg{nicematrix} 定义了 |\Hspace| 命令，用于扩大表格的水平尺寸。\par\nobreak

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
\begin{bNiceMatrix}
  0      & \Cdots & ~emphase#\Hspace*{1cm}@ & 0      \\
  \Vdots &        &               & \Vdots ~emphase#\\[1cm]@
  0      & \Cdots &               & 0    
\end{bNiceMatrix}
\end{BVerbatim}
$\begin{bNiceMatrix}
0      & \Cdots & \Hspace*{1cm} & 0      \\
\Vdots &        &               & \Vdots \\[1cm]
0      & \Cdots &               & 0    
\end{bNiceMatrix}$

%\subsection{The option nullify-dots}
\subsection{“紧凑”虚线（nullify-dots）}

%Consider the following matrix composed classicaly with the environment
%\verb|{pmatrix}| of \pkg{amsmath}.\par\nobreak 
首先来看一个利用 \pkg{amsmath} 宏包的 \verb|{pmatrix}| 环境构建的矩阵示例。\par\nobreak 

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=9cm]
$A = \begin{pmatrix}
  h & i & j & k & l & m \\
  x &   &   &   &   & x 
\end{pmatrix}$
\end{BVerbatim}
$A = \begin{pmatrix}
h & i & j & k & l & m \\
x   &     &     &    &     & x 
\end{pmatrix}$


\bigskip
%If we add \verb|\ldots| instructions in the second row, the geometry of the
%matrix is modified.\par\nobreak
如果在第 2 行加入 \verb|\ldots| 命令，
由于“ $\ldots$ ”比普通字符宽，因此矩阵在水平方向上会被撑宽，如下例示。\par\nobreak

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=9cm]
$B = \begin{pmatrix}
  h & i      & j      & k      & l      & m\\
  x & \ldots & \ldots & \ldots & \ldots & x 
\end{pmatrix}$
\end{BVerbatim}
$B = \begin{pmatrix}
h & i & j & k & l & m \\
x   & \ldots   & \ldots  & \ldots & \ldots & x 
\end{pmatrix}$

\bigskip
%By default, with \pkg{nicematrix}, if we replace \verb|{pmatrix}| by
%\verb|{pNiceMatrix}| and \verb|\ldots| by \verb|\Ldots|, the geometry of the matrix is not
%changed.\par\nobreak 
默认情况下，如果使用 \pkg{nicematrix} 提供的 \verb|{pNiceMatrix}| 环境，
并在其中使用 \verb|\Ldots| 命令，则矩阵的水平尺寸同样会增加，如下例示。\par\nobreak

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=9cm]
$C = \begin{pNiceMatrix}
  h & i      & j      & k      & l      & m\\
  x & \Ldots & \Ldots & \Ldots & \Ldots & x 
\end{pNiceMatrix}$
\end{BVerbatim}
$C = \begin{pNiceMatrix}
h & i & j & k & l & m \\
x & \Ldots & \Ldots  & \Ldots & \Ldots & x 
\end{pNiceMatrix}$

\bigskip
%However, one may prefer the geometry of the first matrix $A$ and would like to
%have such a geometry with a dotted line in the second row. It's possible by
%using the option \verb|nullify-dots| (and only one instruction \verb|\Ldots| is
%necessary).\par\nobreak 
如果在矩阵 $A$ 中，想使第 2 行在用虚线填充的同时保持矩阵的整体宽度不变，
可以开启矩阵的 \verb|nullify-dots| 选项，同时在需要用虚线填充的位置使用 \verb|\Ldots| 命令。\par\nobreak

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=9cm]
$D = \begin{pNiceMatrix}[~emphase#nullify-dots@]
  h & i      & j & k & l & m \\
  x & ~emphase#\Ldots@ &   &   &   & x 
\end{pNiceMatrix}$
\end{BVerbatim}
$D = \begin{pNiceMatrix}[nullify-dots]
h & i      & j & k & l & m \\
x & \Ldots &   &   &   & x 
\end{pNiceMatrix}$

\medskip
%The option |nullify-dots| smashes the instructions |\Ldots| (and the variants)
%horizontally but also vertically.
 |nullify-dots| 选项对水平和垂直虚线都有效。



%\subsection{The commands \textbackslash Hdotsfor and \textbackslash Vdotsfor}
\subsection{可限定扩展范围的虚线（\texttt{\textbackslash}Hdotsfor 和 \texttt{\textbackslash}Vdotsfor 命令）}

%Some people commonly use the command |\hdotsfor| of \pkg{amsmath} in order to
%draw horizontal dotted lines in a matrix. In the environments of
%\pkg{nicematrix}, one should use instead |\Hdotsfor| in order to draw dotted
%lines similar to the other dotted lines drawn by the package \pkg{nicematrix}.
\pkg{amsmath} 宏包提供了 |\hdotsfor| 用于绘制水平虚线。
在 \pkg{nicematrix} 中，可以使用 |\Hdotsfor| 命令绘制水平虚线。


%As with the other commands of \pkg{nicematrix} (like |\Cdots|, |\Ldots|,
%|\Vdots|, etc.), the dotted line drawn with |\Hdotsfor| extends until the
%contents of the cells on both sides.
与 \pkg{nicematrix} 中的 |\Cdots|、|\Ldots| 和 |\Vdots| 等虚线命令相类似，
 |\Hdotsfor| 也会使虚线向两端扩展至“非空”单元格。

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=7cm]
$\begin{pNiceMatrix}
  1 & 2            & 3 & 4 & 5 \\
  1 & ~emphase#\Hdotsfor{3}@ & 5 \\
  1 & 2            & 3 & 4 & 5 \\
  1 & 2            & 3 & 4 & 5 
\end{pNiceMatrix}$
\end{BVerbatim}
$\begin{pNiceMatrix}
1 & 2 & 3 & 4 & 5 \\
1 & \Hdotsfor{3} & 5 \\
1 & 2 & 3 & 4 & 5 \\
1 & 2 & 3 & 4 & 5 
\end{pNiceMatrix}$

\bigskip
%However, if these cells are empty, the dotted line extends only in the cells
%specified by the argument of |\Hdotsfor| (by design).
|\Hdotsfor| 命令带有 1 个可选参数，用于限定虚线的扩展范围。

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=7cm]
$\begin{pNiceMatrix}
  1 & 2 & 3 & 4 & 5 \\
    & ~emphase#\Hdotsfor{3}@ \\
  1 & 2 & 3 & 4 & 5 \\
  1 & 2 & 3 & 4 & 5 
\end{pNiceMatrix}$
\end{BVerbatim}
$\begin{pNiceMatrix}
1 & 2 & 3 & 4 & 5 \\
 & \Hdotsfor{3} \\
1 & 2 & 3 & 4 & 5 \\
1 & 2 & 3 & 4 & 5 
\end{pNiceMatrix}$

\bigskip
%Remark: Unlike the command |\hdotsfor| of \pkg{amsmath}, the command
%|\Hdotsfor| may be used even when the package \pkg{colortbl}\footnote{We
%recall that when \pkg{xcolor} is loaded with the option \verb|table|, the
%package \pkg{colortbl} is loaded.} is loaded (but you might have problem if
%you use |\rowcolor| on the same row as |\Hdotsfor|). 
\pkg{amsmath} 宏包的 |\hdotsfor| 命令与 \pkg{colortbl} 宏包
\footnote{当使用 |\textbackslash usepackage[table]{xcolor}| 命令载入 \pkg{xcolor} 宏包时，\pkg{colortbl} 宏包被自动载入。}存在兼容性问题，
而 |\Hdotsfor| 命令与 \pkg{colortbl} 宏包协同工作良好。
应注意的是，如果在 |\Hdotsfor| 命令所在行内同时也使用 \pkg{colortbl} 宏包的行着色命令 |\rowcolor| 时，可能会存在兼容性问题。

\bigskip
%The package \pkg{nicematrix} also provides a command |\Vdotsfor| similar to
%|\Hdotsfor| but for the vertical dotted lines.
 \pkg{nicematrix} 还提供了 |\Vdotsfor| 命令用于绘制垂直虚线。
  |\Vdotsfor| 的特性与|\Hdotsfor| 相似。
\bigskip
%The following example uses both |\Hdotsfor| and |\Vdotsfor|:
以下是在一个矩阵中同时使用 |\Hdotsfor| 和 |\Vdotsfor|绘制虚线的例子。

\begin{Verbatim}[formatcom=\small\color{gray}]
\begin{bNiceMatrix}
  C[a_1,a_1] & \Cdots & C[a_1,a_n] 
   & \hspace*{20mm} & C[a_1,a_1^{(p)}] & \Cdots & C[a_1,a_n^{(p)}] \\
  \Vdots & \Ddots & \Vdots 
   & ~emphase#\Hdotsfor{1}@ & \Vdots & \Ddots & \Vdots \\ 
  C[a_n,a_1] & \Cdots & C[a_n,a_n] 
   & & C[a_n,a_1^{(p)}] & \Cdots & C[a_n,a_n^{(p)}] \\
  \rule{0pt}{15mm}\NotEmpty & ~emphase#\Vdotsfor{1}@ & & \Ddots & & ~emphase#\Vdotsfor{1}@ \\
  C[a_1^{(p)},a_1] & \Cdots & C[a_1^{(p)},a_n] 
   & & C[a_1^{(p)},a_1^{(p)}] & \Cdots & C[a_1^{(p)},a_n^{(p)}] \\
  \Vdots & \Ddots & \Vdots 
   & ~emphase#\Hdotsfor{1}@ & \Vdots & \Ddots & \Vdots \\ 
  C[a_n^{(p)},a_1] & \Cdots & C[a_n^{(p)},a_n] 
   & & C[a_n^{(p)},a_1^{(p)}] & \Cdots & C[a_n^{(p)},a_n^{(p)}]
\end{bNiceMatrix}
\end{Verbatim}

\[\begin{bNiceMatrix}
C[a_1,a_1] & \Cdots & C[a_1,a_n] & \hspace*{20mm} & C[a_1,a_1^{(p)}] & \Cdots & C[a_1,a_n^{(p)}] \\
\Vdots & \Ddots & \Vdots & \Hdotsfor{1} &  \Vdots & \Ddots & \Vdots \\ 
C[a_n,a_1] & \Cdots & C[a_n,a_n] & & C[a_n,a_1^{(p)}] & \Cdots & C[a_n,a_n^{(p)}] \\
\rule{0pt}{15mm}\NotEmpty & \Vdotsfor{1} & & \Ddots & & \Vdotsfor{1} \\
C[a_1^{(p)},a_1] & \Cdots & C[a_1^{(p)},a_n] & & C[a_1^{(p)},a_1^{(p)}] & \Cdots & C[a_1^{(p)},a_n^{(p)}] \\
\Vdots & \Ddots & \Vdots & \Hdotsfor{1} & \Vdots & \Ddots & \Vdots \\ 
C[a_n^{(p)},a_1] & \Cdots & C[a_n^{(p)},a_n] & & C[a_n^{(p)},a_1^{(p)}] & \Cdots & C[a_n^{(p)},a_n^{(p)}]
\end{bNiceMatrix}\]




%\subsection{How to generate the continuous dotted lines transparently}
\subsection{amsmath 宏包代码（虚线）的透明迁移（generate the continuous dotted lines transparently）}

%Imagine you have a document with a great number of mathematical matrices with
%ellipsis. You may wish to use the dotted lines of \pkg{nicematrix} without
%having to modify the code of each matrix. It's possible with the keys.
%|renew-dots| and |renew-matrix|.\footnote{The options |renew-dots|,
%|renew-matrix| can be fixed with the command
%|\NiceMatrixOptions| like the other options. However, they can also be fixed
%as options of the command |\usepackage|. There is also a key |transparent|
%which is an alias for the conjonction of |renew-dots| and |renew-matrix| but it
%must be considered as obsolete.}

假设您之前已经用 \pkg{amsmath} 宏包的 |{pmatrix}| 环境生成了一个包含大量带有数学省略号（ $\ldots$ ）矩阵的文档，
如果希望使用 \pkg{nicematrix} 风格的虚线，而又不愿修改每个矩阵的代码，
 |renew-dots| 和 |renew-matrix| 选项正好可以派上用场。\footnote{|renew-matrix| 和 |renew-matrix| 可以通过 |\textbackslash NiceMatrixOptions| 设置，也可以在载入宏包时使用 |transparent| 选项，即使用命令  |\textbackslash usepackage[transparent]{nicematrix}| 载入宏包来同时启用 |renew-matrix| 和 |renew-matrix| 选项。不建议使用第 2 种方法。}

\smallskip

\begin{itemize}
%\item The option |renew-dots|\par\nobreak
\item |renew-dots| 选项\par\nobreak

%With this option, the commands |\ldots|, |\cdots|, |\vdots|, |\ddots|,
%|\iddots|\footnotemark[\thefniddots] and |\hdotsfor| are redefined within the
%environments provided by \pkg{nicematrix} and behave like |\Ldots|, |\Cdots|,
%|\Vdots|, |\Ddots|, |\Iddots| and |\Hdotsfor|; the command |\dots|
%(``automatic dots'' of |amsmath|) is also redefined to behave like |\Ldots|. 
当使用这个选项时，\pkg{nicematrix} 重定义了 |\ldots|、|\cdots|、|\vdots|、|\ddots|、|\iddots| 以及 |\hdotsfor| 命令，使它们分别与 |\Ldots|、|\Cdots|、|\Vdots|、|\Ddots|、|\Iddots| 和 |\Hdotsfor| 命令的输出效果相同。
此外， \pkg{amsmath} 宏包中的 |\dots| 命令被重定义为 |\Ldots|。

%\item The option |renew-matrix|\par\nobreak 
\item |renew-matrix| 选项\par\nobreak 

%With this option, the environment |{matrix}| is redefined and behave like
%|{NiceMatrix}|, and so on for the five variants.
当使用这个选项时， |{matrix}| 环境被重定义为 |{NiceMatrix}| 环境，
 |{matrix}| 环境的 5 个变体环境也分别被重定义为对应的 |Nice-| 环境。
\end{itemize}

\bigskip 
%Therefore, with the keys |renew-dots| and |renew-matrix|, a classical code
%gives directly the ouput of \pkg{nicematrix}.\par\nobreak
因此，使用 |renew-dots| 和 |renew-matrix| 选项，
可以不更改原始代码而使输出效果与 \pkg{nicematrix} 的输出效果相同。\par\nobreak

\bigskip
\begin{scope}
\NiceMatrixOptions{renew-dots,renew-matrix}
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
~emphase#\NiceMatrixOptions{renew-dots,renew-matrix}@
\begin{pmatrix}
  1      & \cdots & \cdots & 1      \\
  0      & \ddots &        & \vdots \\
  \vdots & \ddots & \ddots & \vdots \\
  0      & \cdots & 0      & 1
\end{pmatrix}
\end{BVerbatim}
$\begin{pmatrix}
1      & \cdots & \cdots & 1      \\
0      & \ddots &        & \vdots \\
\vdots & \ddots & \ddots & \vdots \\
0      & \cdots & 0      & 1
\end{pmatrix}$
\end{scope}

%\subsection{The labels of the dotted lines}
\subsection{虚线上的标签（labels of the dotted lines）}

%The commands |\Ldots|, |\Cdots|, |\Vdots|, |\Ddots|, |\Iddots| and |\Hdotsfor|
%(and the command |\line| in the |\CodeAfter| which is described
%p.~\pageref{line-in-code-after}) accept two optional arguments specified
%by the tokens |_| and |^| for labels positionned below and above the line. The
%arguments are composed in math mode with |\scriptstyle|.
|\Ldots|、|\Cdots|、|\Vdots|、|\Ddots|、|\Iddots| 和 |\Hdotsfor| 命令，
以及在 |\CodeAfter| 中使用 |\line| 命令（详见~p.~\pageref{line-in-code-after}）绘制的线条
还支持在其上方或下方增加标签（标注文字）。线条上方的标注文字以 |^{<标注文字>}| 形式给出，
线条下方的标注文字以 |_{<标注文字>}| 形式给出。标注文字默认使用数学模式下的 |\scriptstyle| 样式。

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
$\begin{bNiceMatrix}
  1 & \hspace*{1cm}            & 0 \\[8mm]
    & ~emphase#\Ddots^{n \text{ times}}@ &   \\
  0 &                          & 1 
\end{bNiceMatrix}$
\end{BVerbatim}
$\begin{bNiceMatrix}
1 & \hspace*{1cm}            & 0 \\[8mm]
 & \Ddots^{n \text{ times}} &   \\
0 &                          & 1 
\end{bNiceMatrix}$

%\subsection{Customisation of the dotted lines}
\subsection{虚线样式的配置}

\label{customisation} 
%The dotted lines drawn by |\Ldots|, |\Cdots|, |\Vdots|, |\Ddots|, |\Iddots|
%and |\Hdotsfor| (and by the command |\line| in the |\CodeAfter| which is described
%p.~\pageref{line-in-code-after}) may be customized by three options (specified
%between square brackets after the command):
|\Ldots|, |\Cdots|, |\Vdots|, |\Ddots|, |\Iddots| 和 |\Hdotsfor| 命令，
以及在 |\CodeAfter| 中使用|\line| 命令（详见~p.~\pageref{line-in-code-after}）绘制的线条
还支持在命令后的方括号内（|[ ]|）指定 3 个可选参数：

\begin{itemize}
\item |color|;
\item |shorten|;
\item |line-style|.
\end{itemize}

%These options may also be fixed with |\NiceMatrixOptions|, as options of
%|\CodeAfter| or at the level of a given environment but, in those cases, they
%must be prefixed by |xdots|, and, thus have for names:
这些选项也可以用 |\NiceMatrixOptions| 或 |\CodeAfter| 指定，但必须使用前缀 |xdots|，即：
\begin{itemize}
\item |xdots/color|;
\item |xdots/shorten|;
\item |xdots/line-style|.
\end{itemize}


%For the clarity of the explanations, we will use those names.
为防止产生歧义，下文中使用带前缀的选项名。

\bigskip
%\textbf{The option xdots/color}\par\nobreak
\textbf{xdots/color 选项}\par\nobreak

\smallskip 
%The option |xdots/color| fixes the color or the dotted line. However, one should
%remark that the dotted lines drawn in the exterior rows and columns have a
%special treatment: cf. p.~\pageref{exterior}.
用于指定虚线的颜色。需要说明的是，阵列外部的行和列中虚线的颜色有其特殊的指定方式，详见~p.~\pageref{exterior}。

\bigskip
%\textbf{The option xdots/shorten}\par\nobreak
\textbf{xdots/shorten 选项}\par\nobreak

\smallskip
%The option |xdots/shorten| fixes the margin of both extremities of the line.
%The name is derived from the options ``|shorten >|'' and ``|shorten <|'' of
%Tikz but one should notice that \pkg{nicematrix} only provides
%|xdots/shorten|. The initial value of this parameter is 0.3~em (it is
%recommanded to use a unit of length dependent of the current font).
用于指定虚线两端与其它“非空”内容的间距（空白长度）。
此处的名称 “shorten” 源于 \tikzname 宏包的``|shorten >|'' 和 ``|shorten <|''选项，
但应该注意的是，\pkg{nicematrix} 仅提供了 |xdots/shorten| 选项。
本选项的初值是 0.3~em （如需修改，建议仍设为与字号相关的相对长度）。

\FTN{即 \pkg{nicematrix} 宏包作者不建议将 |xdots/shorten| 的值设为 |pt| 、 |mm| 等刚性长度，其原因是当阵列中文字的大小改变时，虚线两端间距的长度可以自动匹配。}

\bigskip
%\textbf{The option xdots/line-style}\par\nobreak
\textbf{ xdots/line-style 选项}\par\nobreak
\smallskip
%It should be pointed that, by default, the lines drawn by Tikz with the
%parameter |dotted| are composed of square dots (and not rounded
%ones).\footnote{The first reason of this behaviour is that the \textsc{pdf}
%format includes a description for dashed lines. The lines specified with this
%descriptor are displayed very efficiently by the \textsc{pdf} readers. It's
%easy, starting from these dashed lines,
%to create a line composed by square dots whereas a line of rounded dots needs
%a specification of each dot in the \textsc{pdf} file.}

首先应指出的是，默认情况下，\tikzname 宏包使用 |dotted| 参数绘制的线条是由正方形（而不是圆形）的点组成的，
如下所示。
\footnote{ \textsc{pdf} 格式原生的虚线即是由断续的方点组成， 
\textsc{pdf} 阅读器可以非常高效地解析这种由断续方点组成的虚线。
这是因为如果用断续的方点构建虚线，只需指定几个数值参数，
而使用圆点构建线则需要在 \textsc{pdf} 文件中指定每个点的位置。
（\NFTN 关于 \textsc{pdf} 中虚线的构建方法，可参阅《PDF Reference》中的 “Line Dash Pattern” 部分。）}

\begin{BVerbatim}[baseline=c,boxwidth=9cm]
\tikz \draw [dotted] (0,0) -- (5,0) ;
\end{BVerbatim}
\tikz \draw [dotted] (0,0) -- (5,0) ;

\medskip
%In order to provide lines with rounded dots in the style of those provided by
%|\ldots| (at least with the \emph{Computer Modern} fonts), the package
%\pkg{nicematrix} embeds its own system to draw a dotted line (and this system
%uses \textsc{pgf} and not Tikz). This style is called |standard| and that's
%the initial value of the parameter |xdots/line-style|.
为了以 |\ldots| 的样式（至少使用\emph{Computer Modern}字体）绘制由圆点组成的虚线，
\pkg{nicematrix} 宏包在内部使用 \textsc{pgf} （而不是\tikzname）构建虚线。
这种样式称为  |standard| 样式，它是选项 |xdots/line-style| 的默认值。 

%However (when Tikz is loaded) it's possible to use for |xdots/line-style| any style
%provided by Tikz, that is to say any sequence of options provided by Tikz for
%the Tizk pathes (with the exception of ``|color|'', ``|shorten >|'' and
%``|shorten <|'').
但当载入 \tikzname 宏包后， |xdots/line-style| 选项的值就可以设为 \tikzname 支持的任何样式，
也就是说可以在其中使用 \tikzname 宏包绘制路径有关的任何命令（不含 ``|color|'' 、
 ``|shorten >|'' 和 ``|shorten <|''）。

\medskip
%Here is for example a tridiagonal matrix with the style |loosely dotted|:\par\nobreak
在以下的三对角矩阵示例中， |xdots/line-style| 选项的值被设为 |loosely dotted| 样式（该样式是 \tikzname 提供的虚线样式）。\par\nobreak

\bigskip
\begin{BVerbatim}[baseline=c]
$\begin{pNiceMatrix}[nullify-dots,~emphase#xdots/line-style=loosely dotted@]
  a      & b      & 0      &        & \Cdots & 0      \\ 
  b      & a      & b      & \Ddots &        & \Vdots \\
  0      & b      & a      & \Ddots &        &        \\
         & \Ddots & \Ddots & \Ddots &        & 0      \\
  \Vdots &        &        &        &        & b      \\
  0      & \Cdots &        & 0      & b      & a
\end{pNiceMatrix}$
\end{BVerbatim}


\[\begin{pNiceMatrix}[nullify-dots,xdots/line-style=loosely dotted]
a      & b      & 0      &        & \Cdots & 0      \\ 
b      & a      & b      & \Ddots &        & \Vdots \\
0      & b      & a      & \Ddots &        &        \\
      & \Ddots & \Ddots & \Ddots &        & 0      \\
\Vdots &        &        &        &        & b      \\
0      & \Cdots &        & 0      & b      & a
\end{pNiceMatrix}\]


%\subsection{The dotted lines and the rules}
\subsection{不会被框线打断的虚线（dotted lines and the rules）}

\label{dotted-and-rules}

%The dotted lines determine virtual blocks which have the same behaviour
%regarding the rules (the rules specified by the specifier \verb+|+ in the
%preamble and by the keys |hlines|, |vlines|, |hvlines| and
%|hvlines-except-corners| are not drawn within the blocks).
虚线形成了虚拟的“块”，因此虚线不会被表格的其他线条打断
（在“块”内部，环境导言区中以 \verb+|+ 形式指定的竖向框线，以及以  |hlines| 、 |vlines| 、 |hvlines| 和 |hvlines-except-corners| 等命令均不会被绘制。）。

\medskip
\begin{BVerbatim}[baseline=c,boxwidth=11cm]
$\begin{bNiceMatrix}[margin,~emphase#hvlines@]
  \Block{3-3}<\LARGE>{A} &               &   & 0      \\
                         & \hspace*{1cm} &   & \Vdots \\
                         &               &   & 0      \\
  0                      & \Cdots        & 0 & 0
\end{bNiceMatrix}$
\end{BVerbatim}
$\begin{bNiceMatrix}[margin,hvlines]
\Block{3-3}<\LARGE>{A} & & & 0 \\
& \hspace*{1cm} & & \Vdots \\
& & & 0 \\
0 & \Cdots& 0 & 0
\end{bNiceMatrix}$

\FTN{上例中，导言区中的 |hvlines| 表示绘制矩阵所有的行线和列线。在运行结果中，第 4 列和第 4 行中的虚线区域都没有绘制框线。更直观的示例见下：}

\noindent\hrulefill\colorbox{red!30}{译者增补示例\ten}\hrulefill
\bigskip\nopagebreak

\begin{BVerbatim}[baseline=c,boxwidth=11cm]
$\begin{bNiceMatrix}[margin,~emphase#hvlines@]
  \Block{2-2}<\LARGE>{A} &        &   & 0      \\
                         &        &   & \Vdots \\
                         &        &   & 0      \\
  0                      & \Cdots & 0 & 0
\end{bNiceMatrix}$
\end{BVerbatim}
$\begin{bNiceMatrix}[margin,hvlines]
\Block{2-2}<\LARGE>{A} &        &   & 0      \\
                       &        &   & \Vdots \\
                       &        &   & 0      \\
0                      & \Cdots & 0 & 0
\end{bNiceMatrix}$

\medskip
\noindent\hrulefill

%\section{The \textbackslash CodeAfter}
\section{阵列构造完成之后的代码 --- \texttt{\textbackslash}CodeAfter}

\label{code-after}
%The option |code-after| may be used to give some code that will be executed
%after the construction of the matrix.\footnote{There is also a key
%|code-before| described p.~\pageref{code-before}.}
选项 |code-after| 可以用来指定在矩阵构造之后需执行的代码。
\footnote{ |code-before| 请参见~p.~\pageref{code-before}。}

\medskip
%For the legibility of the code, an alternative syntax is provided: it's
%possible to give the instructions of the |\code-after| at the end of the
%environment, after the keyword |\CodeAfter|. Although |\CodeAfter| is a
%keyword, it takes in an optional argument (between square brackets). The keys
%accepted form a subset of the keys of the command |\WithArrowsOptions|.
为使代码更清晰易读，|nicematrix| 提供了另一种语法：在环境结尾处的 |\CodeAfter| 之后给出 |\code-after| 的指令。
尽管 |\CodeAfter| 是关键字，但它接受用方括号括起来可选参数。
可选参数是 |\WithArrowsOptions| 的子集。

\FTN{\textsf{nicematrix} 的作者 François Pantigny 还开发有一个用于在公式右侧绘制箭头的 |witharrows| 宏包，在该宏包中有 \textsf{\textbackslash WithArrowsOptions} 命令。在此处的含义暂不明。}

\medskip
%The experienced users may use, for instance, the PGF/Tikz nodes created by
%\pkg{nicematrix} in the |\CodeAfter|. These nodes are described further
%beginning on p.~\pageref{PGF-nodes}.
对有经验的用户而言，可以在 |\CodeAfter| 中对 \pkg{nicematrix} 创建的 \textsc{pgf}/\tikzname 节点进行操作（详见~p.~\pageref{PGF-nodes} ）。

\medskip
%Moreover, two special commands are available in the |\CodeAfter|: |line| and 
%|\SubMatrix|. 
此外，在 |\CodeAfter| 中还有两个特殊的命令： |line| 和 |\SubMatrix| 。 

%\subsection{The command \textbackslash line in the \textbackslash CodeAfter}
\subsection{在指定单元格之间绘制虚线 --- \texttt{\textbackslash}CodeAfter 中的 \texttt{\textbackslash}line 命令}

%The command |\line| draws directly dotted lines between nodes. It takes in two
%arguments for the two cells to link, both of the form $i$-$j$ where is the
%number of the row and $j$ is the number of the column. It may be used, for
%example, to draw a dotted line between two adjacent
%cells. \label{line-in-code-after}
|\line| 命令用于绘制连接两个节点的虚线。
它接受 2 个表示单元格位置的参数，参数的形式均为“ $i-j$ ”，
其中是 $i$ 表示行号，$j$ 表示列号。
|\line| 命令的一个典型应用场景是在两个相邻单元之间绘制虚线。 
\label{line-in-code-after} 

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=11cm]
\NiceMatrixOptions{xdots/shorten = 0.6 em}
\begin{pNiceMatrix}
  I       & 0      & \Cdots  & 0     \\
  0       & I      & \Ddots  &\Vdots \\
  \Vdots  & \Ddots & I       & 0     \\
  0       & \Cdots & 0       & I
  ~emphase#\CodeAfter \line{2-2}{3-3}@
\end{pNiceMatrix}
\end{BVerbatim}
\begin{scope}
\NiceMatrixOptions{xdots/shorten = 0.6 em}
$\begin{pNiceMatrix}
I       & 0      & \Cdots  &0     \\
0       & I      & \Ddots  &\Vdots\\
\Vdots  &\Ddots  & I       &0     \\
0       &\Cdots  & 0       &I
\CodeAfter \line{2-2}{3-3}
\end{pNiceMatrix}$
\end{scope}

\medskip
%The options available for the customisation of the dotted lines created by
%|\Cdots|, |\Vdots|, etc. are also available for this command (cf.
%p.~\pageref{customisation}). 
关于虚线样式的自定义，请参见~p.~\pageref{customisation}。


%\subsection{The command \textbackslash SubMatrix in the \textbackslash CodeAfter}
\subsection{分块矩阵 --- \texttt{\textbackslash}CodeAfter 中的 \texttt{\textbackslash}SubMatrix 命令}

\label{sub-matrix}

%\colorbox{yellow!50}{\textbf{New 5.10}}\enskip 
%\colorbox{yellow!50}{\textbf{v5.10新增}}\enskip 
%The command |\SubMatrix| provides a way to put delimiters on a portion
%of the array considered as a submatrix. The command |\SubMatrix| takes in five
%arguments:
命令 |\SubMatrix| 可以在一个完整的母（“大”）矩阵中绘制定界符以标示子（“小”）阵矩。
命令 |\SubMatrix| 有 5 个参数，其中前 4 个是必选参数，第 5 个是可选参数。

\begin{itemize}
%\item the first argument is the left delimiter, which may be any extensible delimiter
%provided by LaTeX : |(|, |[|, |\{|, |\langle|, |\lgroup|, |\lfloor|, etc. but also
%the null delimiter |.|;
\item 第 1 个参数是子矩阵的左定界符，取值可以是\LaTeX 中的可扩展定界符，如 
|(|、|[|、|\{|、|\langle|、|\lgroup|、|\lfloor| 和 |.| 等。
%\item the second argument is the upper-left corner of the submatrix with the
%syntax $i$|-|$j$ where $i$ the number of row and $j$ the number of column;
\item 第 2 个参数是子矩阵左上角元素在母矩阵中的行列号，语法是“  $i$|-|$j$ ”，
共中 $i$ 表示行号， $i$ 表示列号。
%\item the third argument is the lower-right corner with the same syntax;
\item 第 3 个参数是子矩阵右下角元素在母矩阵中的行列号，语法同 参数 2 。
%\item the fourth argument is the right delimiter;
\item 第 4 个参数是子矩阵的右定界符，可取的值与参数 1 相同。
%\item the last argument, which is optional, is a list of key-value pairs.% pairs.\footnote{There is no optional argument between square brackets in first
% position because a square bracket just after |\SubMatrix| must be interpreted
% as the first (mandatory) argument of the command |\SubMatrix|: that bracket is
% the left delimiter of the sub-matrix to construct (eg.:
% |\SubMatrix[{2-2}{4-7}]|).} 

\item 第 5 个参数是可选参数，以 \textsl{<选项> = <值>} 的形式给出。\footnote{|\textbackslash SubMatrix| 命令后没有紧跟用方括号括起来的可选参数的原因是紧跟命令的方括号会被解析为分块（子）矩阵的左定界符，如 |\textbackslash SubMatrix[{2-2}{4-7}]|。}
\end{itemize}

%One should remark that the command |\SubMatrix| draws the delimiters after the
%construction of the array: no space is inserted by the command |\SubMatrix|
%itself. That's why, in the following example, we have used the key |margin|
%and you have added by hand some space between the third and fourth column with
%|@{\hspace{1.5em}}| in the preamble of the array.

应该注意的是，|\SubMatrix| 命令是在“母”矩阵构造完成之后才在其上绘制“子”矩阵的定界符，
也就是说，|\SubMatrix| 命令不会使母矩阵的宽度增加。
因此，在下例中使用  |margin| 使母矩阵在左右两侧各增加 5 pt 的间距（\NFTN 关于 \textsf{margin} ，请参见~p.~\pageref{key:margin}。），
并在手动在矩阵第 3 和第 4 列之间增加了 1.5em 的宽度。

\bigskip
\begin{scope}
\hfuzz=15cm
\fvset{commandchars=\~\#\+}%
\begin{BVerbatim}[boxwidth=11cm,baseline=c]
\[\begin{NiceArray}{ccc~emphase#@{\hspace{1.5em}}+c}[cell-space-limits=2pt,~emphase#margin+]
  1            & 1            & 1            & x \\
  \dfrac{1}{4} & \dfrac{1}{2} & \dfrac{1}{4} & y \\
  1            & 2            & 3            & z
  \CodeAfter
  ~emphase#\SubMatrix({1-1}{3-3})+
  ~emphase#\SubMatrix({1-4}{3-4})+
\end{NiceArray}\]
\end{BVerbatim}
\end{scope}
$\begin{NiceArray}{ccc@{\hspace{1.5em}}c}[cell-space-limits=2pt,margin]
1          & 1           & 1           & x \\
\dfrac{1}{4} & \dfrac{1}{2} & \dfrac{1}{4} & y \\
1          & 2           & 3           & z 
\CodeAfter
\SubMatrix({1-1}{3-3})
\SubMatrix({1-4}{3-4})
\end{NiceArray}$

\bigskip
%The options of the command |\SubMatrix| are as follows:
|\SubMatrix| 命令的可选参数（即第 5 个参数）可以是：

\begin{itemize}
%\item |left-xshift| and |right-shift| shift horizontally the delimiters (there
%exists also the key |xshift| which fixes both parameters);
\item |left-xshift| 和 |right-xshift|，分别表示左侧定界符和右侧定界符在水平方向上的位移量，
也可以使用 |xshift| 同时指定左右两侧定界符在水平方向上的位移量；
%\item |extra-height| adds a quantity to the total height of the delimiters
%(height |\ht| + depth |\dp|);
\item |extra-height|，表示定界符总高度（即深度与高度之和）。\NFTN 关于“盒子”深度、高度及总高度的概念，
请参见《\LaTeX 2e 完全学习手册（第2版）~p.~52。
%\item |delimiters/color| fixes the color of the delimiters (also
%available in |\NiceMatrixOptions|, in the environments with delimiters and as
%option of the keyword |\CodeAfter|);
\item |delimiters/color|，用于设置定界符的颜色（也可以使用 |\NiceMatrixOptions| 命令或  |\CodeAfter| 设定定界符的颜色）；
%\item |slim| is a boolean key: when that key is in force, the horizontal
%position of the delimiters is computed by using only the contents of the cells
%of the submatrix whereas, in the general case, the position is computed by
%taking into account the cells of the whole columns implied in the submatrix
%(see example below).
\item |slim| 该选项是一个 bool 值。当该选项生效时，仅使用子矩阵单元格的内容来计算定界符的水平位置。
当不设置 |slim| 选项时，会根据母矩阵中列的宽度确定子矩阵定界符的位置。


% \item |vlines| contents a list of numbers of vertical rules that will be drawn in
% the sub-matrix (if this key is used without value, all the vertical rules of
% the sub-matrix are drawn);
\item |vlines|，包含一个数值列表，表示需绘制的垂直框线。默认绘制所有子矩阵的垂直框线。

% \item |hlines| is similar to |vlines| but for the horizontal rules;
\item |hlines|，水平框线，取值与 |vlines| 相同。

% \item |hvlines|, which must be used without value, draws all the vertical and
% horizontal rules.
\item |hvlines|，不接受任何选项，表示绘制子矩阵内所有水平和垂直框线。

\end{itemize}
% One should remark that these keys add their rules after the construction of
% the main matrix: no space is added between the rows and the columns of the
% array for theses rules.
需要说明的是，以上选项是在母（大）矩阵构建完成之后绘制框线，因此不会使母（大）矩阵的宽度和高度增加。

%
% \bigskip 
% All these keys are also available in |\NiceMatrixOptions|, at the level of the
% environments of \pkg{nicematrix} or as option of the command |\CodeAfter| with
% the prefix |sub-matrix| which means that their names are therefore
% |sub-matrix/left-xshift|, |sub-matrix/right-xshift|, |sub-matrix/xshift|, etc.
以上选项也可以在 |\NiceMatrixOptions| 中使用，还可以在 \pkg{nicematrix} 中“母”环境的选项
和 |\CodeAfter| 命令中使用。在后 2 种情况下，应在选项名前加 |sub-matrix| 前缀，即使用 |sub-matrix/left-xshift| 、|sub-matrix/right-xshift| 和 |sub-matrix/xshift|等
作为选项名称。
% \bigskip


%\end{itemize}

%These keys are also available in |\NiceMatrixOptions|, at the level of the
%environments of \pkg{nicematrix} or as option of the command |\CodeAfter| with
%the prefix |sub-matrix| which means that their names are therefore
%|sub-matrix/left-xshift|, |sub-matrix/right-xshift|, |sub-matrix/xshift|, etc.
以上选项也可以在 |\NiceMatrixOptions| 中使用，还可以在 \pkg{nicematrix} 中“母”环境的选项
和 |\CodeAfter| 命令中使用。在后 2 种情况下，应在选项名前加 |sub-matrix| 前缀，即使用 |sub-matrix/left-xshift| 、|sub-matrix/right-xshift| 和 |sub-matrix/xshift|等
作为选项名称。

\bigskip
\begin{scope}
\hfuzz=12cm
\fvset{commandchars=\~\#\!}%
\begin{BVerbatim}[baseline=c,boxwidth=11cm]
$\begin{NiceArray}{cc@{\hspace{5mm}}l}[cell-space-limits=2pt]
    &   & \frac12           \\
    &   & \frac14           \\[1mm]
  a & b & \frac12a+\frac14b \\
  c & d & \frac12c+\frac14d \\
  \CodeAfter 
  \SubMatrix({1-3}{2-3})
  \SubMatrix({3-1}{4-2})
  \SubMatrix({3-3}{4-3})
\end{NiceArray}$
\end{BVerbatim}
\end{scope}
$\begin{NiceArray}{cc@{\hspace{5mm}}l}[cell-space-limits=2pt]
        &   & \frac12 \\
        &      & \frac14 \\[1mm]
a & b & \frac12a+\frac14b \\
c & d & \frac12c+\frac14d \\
\CodeAfter
\SubMatrix({1-3}{2-3})
\SubMatrix({3-1}{4-2})
\SubMatrix({3-3}{4-3})
\end{NiceArray}$

\medskip
%Here is the same example with the key |slim| used for one of the submatrices.
上例中使用 |slim| 选项后的代码和输出结果如下例示。


\bigskip
\begin{scope}
\hfuzz=12cm
\fvset{commandchars=\~\#\!}%
\begin{BVerbatim}[baseline=c,boxwidth=11cm]
$\begin{NiceArray}{cc@{\hspace{5mm}}l}[cell-space-limits=2pt]
    &   & \frac12           \\
    &   & \frac14           \\[1mm]
  a & b & \frac12a+\frac14b \\
  c & d & \frac12c+\frac14d \\
  \CodeAfter
  \SubMatrix({1-3}{2-3})[~emphase#slim!]
  \SubMatrix({3-1}{4-2})
  \SubMatrix({3-3}{4-3})
\end{NiceArray}$
\end{BVerbatim}
\end{scope}
$\begin{NiceArray}{cc@{\hspace{5mm}}l}[cell-space-limits=2pt]
        &   & \frac12 \\
        &      & \frac14 \\[1mm]
a & b & \frac12a+\frac14b \\
c & d & \frac12c+\frac14d \\
\CodeAfter
\SubMatrix({1-3}{2-3})[slim]
\SubMatrix({3-1}{4-2})
\SubMatrix({3-3}{4-3})
\end{NiceArray}$


\bigskip
%There is also a key |name| which gives a name to the submatrix created by
%|\SubMatrix|. That name is used to created PGF/Tikz nodes: cf
%p.~\pageref{node-sub-matrix}.
使用 |\SubMatrix| 创建的子矩阵还可以通过 |name| 选项为其命名。这个名字在 |nicematrix| 内部用于创建 \textsc{pgf}/\tikzname 节点，详见~p.~\pageref{node-sub-matrix}。

%\section{The notes in the tabulars}
\section{表格中的注释}

\label{s:notes}

%\subsection{The footnotes}
\subsection{脚注}

\smallskip
%The package \pkg{nicematrix} allows, by using \pkg{footnote} or
%\pkg{footnotehyper}, the extraction of the notes inserted by |\footnote| in
%the environments of \pkg{nicematrix} and their composition in the footpage
%with the other notes of the document.

\pkg{nicematrix} 支持在环境中使用 |\footnote| 命令创建脚注，这些脚注可以与正文的脚注统一编号并排布在页脚区域。脚注宏包可以用 \pkg{footnote} 宏包，也可以用 \pkg{footnotehyper} 宏包。

\smallskip

\smallskip
%If \pkg{nicematrix} is loaded with the option |footnote| (with
%|\usepackage[footnote]{nicematrix}| or with |\PassOptionsToPackage|), the
%package \pkg{footnote} is loaded (if it is not yet loaded) and it is used to
%extract the footnotes.
%
%\smallskip
%If \pkg{nicematrix} is loaded with the option |footnotehyper|, the package
%\pkg{footnotehyper} is loaded (if it is not yet loaded) ant it is used to
%extract footnotes.

如果用 |\usepackage[footnote]{nicematrix}| 载入 |nicematrix|，则使用 |footnote| 处理脚注；如果用 |\usepackage[footnotehyper]{nicematrix}| 命令，则使用 |footnotehyper| 处理脚注。

\smallskip
%Caution: The packages \pkg{footnote} and \pkg{footnotehyper} are incompatible.
%The package \pkg{footnotehyper} is the successor of the package \pkg{footnote}
%and should be used preferently. The package \pkg{footnote} has some drawbacks,
%in particular: it must be loaded after the package \pkg{xcolor} and it is not
%perfectly compatible with \pkg{hyperref}.

注意： \pkg{footnote} 宏包与 \pkg{footnotehyper} 宏包不兼容。 \pkg{footnote} 必须在 \pkg{xcolor} 宏包之后载入，并且与 \pkg{hyperref} 宏包存兼容性问题。总体来看， \pkg{footnotehyper} 优于  \pkg{footnote}。因此，作者建议使用 \pkg{footnotehyper} 宏包生成脚注。

%\subsection{The notes of tabular}
\subsection{表注}

%The package \pkg{nicematrix} also provides a command |\tabularnote| which gives
%the ability to specify notes that will be composed at the end of the array
%with a width of line equal to the width of the array (excepted the potential
%exterior columns). With no surprise, that command is available only in the
%environments without delimiters, that is to say |{NiceTabular}|, |{NiceArray}|
%and |{NiceMatrix}|.

\pkg{nicematrix} 提供了 |\tabularnote| 命令，用于在表格中插入注释。注释在表格之后排布，与表格之间用横线分隔。分隔横线的宽度与表格主体内容的宽度（即不含表格外部列的表格宽度）相同。注释只能在 |{NiceTabular}|、|{NiceArray}| 和 |{NiceMatrix}| 等不含定界符的环境中使用。

%In fact, this command is available only if the extension \pkg{enumitem} has
%been loaded (before or after \pkg{nicematrix}). Indeed, the notes are composed
%at the end of the array with a type of list provided by the package
%\pkg{enumitem}. 

\pkg{nicematrix} 中表格的注释依赖 \pkg{enumitem} 宏包（需手动载入，在 \pkg{nicematrix} 宏包载入之前、之后均可）。事实上，表格的注释是在表格之后以 \pkg{enumitem} 支持的列表形式排布的。

\begin{scope}
\fvset{commandchars=\~\#\!}
\begin{Verbatim}
\begin{NiceTabular}{@{}llr@{}}[first-row,code-for-first-row = \bfseries]
  \toprule
  Last name & First name & Birth day \\
  \midrule
  Achard\tabularnote{~emphase#Achard is an old family of the Poitou.!} 
  & Jacques & 5 juin 1962 \\
  Lefebvre\tabularnote{~emphase#The name Lefebvre is an alteration of the name Lefebure.!} 
  & Mathilde & 23 mai 1988 \\
  Vanesse & Stephany & 30 octobre 1994 \\
  Dupont & Chantal & 15 janvier 1998 \\
  \bottomrule
\end{NiceTabular}
\end{Verbatim}
\end{scope}

\begin{center}
\begin{NiceTabular}{@{}llr@{}}[first-row,code-for-first-row = \bfseries]
\toprule
Last name & First name & Birth day \\
\midrule
Achard\tabularnote{Achard is an old family of the Poitou.} 
& Jacques & June 5, 2005 \\
Lefebvre\tabularnote{The name Lefebvre is an alteration of the name Lefebure.} 
& Mathilde & January 23, 1975 \\
Vanesse & Stephany & October 30, 1994 \\
Dupont & Chantal & January 15, 1998 \\
\bottomrule
\end{NiceTabular}
\end{center}


\bigskip
\begin{itemize}
%\item If you have several successive commands |\tabularnote{...}| \emph{with no
%space at all between them}, the labels of the corresponding notes are composed
%together, separated by commas (this is similar to the option |multiple| of
%\pkg{footmisc} for the footnotes).
\item 如果源文件中有连续多个 |\tabularnote{...}| 命令，且它们之间没有空格，则表格中这些脚注的标签（编号）之间会用逗号分隔，如“a,b”，与使用 \pkg{footmisc} 宏包开启 |multiple| 选项的效果相同。

%\item If a command |\tabularnote{...}| is exactly at the end of a cell (with
%no space at all after), the label of the note is composed in an overlapping
%position (towards the right). This structure may provide a better alignment of
%the cells of a given column.
\item  当 |\tabularnote{...}| 位于单元格内容的最末位置，且其后没有多余的空格时，注释的标签（编号）会重叠排布（overlapping），以使单元格内容与同列其他单元格更好地对齐。

%\item If the key |notes/para| is used, the notes are composed at the end of
%the array in a single paragraph (as with the key |para| of \pkg{threeparttable}).
\item 如果使用 |notes/para| 选项，所有注释会在表格之后排成一段，即多个注释之间不会分段，与使用 \pkg{threeparttable} 宏包并启用 |para| 选项的效果相同。

%\item There is a key |tabularnote| which provides a way to insert some text in
%the zone of the notes before the numbered tabular notes.
\item |tabularnote| 用于在所有注释之前插入内容。

%\item If the package \pkg{booktabs} has been loaded (before or after
%\pkg{nicematrix}), the key |notes/bottomrule| draws a |\bottomrule| of
%\pkg{booktabs} \emph{after} the notes. 
\item 如果载入了 \pkg{booktabs} 宏包（在 \pkg{nicematrix} 宏包载入之前、之后均可）， |notes/bottomrule| 选项可以在表下的\emph{所有注释之后}绘制一条三线表样式的底线（ |\bottomrule| ）。

%\item The command |\tabularnote| may be used \emph{before}
%the environment of \pkg{nicematrix}. Thus, it's possible to use it on the
%title inserted by |\caption| in an environment |{table}| of LaTeX.
\item  |\tabularnote| 命令可以在 \pkg{nicematrix} 的环境前使用。这个特性可以用于在 |{table}| 环境的标题（由 |\caption| 命令生成）中插入脚注。

%\item It's possible to create a reference to a tabular note created by |\tabularnote|
%(with the usual command |\label| used after the |\tabularnote|).
\item 当需要引用表格的注释时，可以在 |\tabularnote| 命令之后使用 |\label| 命令。
\end{itemize}
%
%For an illustration of some of those remarks, see table
%\ref{t:tabularnote}, p.~\pageref{t:tabularnote}. This table has been composed
%with the following code.
表格注释的示例见下。

\begin{center}
\fvset{commandchars=\~\#\!}
\begin{Verbatim}[formatcom=\small\color{gray}]
\begin{table}
  \setlength{\belowcaptionskip}{1ex}
  \centering
  \caption{表格注释示例~emphase#\tabularnote{可以在表格标题中使用注释。}!}
  \label{t:tabularnote}
    \begin{NiceTabular}{@{}llc@{}
    [~emphase#notes/bottomrule, tabularnote = 这是注释之前的内容。!]
      \toprule
      Last name & First name & Length of life \\
      \midrule
      Churchill & Wiston &  91\\
      Nightingale~emphase#\tabularnote{注意本条注释与后一条注释在表格中标签（编号）的排布方式。}\tabularnote{注意本条注释与前一条注释在表格中标签（编号）的排布方式}!
      & Florence & 90 \\
      Schoelcher & Victor & 89~emphase#\tabularnote{表格注释的标签（编号）重叠排布（与同列其他单元格对齐良好）。}!\\
      Touchet & Marie & 89 \\
      Wallis & John & 87 \\
      \bottomrule
    \end{NiceTabular}
\end{table}
\end{Verbatim}
\end{center}


\begin{table}[htbp]
\setlength{\belowcaptionskip}{1ex}
\centering
\caption[表格中的注释示例]{表格中的注释示例\tabularnote{可以在表格标题中使用注释。}}
\label{zm:表格注释示例}
\label{t:tabularnote}
\begin{NiceTabular}{@{}llc@{}}[notes/bottomrule, 
  tabularnote = 这是注释之前的内容。] 
\toprule
Last name & First name & Length of life \\
\midrule
Churchill & Wiston &  91\\
Nightingale\tabularnote{注意本条注释与后一条注释在表格中标签（编号）的排布方式。}\tabularnote{注意本条注释与前一条注释在表格中标签（编号）的排布方式。} 
& Florence & 90 \\
Schoelcher & Victor & 89\tabularnote{表格注释的标签（编号）重叠排布（与同列其他单元格对齐良好）。}\\
Touchet & Marie & 89 \\
Wallis & John & 87 \\
\bottomrule
\end{NiceTabular}
\end{table}

\FTN{表~\ref{zm:表格注释示例} 的主体内容来自 |nicematrix| 宏包手册，为便于说明表格注释的各种应用场景，将表格标题和注释部分改为了中文。}


%\subsection{Customisation of the tabular notes}
\subsection{自定义表格注释的样式}


%The tabular notes can be customized with a set of keys available in
%|\NiceMatrixOptions|. The name of these keys is prefixed by |notes|.
表格注释的样式可以 |\NiceMatrixOptions| 中以“| <选项> = <值>|”的形式自定义。所有选项均以 |notes| 作为前缀。具体可用的 |选项| 如下：
\begin{itemize}
\item |notes/para| 
\item |notes/bottomrule| 
\item |notes/style| 
\item |notes/label-in-tabular| 
\item |notes/label-in-list| 
\item |notes/enumitem-keys| 
\item |notes/enumitem-keys-para| 
\item |notes/code-before|
\end{itemize}
%For sake of commodity, it is also possible to set these keys in
%|\NiceMatrixOptions| via a key |notes| which takes in as value a list of 
%pairs \textsl{key=value} where the name of the keys need no longer be
%prefixed by |notes|:

还可以在 |\NiceMatrixOptions| 中使用 |notes| 设置表格注释的样式，此时选项名前无需使用前缀 |notes| 。如下所示：

\begin{center}
\begin{BVerbatim}[formatcom = \small \color{gray}]
\NiceMatrixOptions
 {
   notes = 
    {
      bottomrule ,
      style = ... ,
      label-in-tabular = ... ,
      enumitem-keys = 
       {
         labelsep = ... ,
         align = ... ,
         ...
       }
    }
 }
\end{BVerbatim}
\end{center}


\bigskip
%We detail these keys.
表格注释各个选项的含义如下：

\begin{itemize}[itemsep=\medskipamount]
%\item The key |notes/para| requires the composition of the notes (at the end of
%the tabular) in a single paragraph.
\item |notes/para| 表示表格后注释内容之间不分段，所有注释排成一段。

%Initial value: |false|
初值： |false|

%That key is also available within a given environment.
此选项也可用于给定的环境中。

%\item The key |notes/bottomrule| adds a |\bottomrule| of \pkg{booktabs}
%\emph{after} the notes. Of course, that rule is drawn only if there is really
%notes in the tabular. The package \pkg{booktabs} must have been loaded (before
%or after the package \pkg{nicematrix}). If it is not, an error is raised.
\item |notes/bottomrule| 在表下的\emph{所有注释之后}绘制一条三线表样式的底线（ |\bottomrule| ）。如启用此选项，必须手动载入三线表宏包 \pkg{booktabs} （在 \pkg{nicematrix} 宏包载入之前、之后均可），否则会报错。

%Initial value: |false|
初值： |false|

%That key is also available within a given environment.
此选项也可用于给定的环境中。

%\item The key |notes/style| is a command whose argument is specified by |#1|
%and which gives the style of numerotation of the notes. That style will be
%used by |\ref| when referencing a tabular note marked with a command |\label|.
%The labels formatted by that style are used, separated by commas, when the user
%puts several consecutive commands |\tabularnote|. The marker |#1| is meant to
%be the name of a LaTeX counter.
\item  |notes/style| 用于指定表格注释的标签（编号）在引用处的样式。如需引用表格注释，应首先在表格注释处用 |\label| 命令添加标签，而后在需引用的位置使用 |\ref| 命令。多个样式命令之间用逗号“,”分隔。 可以接受参数 “|#1|” ，表示表格注释编号计数器。


%Initial value: |\textit{\alph{#1}}|
初值：|\textit{\alph{#1}}| （\NFTN 即表格注释默认以小写英文字母顺序编号。）

%Another possible value should be a mere |\arabic{#1}|
例：可设为 |\arabic{#1}|  （\NFTN 此命令将表格注释编号改用阿拉伯数字顺序编号。）

%\item The key |notes/label-in-tabular| is a command whose argument is
%specified by |#1| which is used when formatting the label of a note in the
%tabular. Internally, this number of note has already been formatted by
%|notes/style| before sent to that command.

\item |notes/label-in-tabular| 用于指定表格中注释标签（编号）的样式。可以接受参数 “|#1|” ，这里的 “|#1|” 是 |notes/style| 里指定样式的结果，而不是 |notes/style| 里的 “|#1|” 。

%Initial value: |\textsuperscript{#1}|
初值：|\textsuperscript{#1}|

%In French, it's a tradition of putting a small space before the label of note.
%That tuning could be acheived by the following code:
在法语中，习惯上在表格注释的标签（编号）与表格注释的主体内容之间增加一个空格，可以通过如下代码实现：
%
\begin{Verbatim}
\NiceMatrixOptions{notes/label-in-tabular = \,\textsuperscript{~#1}}
\end{Verbatim}


%\item The key |notes/label-in-list| is a command whose argument is specified
%by |#1| which is used when formatting the label in the list of notes at the
%end of the tabular. Internally, this number of note has already been formatted by
%|notes/style| before sent to that command.
\item |notes/label-in-list| 用于指定表格后注释标签（编号）的样式。可以接受参数 “|#1|” ，这里的 “|#1|” 是 |notes/style| 里指定样式的结果，而不是 |notes/style| 里的 “|#1|” 。

%Initial value: |\textsuperscript{#1}|
初值：|\textsuperscript{#1}|

%In French, the labels of notes are not composed in upper position when
%composing the notes. Such behaviour could be acheived by:
在法语中，表格后注释里标签（编号）通常不采用上标的形式，可以通过如下代码实现：
\begin{Verbatim}
\NiceMatrixOptions{notes/label-in-list = ~#1.\nobreak\hspace{0.25em}}
\end{Verbatim}
%The command |\nobreak| is for the event that the option |para| is used.
上述代码中使用  |\nobreak| 主要是为了防止启用 |para| 选项（即所有注释成一段排布）后，注释的标签与其后的空白被分行排布。


%\item The notes are composed at the end of the tabular by using internally a
%style of list of \pkg{enumitem}.
\item 表格后注释的排布使用 \pkg{enumitem} 宏包提供的列表实现。

%The key |notes/enumitem-keys| specifies a list of pairs 
%\textsl{key=value} (following the specifications of \pkg{enumitem}) to
%customize that type of list.
 |notes/enumitem-keys| 接受\textsl{<选项> = <值>}的形式的参数，用于指定列表的样式。具体设置方法参见 \pkg{enumitem} 宏包帮助文档。

%Initial value:\quad |noitemsep , leftmargin = * , align = left , labelsep = 0pt|
初值：\quad |noitemsep , leftmargin = * , align = left , labelsep = 0pt|

%This initial value contains the specification |align = left| which requires a
%composition of the label leftwards in the box affected to that label.
%With that tuning, the notes are composed flush left, which is pleasant when
%composing tabulars in the spirit of \pkg{booktabs} (see for example the 
%table \ref{t:tabularnote}, p.~\pageref{t:tabularnote}).
默认 |notes/enumitem-keys| 的排版效果见表 \ref{t:tabularnote}（~p.~\pageref{t:tabularnote}）。


%\item The key |notes/enumitem-keys-para| is similar to the previous one but
%corresponds to the type of list used when the option |para| is in force. Of
%course, when the option |para| is used, a list of type |inline| (as called by
%\pkg{enumitem}) is used and the pairs \textsl{key=value} should correspond to
%such a list of type |inline|. 
\item  |notes/enumitem-keys-para| 接受\textsl{<选项> = <值>}的形式的参数，用于指定表后注释不分段排布（即启用 |para| 选项）时列表的样式。具体可设置的 |<选项>| 参见 |enumitem| 宏包帮助文档。

%Initial value:\quad |afterlabel = \nobreak, itemjoin = \quad|
初值：\quad |afterlabel = \nobreak, itemjoin = \quad|


%\item The key |notes/code-before| is a token list inserted by \pkg{nicematrix}
%just before the composition of the notes at the end of the tabular.
\item |notes/code-before| 在表后的表格注释排布前执行的代码。

%Initial value: \textsl{empty}
初值：\textsl{empty}

%For example, if one wishes to compose all the notes in gray and |\footnotesize|,
%he should use that key:
例，如需将所有表格注释的颜色设为灰色，字号设为 |\footnotesize|，可使用如下代码：
\begin{Verbatim}
\NiceMatrixOptions{notes/code-before = \footnotesize \color{gray}}
\end{Verbatim}
%It's also possible to add |\raggedright| or |\RaggedRight| in that key (|\RaggedRight|
%is a command of \pkg{ragged2e}).
在 |notes/code-before| 中也可以指定 |\raggedright| 、 |\RaggedRight| 和 |\RaggedRight|等格式（|\RaggedRight| 命令需要手动载入 \pkg{ragged2e} 宏包）。
\end{itemize}



\bigskip
%For an example of customisation of the tabular notes, see p.~\pageref{ex:notes}.
关于自定义表格注释样式的更多示例见~p.~\pageref{ex:notes}。

%\subsection{Use of \{NiceTabular\} with threeparttable}
\subsection{在三分表宏包 threeparttable 中使用 NiceTabular 环境}


%If you wish to use the environment |{NiceTabular}| or |{NiceTabular*}| in an
%environment |{threeparttable}| of the eponymous package, you have to patch the
%environment |{threeparttable}| with the following code (with a version of
%LaTeX at least 2020/10/01).
如果希望在 \pkg{threeparttable} 宏包提供的三分表环境 |threeparttable| 中使用 |{NiceTabular}| 或 |{NiceTabular*}| 环境，需要使用如下代码为 \pkg{threeparttable} 宏包打补丁（\LaTeX 版本应不低于 2020/10/01）。
\begin{Verbatim}[commandchars=\~\#\!]
\makeatletter
  \AddToHook{env/threeparttable/begin}
  {\TPT@hookin{NiceTabular}\TPT@hookin{NiceTabular*}}
\makeatother
\end{Verbatim}


%\section{Other features}
\section{其他特性}

%\subsection{Use of the column type S of siunitx}
\subsection{使用 siunitx 宏包的 S 型列}

%If the package \pkg{siunitx} is loaded (before or after \pkg{nicematrix}),
%it's possible to use the |S| column type of \pkg{siunitx} in the environments
%of \pkg{nicematrix}. The implementation doesn't use explicitly any private
%macro of \pkg{siunitx}. 
如果载入了 \pkg{siunitx} 宏包（在 \pkg{nicematrix} 宏包载入之前、之后均可），
在 \pkg{nicematrix} 的环境中也可以使用 \pkg{siunitx} 宏包的 |S| 型列。
 \pkg{nicematrix} 中 |S| 型列的实现没有使用任何 \pkg{siunitx} 宏包的私有宏。


\medskip
\begin{BVerbatim}[baseline = c, boxwidth = 10.3cm]
$\begin{pNiceArray}{~emphase#S@cWc{1cm}c}[nullify-dots,first-row]
  {C_1} & \Cdots &        & C_n    \\
  2.3   & 0      & \Cdots & 0      \\
  12.4  & \Vdots &        & \Vdots \\
  1.45 \\
  7.2   & 0      & \Cdots & 0 
\end{pNiceArray}$
\end{BVerbatim}
$\begin{pNiceArray}{ScWc{1cm}c}[nullify-dots,first-row]
{C_1} & \Cdots &  & C_n \\
2.3  & 0 & \Cdots & 0 \\
12.4 & \Vdots & & \Vdots \\
1.45 \\
7.2  & 0 & \Cdots & 0 
\end{pNiceArray}$

\medskip
%On the other hand, the |d| columns of the package \pkg{dcolumn} are not
%supported by \pkg{nicematrix}.
需要说明的是， \pkg{nicematrix} 不支持 \pkg{dcolumn} 宏包中的 |d| 型列。


%\subsection{Alignment option in \{NiceMatrix\}}
\subsection{矩阵环境中的对齐方式}

\label{key-R}

%The environments without preamble (|{NiceMatrix}|, |{pNiceMatrix}|,
%|{bNiceMatrix}|, etc.) provide two options |l| and |r| which generate all the
%columns aligned leftwards (or rightwards).
对于没有导言的环境，如 |{NiceMatrix}| 、 |{pNiceMatrix}| 和 |{bNiceMatrix}| 等，可以使用 |l| 或 |r| 选项使矩阵中的所有内容左对齐或右对齐（\NFTN 默认居中对齐，这也是 \pkg{amsmath} 宏包中默认的对齐方式）。

\medskip
\begin{BVerbatim}[baseline=c,boxwidth=10cm]
$\begin{bNiceMatrix}[r]
  \cos x & - \sin x \\
  \sin x &   \cos x 
\end{bNiceMatrix}$
\end{BVerbatim}
$\begin{bNiceMatrix}[r]
\cos x & - \sin x \\
\sin x & \cos x 
\end{bNiceMatrix}$


%\subsection{The command \textbackslash rotate}
\subsection{旋转阵列内容（\texttt{\textbackslash}rotate 命令）}

%The package \pkg{nicematrix} provides a command |\rotate|. When used in the
%beginning of a cell, this command composes the contents of the cell after a
%rotation of 90° in the direct sens.
 \pkg{nicematrix} 提供了 |\rotate| 命令用于旋转内容。
 当该命令在单元格内容之前时，可以使单元格内容逆时针旋转90°。

%In the following command, we use that command in the |code-for-first-row|.
下例是在 |code-for-first-row| 中使用 |\rotate| 命令，
使表格上方的外部行顺时针旋转90°。

\bigskip

\begin{BVerbatim}[baseline=c,boxwidth=11cm]
\NiceMatrixOptions%
  {code-for-first-row=\scriptstyle~emphase#\rotate@\text{image of },
   code-for-last-col = \scriptstyle }
$A = \begin{pNiceMatrix}[first-row,last-col=4]
  e_1 & e_2 & e_3       \\
  1   & 2   & 3   & e_1 \\
  4   & 5   & 6   & e_2 \\
  7   & 8   & 9   & e_3 
\end{pNiceMatrix}$
\end{BVerbatim}
\begin{varwidth}{10cm}
\NiceMatrixOptions%
{code-for-first-row = \scriptstyle\rotate \text{image of },
code-for-last-col = \scriptstyle }
$ A = \begin{pNiceMatrix}[first-row,last-col=4]
e_1 & e_2 & e_3 \\
1   & 2   & 3  & e_1 \\
4   & 5   & 6  & e_2 \\
7   & 8   & 9  & e_3 
\end{pNiceMatrix}$
\end{varwidth}

\bigskip
%If the command |\rotate| is used in the ``last row'' (exterior to the matrix),
%the corresponding elements are aligned upwards as shown below.
当在阵列下方的外部行 |code-for-last-row| 中使用 |\rotate| 命令时，
被旋转内容自动靠上对齐，如下所示。

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=11cm]
\NiceMatrixOptions%
  {code-for-last-row = \scriptstyle ~emphase#\rotate@ ,
   code-for-last-col = \scriptstyle }
$A = \begin{pNiceMatrix}[last-row=4,last-col=4]
  1   & 2   & 3   & e_1 \\
  4   & 5   & 6   & e_2 \\
  7   & 8   & 9   & e_3 \\
  \text{image of } e_1 & e_2 & e_3
\end{pNiceMatrix}$
\end{BVerbatim}
\begin{varwidth}{10cm}
\NiceMatrixOptions%
{code-for-last-row = \scriptstyle\rotate ,
 code-for-last-col = \scriptstyle }%
$A = \begin{pNiceMatrix}[last-row=4,last-col=4]
1   & 2   & 3  & e_1 \\
4   & 5   & 6  & e_2 \\
7   & 8   & 9  & e_3 \\
\text{image of } e_1 & e_2 & e_3 
\end{pNiceMatrix}$
\end{varwidth}



%\subsection{The option small}
\subsection{“行内”阵列（small 选项）}

\label{small}

%With the option |small|, the environments of the package \pkg{nicematrix}
%are composed in a way similar to the environment |{smallmatrix}| of the
%package \pkg{amsmath} (and the environments |{psmallmatrix}|,
%|{bsmallmatrix}|, etc. of the package \pkg{mathtools}).
当使用 |small| 选项时， \pkg{nicematrix} 的环境会缩小排布（“行内”效果），
效果类似于 \pkg{amsmath} 宏包中的 |{smallmatrix}| 环境和 \pkg{mathtools} 宏包中的 |{psmallmatrix}|、|{bsmallmatrix}| 等环境。

\bigskip
\begin{Verbatim}
$\begin{bNiceArray}{cccc|c}[~emphase#small@, 
                           last-col, 
                           code-for-last-col = \scriptscriptstyle, 
                           columns-width = 3mm ] 
1 & -2 & 3 & 4 & 5 \\
0 & 3  & 2 & 1 & 2 & L_2 \gets 2 L_1 - L_2 \\
0 & 1  & 1 & 2 & 3 & L_3 \gets L_1 + L_3 
\end{bNiceArray}$
\end{Verbatim}
%
\[\begin{bNiceArray}{cccc|c}[small, last-col, 
                    code-for-last-col = \scriptscriptstyle, 
                    columns-width=3mm]
1 & -2 & 3 & 4 & 5 \\
0 & 3  & 2 & 1 & 2 & L_2 \gets 2 L_1 - L_2 \\
0 & 1  & 1 & 2 & 3 & L_3 \gets L_1 + L_3 
\end{bNiceArray}\]



\bigskip
%One should note that the environment |{NiceMatrix}| with the option |small| is
%not composed \emph{exactly} as the environment |{smallmatrix}|. Indeed, all
%the environments of \pkg{nicematrix} are constructed upon |{array}| (of the
%package \pkg{array}) whereas the environment |{smallmatrix}| is constructed
%directly with an |\halign| of TeX.
应注意的是，即便开启 |small| 选项， |nicematrix| 宏包的环境也与 |{smallmatrix}|的输出效果不完全相同。
事实上， \pkg{nicematrix} 宏包的所有环境均基于 |array| 构建，
而 |{smallmatrix}| 则直接使用 \TeX 原生命令 |\halign| 构建。

\medskip
%In fact, the option |small| corresponds to the following tuning:
在 |nicematrix| 宏包内部， |small| 选项对应的样式如下：
\begin{itemize}
%\item the cells of the array are composed with \verb|\scriptstyle|; 
\item 单元格内容的样式是 \verb|\scriptstyle|；
%\item \verb|\arraystretch| is set to $0.47$; 
\item 行距系数 \verb|\arraystretch| 设置为  $0.47$ （\NFTN 默认值为 $1$ ）；
\item 列间间 \verb|\arraycolsep| $1.45$~pt（\NFTN 默认值为 $5$~pt ）
%\item the characteristics of the dotted lines are also modified.
\item 虚线的样式也被修改。
\end{itemize}

\subsection{行（列）编号计数器（iRow 和 jCol）}

%In the cells of the array, it's possible to use the LaTeX counters |iRow| and
%|jCol| which represent the number of the current row and the number of the
%current column\footnote{We recall that the exterior ``first row'' (if it
%exists) has the number~$0$ and that the exterior ``first column'' (if it
%exists) has also the number~$0$.}. Of course, the user must not change the
%value of these counters which are used internally by \pkg{nicematrix}.
在 \pkg{array} 宏包中，计数器 |iRow| 和 |jCol| 分别表示当前行和当前列的编号\footnote{阵列上方的外部行（如有）的编号是 $0$ ，阵列左侧的外部列（如有）的编号也是 $0$。}。
在 \pkg{nicematrix} 中， |iRow| 和 |jCol| 也分别表示当前行和当前列的编号，但用户不能手动改变这两个计数器的值。

%In the |code-before| (cf. p. \pageref{code-before}) and in the |\CodeAfter|
%(cf. p. \pageref{code-after}), |iRow| represents the total number of rows
%(excepted the potential exterior rows) and |jCol| represents the total number
%of columns (excepted the potential exterior columns).
在 |code-before| （见~p.~\pageref{code-before}）和 |\CodeAfter|
（~p.~\pageref{code-after}）中， |iRow| 和 |jCol| 分别表示阵列的总行数和总列数（不含阵列外部的行和列）。


\medskip
\begin{BVerbatim}[baseline=c,boxwidth=10.6cm]
$\begin{pNiceMatrix}% don't forget the %
   [first-row,
    first-col,
    code-for-first-row = \mathbf{~emphase#\alph{jCol}@} ,
    code-for-first-col = \mathbf{~emphase#\arabic{iRow}@} ]
&   &    &    &   \\
& 1 & 2  & 3  & 4 \\
& 5 & 6  & 7  & 8 \\
& 9 & 10 & 11 & 12
\end{pNiceMatrix}$
\end{BVerbatim}
$\begin{pNiceMatrix}[first-row,
                  first-col,
                  code-for-first-row = \mathbf{\alph{jCol}} ,
                  code-for-first-col = \mathbf{\arabic{iRow}} ]
&   &    &    &   \\
& 1 & 2  & 3  & 4 \\
& 5 & 6  & 7  & 8 \\
& 9 & 10 & 11 & 12
\end{pNiceMatrix}$

\medskip
%If LaTeX counters called |iRow| and |jCol| are defined in the document by
%packages other than \pkg{nicematrix} (or by the final user), they are shadowed
%in the environments of \pkg{nicematrix}.
如果计数器 |iRow| 和（或） |jCol| 已经被其他宏包或用户定义，在 \pkg{nicematrix} 的环境中会恢复它们的值，即可以正常使用这两个计数器。

\bigskip
%The package \pkg{nicematrix} also provides commands in order to compose
%automatically matrices from a general pattern. These commands are
%|\AutoNiceMatrix|, |\pAutoNiceMatrix|, |\bAutoNiceMatrix|, |\vAutoNiceMatrix|,
%|\VAutoNiceMatrix| and |\BAutoNiceMatrix|.
\pkg{nicematrix} 还提供了自动生成矩阵的通用方法。具体办法是使用行（列）编号计数器（ |iRow| 、 |jCol| ）和自动生成矩阵的专用命令 |\AutoNiceMatrix|、|\pAutoNiceMatrix|、 |\bAutoNiceMatrix|、 |\vAutoNiceMatrix|、
|\VAutoNiceMatrix| 以及 |\BAutoNiceMatrix|。

%These commands take in two mandatory arguments. The first is the format of the
%matrix, with the syntax $n$-$p$ where $n$ is the number of rows and $p$ the
%number of columns. The second argument is the pattern (it's a list of tokens
%which are inserted in each cell of the constructed matrix, excepted in the
%cells of the potential exterior rows and columns).
上述命令都带有 2 个必选参数，
第 1 个参数的形式是“ $n$-$p$ ”， $n$ 表示矩阵的行数， $p$ 表示矩阵的列数；
第 2 个参数表示矩阵的元素（不含矩阵外部的行和列）。


\medskip
\begin{Verbatim}
$C = ~emphase#\pAutoNiceMatrix@{3-3}{C_{\arabic{iRow},\arabic{jCol}}}$
\end{Verbatim}

\[C = \pAutoNiceMatrix{3-3}{C_{\arabic{iRow},\arabic{jCol}}}\]


%\subsection{The option light-syntax}
\subsection{使阵列输入更简洁 --- light-syntax 选项}

\label{light-syntax}
%The option |light-syntax| (inpired by the package \pkg{spalign}) allows the
%user to compose the arrays with a lighter syntax, which gives a better
%legibility of the TeX source.
|light-syntax| 选项（受 \pkg{spalign} 宏包启发）可以使用户以更简洁的语法输入阵列。

%When this option is used, one should use the semicolon for the end of a row
%and spaces or tabulations to separate the columns. However, as usual in the
%TeX world, the spaces after a control sequence are discarded and the elements
%between curly braces are considered as a whole.
当使用 |light-syntax| 选项时，应在行尾使用分号，并使用空格或制表符分隔列。 需要注意的是命令后的空格将被舍弃，花括号之间的内容将视为同一个单元格的内容。

\medskip
\begin{scope}
\begin{BVerbatim}[baseline=c,boxwidth=9.5cm]
$\begin{bNiceMatrix}[~emphase#light-syntax@,first-row,first-col]
  {} a             b                 ;
  a  2\cos a       {\cos a + \cos b} ;
  b \cos a+\cos b  { 2 \cos b }
\end{bNiceMatrix}$
\end{BVerbatim}
\end{scope}
$\begin{bNiceMatrix}[light-syntax,first-row,first-col]
  {} a             b                 ;
  a  2\cos a       {\cos a + \cos b} ;
  b \cos a+\cos b  { 2 \cos b }
\end{bNiceMatrix}$
\bigskip

%It's possible to change the character used to mark the end of rows with the
%option |end-of-row|. As said before, the initial value is a semicolon.
如前所述，行之间的分隔符是分号（;）。可使用 |end-of-row| 选项更改行之间的分隔符。

\medskip
%When the option |light-syntax| is used, it is not possible to put verbatim
%material (for example with the command |\verb|) in the cells of the
%array.\footnote{The reason is that, when the option |light-syntax| is used,
%the whole content of the environment is loaded as a TeX argument to be
%analyzed. The environment doesn't behave in that case as a standard
%environment of LaTeX which only put TeX commands before and after the content.}
当开启 |light-syntax| 选项后，在单元格中不能有抄录内容，即不能使用 |\verb| 等命令\footnote{当启用 |light-syntax| 选项时，环境的内容被作为一个整体参数传入\TeX 中。在这种情况下，环境不能像\LaTeX 的标准环境那样工作，仅支持在内容之前和之后放置\TeX 命令。 }。


%\subsection{Color of the delimiters}
\subsection{阵列定界符的颜色}

%For the environements with delimiters (|{pNiceArray}|, |{pNiceMatrix}|, etc.),
%it's possible to change the color of the delimiters with the key
%|delimiters/color|.\footnote{\verb|delimiters-color| is a synonymous
%(deprecated) for |delimiters/color|.}
对带有定界符的环境，如 |{pNiceArray}| 、 |{pNiceMatrix}| 等，可以通过 |delimiters/color| 改变定界符的颜色。\footnote{也可使用 |delimiters-color| 改变定界符的颜色，但不推荐。}

\bigskip
\begin{BVerbatim}[boxwidth=12cm,baseline=c]
$\begin{bNiceMatrix}[delimiters/color=red]
1 & 2 \\
3 & 4 
\end{bNiceMatrix}$
\end{BVerbatim}
$\begin{bNiceMatrix}[delimiters/color=red]
1 & 2 \\
3 & 4 
\end{bNiceMatrix}$


%\subsection{The environment \{NiceArrayWithDelims\}}
\subsection{自定义矩阵定界符的样式 --- NiceArrayWithDelims 环境}
\label{zm:非对称定界符}

%In fact, the environment |{pNiceArray}| and its variants are based upon a
%more general environment, called |{NiceArrayWithDelims}|. The first two
%mandatory arguments of this environment are the left and right delimiters used
%in the construction of the matrix. It's possible to use
%|{NiceArrayWithDelims}| if we want to use atypical or asymetrical delimiters.
在 |nicematrix| 内部， |{pNiceArray}| 及其变体环境都是基于叫作 |{NiceArrayWithDelims}| 的通用环境。该环境的前两个必选参数是构造矩阵时使用的左定界符和右定界符。可以使用 |{NiceArrayWithDelims}| 构造非典型或非对称定界符。

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=11cm]
$\begin{~emphase#NiceArrayWithDelims@}
  {\downarrow}{\uparrow}{ccc}[margin]
  1 & 2 & 3 \\
  4 & 5 & 6 \\
  7 & 8 & 9 
\end{~emphase#NiceArrayWithDelims@}$
\end{BVerbatim}
$\begin{NiceArrayWithDelims}
  {\downarrow}{\uparrow}{ccc}[margin]
  1 & 2 & 3 \\
  4 & 5 & 6 \\
  7 & 8 & 9 
\end{NiceArrayWithDelims}$

\section{nicematrix 与 \tikzname 的协同}

\label{name}\label{PGF-nodes}

%\subsection{The nodes corresponding to the contents of the cells}
\subsection{“普通”节点 --- 单元格内容节点}
\label{zm:NormalNodes}

%The package \pkg{nicematrix} creates a PGF/Tikz node for each (non-empty) cell
%of the considered array. These nodes are used to draw the dotted lines between
%the cells of the matrix (inter alia).

|nicematrix| 为阵列的每个（非空）单元格创建一个 \textsc{pgf}/\tikzname 节点。这些节点可以用于在阵列内的单元格之间绘制虚线。


\smallskip
%\textbf{Caution} : By default, no node is created in a empty cell.
\textbf{注意}：默认情况下，在空单元格中不会创建 \textsc{pgf}/\tikzname 节点。

\smallskip
%However, it's possible to impose the creation of a node with the command |\NotEmpty|.
%\footnote{One should note that, with that command, the cell is considered as
%non-empty, which has consequencies for the continuous dotted lines (cf.
%p.~\pageref{Cdots}).} 
但是，可以使用 |\NotEmpty| 命令强制创建节点。
\footnote{应该注意的是，使用 |\textbackslash NotEmpty| 命令后，该单元格被认为是非空的，这会影响连续虚线的绘制。关于虚线的细节详见~p.~\pageref{Cdots}。}

\medskip
%The nodes of a document must have distinct names. That's why the names of the
%nodes created by \pkg{nicematrix} contains the number of the current
%environment. Indeed, the environments of \pkg{nicematrix} are numbered by a
%internal global counter. 
在一个文档中，节点的名称必须惟一，不能重复。因此，|nicematrix| 创建的节点名称都包含当前环境的编号。|nicematrix| 中的环境由内部全局计数器编号。 

\smallskip
%In the environment with the number $n$, the node of the row $i$ and
%column~$j$ has for name |nm-|$n$|-|$i$|-|$j$. 
对于编号为 $n$ 的环境，其中第 $i$ 行和第 $j$ 列的节点的名称为 |nm-|$n$|-|$i$|-|$j$。

\smallskip
%The command |\NiceMatrixLastEnv| provides the number of the last environment
%of \pkg{nicematrix} (for LaTeX, it's a ``fully expandable'' command and not a
%counter).
|\NiceMatrixLastEnv| 命令提供了 |nicematrix| 中最后一个环境的编号（在\LaTeX 中，这是“完全可扩展”命令，而不是计数器）。 

\smallskip
%However, it's advisable to use instead the key |name|. This key gives a name
%to the current environment. When the environment has a name, the nodes are
%accessible with the name ``\textsl{name}-$i$-$j$'' where \textsl{name} is the
%name given to the array and $i$ and $j$ the numbers of row and column. It's
%possible to use these nodes with \textsc{pgf} but the final user will
%probably prefer to use Tikz (which is a convenient layer upon \textsc{pgf}).
%However, one should remind that \pkg{nicematrix} doesn't load Tikz by default.
%In the following examples, we assume that Tikz has been loaded.
建议使用 |name| 选项指定当前环境的名称。当给一个环境指定特定的名称时，就可以使用 ``\textsl{name}-$i$-$j$'' 来引用环境中特定的单元格。其中\textsl{name} 是环境的名称， $i$ 和 $j$ 分别表示单元格的行号和列号。可以在 \textsc{pgf} 或基于 \textsc{pgf} 的 \tikzname 中使用这些节点编号。应该说明的是，默认情况下 |nicematrix| 不会加载 \tikzname 。
在以下示例中，我们假定已载入了 \tikzname 宏包。 
\label{zm:单元格编号}

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=11cm]
$\begin{pNiceMatrix}[name=~emphase#mymatrix@]
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9 
\end{pNiceMatrix}$
\tikz[remember picture,overlay] 
    \draw ~emphase#(mymatrix-2-2)@ circle (2mm) ; 
\end{BVerbatim}
$\begin{pNiceMatrix}[name=mymatrix]
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9 
\end{pNiceMatrix}$
\tikz[remember picture,overlay] 
    \draw (mymatrix-2-2) circle (2mm) ; 

\medskip
%Don't forget the options |remember picture| and |overlay|.
注意上例中 \tikzname 的 |remember picture| 和 |overlay|选项。
\bigskip
%In the |\CodeAfter|, the things are easier : one must refer to the nodes with
%the form $i$-$j$ (we don't have to indicate the environment which is of
%course the current environment).
在 |\CodeAfter| 中，仅用“ $i$-$j$ ”即可引用特定的单元格，如下例示。


\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=11cm]
$\begin{pNiceMatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9 
\CodeAfter
\tikz \draw ~emphase#(2-2)@ circle (2mm) ; 
\end{pNiceMatrix}$
\end{BVerbatim}
$\begin{pNiceMatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9 
\CodeAfter
\tikz \draw (2-2) circle (2mm) ; 
\end{pNiceMatrix}$


\bigskip
%In the following example, we have underlined all the nodes of the matrix (we
%explain below the technic used : cf. p. \pageref{highlight}). 
在下例中，我们对矩阵的所有节点都加了背景色（实现方法见~p.~\pageref{highlight}）。

\[\begin{pNiceMatrix}[
code-after = {\begin{tikzpicture}
                 [every node/.style = {blend mode = multiply,
                                       fill = red!15,
                                       inner sep = 0 pt }]
              \node [fit = (1-1)] {} ;
              \node [fit = (1-3)] {} ;
              \node [fit = (2-2)] {} ;
              \node [fit = (3-1)] {} ;
              \node [fit = (3-3)] {} ;
              \node [fit = (1-2)] {} ;
              \node [fit = (2-1)] {} ;
              \node [fit = (2-3)] {} ;
              \node [fit = (3-2)] {} ;
              \end{tikzpicture}}]
a & a + b & a + b + c \\
a & a     & a + b  \\
a & a     & a 
\end{pNiceMatrix}\]



%\subsection{The ``medium nodes'' and the ``large nodes''}
\subsection{“中等节点”和“大节点”（ medium nodes 和 large nodes）}
\label{zm:中等节点和大节点}


%In fact, the package \pkg{nicematrix} can create ``extra nodes'': the ``medium
%nodes'' and the ``large nodes''. The first ones 
%are created with the option |create-medium-nodes| and the second ones with the
%option |create-large-nodes|.\footnote{There is also an option
%|create-extra-nodes| which is an alias for the conjonction of
%|create-medium-nodes| and |create-large-nodes|.}
从上例的输出结果看，节点的背景色仅覆盖了单元格内容部分，总体上看还不够美观。在 |nicematrix| 中还可以绘制 “扩展节点”（extra nodes），即“中等节点”（medium
nodes）和“大节点”（large nodes）。前者用 |create-medium-nodes| 选项绘制，后者用 |create-large-nodes| 选项绘制。\footnote{还有一个选项 |create-extra-nodes|，它是 |create-medium-nodes| 与 |create-large-nodes| 的组合的别名。}

\medskip
%These nodes are not used by \pkg{nicematrix} by default, and that's why they
%are not created by default.
默认情况下，|nicematrix| 不使用这些节点，因此默认也不不创建它们。

\medskip
%The names of the ``medium nodes'' are constructed by adding the suffix
%``|-medium|'' to the names of the ``normal nodes''. In the following example,
%we have underlined the ``medium nodes''. We consider that this example is
%self-explanatory.
“中等节点”是通过在“普通节点”上添加后缀“-medium”来构造的。在以下示例中，我们对“中等节点”添加了背景色。
\[\begin{pNiceMatrix}[
create-medium-nodes,
code-after = {\begin{tikzpicture}
                 [every node/.style = {fill = red!15,
                                       blend mode = multiply,
                                       inner sep = 0pt},
                  name suffix = -medium]
              \node [fit = (1-1)] {} ;
              \node [fit = (1-2)] {} ;
              \node [fit = (1-3)] {} ;
              \node [fit = (2-1)] {} ;
              \node [fit = (2-2)] {} ;
              \node [fit = (2-3)] {} ;
              \node [fit = (3-1)] {} ;
              \node [fit = (3-2)] {} ;
              \node [fit = (3-3)] {} ;
              \end{tikzpicture}}]
a & a + b & a + b + c \\
a & a     & a + b  \\
a & a     & a 
\end{pNiceMatrix}\]


\medskip
%The names of the ``large nodes'' are constructed by adding the suffix
%``|-large|'' to the names of the ``normal nodes''. In the following example,
%we have underlined the ``large nodes''. We consider that this example is
%self-explanatory.\footnote{There is no ``large nodes'' created in the exterior
%rows and columns (for these rows and columns, cf. p.~\pageref{exterior}).}
同样，“大节点”是通过在“普通节点”上添加后缀“-large”来构造的。在以下示例中，我们对“大节点”添加了背景色。\footnote{在阵列外的行和列不会被纳入“大节点”的覆盖范围。}

\[\begin{pNiceMatrix}[
create-large-nodes,
code-after = {\begin{tikzpicture}
                 [every node/.style = {blend mode = multiply,
                                       inner sep = 0pt},
                  name suffix = -large]
              \node [fit = (1-1),fill = red!15] {} ;
              \node [fit = (1-3),fill = red!15] {} ;
              \node [fit = (2-2),fill = red!15] {} ;
              \node [fit = (3-1),fill = red!15] {} ;
              \node [fit = (3-3),fill = red!15] {} ;
              \node [fit = (1-2),fill = blue!15] {} ;
              \node [fit = (2-1),fill = blue!15] {} ;
              \node [fit = (2-3),fill = blue!15] {} ;
              \node [fit = (3-2),fill = blue!15] {} ;
              \end{tikzpicture}}]
a & a + b & a + b + c \\
a & a     & a + b  \\
a & a     & a 
\end{pNiceMatrix}\]


\medskip
%The ``large nodes'' of the first column and last column may appear too small
%for some usage. That's why it's possible to use the options |left-margin| and
%|right-margin| to add space on both sides of the array and also space in the
%``large nodes'' of the first column and last column. In the following example,
%we have used the options |left-margin| and |right-margin|.\footnote{The
%options |left-margin| and |right-margin| take dimensions as values but, if no
%value is given, the default value is used, which is |\arraycolsep| (by
%default: 5~pt). There is also an option |margin| to fix both |left-margin| and
%|right-margin| to the same value.}
在某些情况下，第一列和最后一列的“大节点”可能还不够大。
为此，可以使用 |left-margin| 和 |right-margin| 选项在阵列的两侧以及第一列和最后一列的“大节点”中添加空白。下例中，使用了 |left-margin| 和 |right-margin| 选项。\footnote{选项 |left-margin| 和 |right-margin| 的值是一个长度。如果未指定值，则使用 |\textbackslash arraycolsep| （默认值：5 pt） 作为长度。此外，还可以用 |margin| 选项将左边界和右边界同时设为相同的值。}\label{key:margin}

\[\begin{pNiceMatrix}[
create-large-nodes,left-margin,right-margin,
code-after = {\begin{tikzpicture}
                 [every node/.style = {blend mode = multiply,
                                       inner sep = 0pt},
                  name suffix = -large]
              \node [fit = (1-1),fill = red!15] {} ;
              \node [fit = (1-3),fill = red!15] {} ;
              \node [fit = (2-2),fill = red!15] {} ;
              \node [fit = (3-1),fill = red!15] {} ;
              \node [fit = (3-3),fill = red!15] {} ;
              \node [fit = (1-2),fill = blue!15] {} ;
              \node [fit = (2-1),fill = blue!15] {} ;
              \node [fit = (2-3),fill = blue!15] {} ;
              \node [fit = (3-2),fill = blue!15] {} ;
              \end{tikzpicture}}]
a & a + b & a + b + c \\
a & a     & a + b  \\
a & a     & a 
\end{pNiceMatrix}\]

\medskip
%It's also possible to add more space on both side of the array with the
%options |extra-left-margin| and |extra-right-margin|. These margins are not
%incorporated in the ``large nodes''. It's possible to fix both values with the
%option |extra-margin| and, in the following example, we use |extra-margin|
%with the value $3$~pt.
还可以使用 |extra-left-margin| 和 |extra-right-margin| 选项在阵列的两侧添加更多的空白。
这些空白不会被包含在“大节点”中。可以使用 |extra-margin| 选项同时设定上述两个值。
在下例中，|extra-margin| 的值为 $3$~pt。
\[\begin{pNiceMatrix}[
create-large-nodes,margin,extra-margin=3pt,
code-after = {\begin{tikzpicture}
                 [every node/.style = {blend mode = multiply,
                                       inner sep = 0 pt},
                  name suffix = -large]
              \node [fit = (1-1),fill = red!15] {} ;
              \node [fit = (1-3),fill = red!15] {} ;
              \node [fit = (2-2),fill = red!15] {} ;
              \node [fit = (3-1),fill = red!15] {} ;
              \node [fit = (3-3),fill = red!15] {} ;
              \node [fit = (1-2),fill = blue!15] {} ;
              \node [fit = (2-1),fill = blue!15] {} ;
              \node [fit = (2-3),fill = blue!15] {} ;
              \node [fit = (3-2),fill = blue!15] {} ;
              \end{tikzpicture}}]
a & a + b & a + b + c \\
a & a     & a + b  \\
a & a     & a 
\end{pNiceMatrix}\]



\bigskip
%\textbf{Be careful} : These nodes are reconstructed from the contents of the
%contents cells of the array. Usually, they do not correspond to the cells
%delimited by the rules (if we consider that these rules are drawn).
%\textbf{注意}：这些节点是根据数组内容单元的内容重建的。
通常，“中等节点”与“大节点”与由框线分割的单元格并不一一对应（假设框线已经被绘制）。

\bigskip
\begin{minipage}[c]{7.6cm}
%Here is an array composed with the following code:
一个带有全部框线的表格如下：

\medskip
\begin{BVerbatim}
\large
\begin{NiceTabular}{wl{2cm}ll}[hvlines]
  fraise & amande   & abricot \\
  prune  & pêche    & poire   \\[1ex]
  noix   & noisette & brugnon
\end{NiceTabular}
\end{BVerbatim}
\end{minipage}
\hspace{0.5cm}
\begin{scope}
\large
\begin{NiceTabular}[c]{wl{2cm}ll}[hvlines]
fraise & amande & abricot \\
prune & pêche & poire  \\[1ex]
noix & noisette & brugnon
\end{NiceTabular}
\end{scope}

\vspace{1cm}
\begin{minipage}[c]{7cm}
%Here, we have colored all the cells of the array with |\chessboardcolors|.
在上例的基础上，使用 |\chessboardcolors| 对单元格进行“棋盘”着色，结果如右所示。
\end{minipage}
\hspace{1.1cm}
\begin{scope}
\large
\begin{NiceTabular}[c]{wl{2cm}ll}[hvlines,code-before = \chessboardcolors{red!15}{blue!15}]
fraise & amande & abricot \\
prune & pêche & poire  \\[1ex]
noix & noisette & brugnon
\end{NiceTabular}
\end{scope}

\vspace{1cm}
\begin{minipage}[c]{7cm}
%Here are the ``large nodes'' of this array (without use of |margin|
%nor |extra-margin|).
在第 1 个表格的基础上绘制的“大节点”如右所示（没有使用 |margin|
和 |extra-margin| 选项以扩展阵列两侧的空白）。
\end{minipage}
\hspace{1.1cm}
\begin{scope}
\large
\begin{NiceTabular}[c]{wl{2cm}ll}[hvlines,
create-large-nodes,
code-after = {\begin{tikzpicture}
                 [every node/.style = {blend mode = multiply,
                                       inner sep = 0 pt},
                  name suffix = -large]
              \node [fit = (1-1),fill = red!15] {} ;
              \node [fit = (1-3),fill = red!15] {} ;
              \node [fit = (2-2),fill = red!15] {} ;
              \node [fit = (3-1),fill = red!15] {} ;
              \node [fit = (3-3),fill = red!15] {} ;
              \node [fit = (1-2),fill = blue!15] {} ;
              \node [fit = (2-1),fill = blue!15] {} ;
              \node [fit = (2-3),fill = blue!15] {} ;
              \node [fit = (3-2),fill = blue!15] {} ;
              \end{tikzpicture}}]
fraise & amande & abricot \\
prune & pêche & poire  \\[1ex]
noix & noisette & brugnon
\end{NiceTabular}
\end{scope}

%\subsection{The nodes which indicate the position of the rules}
\subsection{行列线的交点 --- i 节点}

\label{nodes-i}
%\colorbox{yellow!50}{\textbf{New 5.11}}\enskip The package \pkg{nicematrix}
%creates a PGF/Tikz node merely called $i$ (with the classical prefix) at the
%intersection of the horizontal rule of number~$i$ and the vertical rule of
%number~$j$ (more specifically the potential position of those rules because
%maybe there are not actually drawn). These nodes are available in the
%|code-before| and the |\CodeAfter|.
\colorbox{yellow!50}{\textbf{v5.11新增}} 不论行线和列线是否显式绘出，
|nicematrix| 都会在所有行线和列线的交点处创建名为 $i$ （取intersection，交点的首字母之意）的 \textsc{pgf}/\tikzname 节点。
这些节点可以在 |code-before| 和 |\CodeAfter| 中使用。

% \colorbox{yellow!50}{\textbf{New 5.13}}\enskip The last node has also an alias called
% |last|. 
\colorbox{yellow!50}{\textbf{v5.13 新增}}\enskip 阵列的最后一个 |i| 节点可以使用 |last| 直接引用。

\begin{center}
\begin{NiceTabular}{ccc}[hvlines,rules/width=1pt,rules/color=gray]
rose & tulipe & lys \\
arum & iris & violette \\
muguet & dahlia & souci 
\CodeAfter
\tiny
\begin{tikzpicture}
\foreach \i in {1,2,3,4}
 { 
   \fill [red] (\i) circle (0.5mm) ; 
   \node [red,above right] at (\i) {\i} ; 
 } 
\end{tikzpicture}
\end{NiceTabular}
\end{center}

\bigskip
%If we use Tikz (we remind that \pkg{nicematrix} does not load Tikz by default,
%by only \textsc{pgf}, which is a sub-layer of Tikz), we can access, in the
%|\CodeAfter| but also in the |code-before|) to the intersection of the horizontal
%rule~$i$ and the vertical rule~$j$ with the syntax |(|$i$\verb+-|+$j$|)|.
如果加载了 \tikzname 宏包（请注意，默认情况下 |nicematrix| 不会加载 \tikzname ，仅加载 \textsc{pgf}），那么就可以在 |\CodeAfter| 和 |code-before| 中引用 $i$ 节点。
引用 $i$ 节点的语法是 |(|$i$\verb+-|+$j$|)| ，其中 $i$ 表示行线的序号，
$j$ 表示列线的序号。 
\medskip
\begin{Verbatim}
\[\begin{NiceMatrix}[
  \CodeBefore
~emphase#  \tikz \draw [fill = red!15] (7-|4) |- (8-|5) |- (9-|5) |- (9-|6) |- cycle ; @
  \Body
    1 \\
    1 & 1 \\
    1 & 2 &  1 \\
    1 & 3 &  3 &  1 \\
    1 & 4 &  6 &  4 &  1 \\
    1 & 5 & 10 & 10 &  5 &  1 \\
    1 & 6 & 15 & 20 & 15 &  6 &  1 \\
    1 & 7 & 21 & 35 & 35 & 21 &  7 & 1 \\
    1 & 8 & 28 & 56 & 70 & 56 & 28 & 8 & 1
\end{NiceMatrix}\]
\end{Verbatim}
\[\begin{NiceMatrix}
  \CodeBefore
     \tikz \draw [fill = red!15] (7-|4) |- (8-|5) |- (9-|5) |- (9-|6) |- cycle ;
  \Body
    1 \\
    1 & 1 \\
    1 & 2 &  1 \\
    1 & 3 &  3 &  1 \\
    1 & 4 &  6 &  4 &  1 \\
    1 & 5 & 10 & 10 &  5 &  1 \\
    1 & 6 & 15 & 20 & 15 &  6 &  1 \\
    1 & 7 & 21 & 35 & 35 & 21 &  7 & 1 \\
    1 & 8 & 28 & 56 & 70 & 56 & 28 & 8 & 1
\end{NiceMatrix}\]

%\subsection{The nodes corresponding to the command  \textbackslash SubMatrix}
\subsection{分块（子）矩阵节点 （\texttt{\textbackslash}SubMatrix）}

\label{node-sub-matrix}

%The command |\SubMatrix| available in the |\CodeAfter| has been described
%p.~\pageref{sub-matrix}.  
 |\SubMatrix| 可以在 |\CodeAfter| 中使用，详见~p.~\pageref{sub-matrix}。
\smallskip
%If a command |\SubMatrix| has been used with the key |name| with an expression
%such as |name=|\textsl{\ttfamily MyName} three PGF/Tikz nodes are created
%with the names \textsl{\ttfamily MyName}|-left|, \textsl{\ttfamily MyName} and
%\textsl{\ttfamily MyName}|-right|.
如果在 |\SubMatrix| 命令后使用 |name| 选项为分块（子）矩阵命名，如 |name = |\textsl{\ttfamily MyName} ，
那么 3 个 \textsc{pgf}/\tikzname 节点将会被创建，它们的名字分别是 \textsl{\ttfamily MyName}|-left|、 \textsl{\ttfamily MyName} 和 \textsl{\ttfamily MyName}|-right|。

\smallskip
%The nodes \textsl{\ttfamily MyName}|-left| and \textsl{\ttfamily
%MyName}|-right| correspond to the delimiters left and right and the node 
%\textsl{\ttfamily MyName} correspond to the submatrix itself.

节点 \textsl{\ttfamily MyName}|-left| 和 \textsl{\ttfamily
MyName}|-right| 分别对应子矩阵的左、右定界符，节点 \textsl{\ttfamily MyName} 对应子矩阵本身。 

\medskip
%In the following example, we have highlighted these nodes (the submatrix itself has
%been created with |\SubMatrix\{{2-2}{3-3}\}|). 
下例中，使用命令 |\SubMatrix\{{2-2}{3-3}\}| 定义了子矩阵，
并对上述 3 个节点分别设置了背景色。

\[\begin{pNiceMatrix}
121 & 23 & 345 & 345\\
45 & 346 & 863 & 444\\
3462 & 38458 & 34 & 294 \\
34 & 7 & 78 & 309 \\
\CodeAfter
\SubMatrix\{{2-2}{3-3}\}[name=A]
\begin{tikzpicture}
  [every node/.style = {blend mode = multiply,
                        inner sep = 0 pt}]
\node [fit = (A),fill = red!15] {} ;
\node [fit = (A-left),fill = blue!15] {} ;
\node [fit = (A-right),fill = blue!15] {} ;
\end{tikzpicture}
\end{pNiceMatrix}\]

%\section{API for the developpers}
\section{开发者接口（API）}

%The package \pkg{nicematrix} provides two variables which are internal but
%public\footnote{According to the LaTeX3 conventions,
%each variable with name beginning with |\g_nicematrix| ou |\l_nicematrix| is
%public and each variable with name beginning with |\g__nicematrix| or
%|\l__nicematrix| is private.}: 
|nicematrix| 提供了两个即是私有又是公共的变量\footnote{根据 LaTeX3 的约定，以 \texttt{\textbackslash g\_nicematrix} 或 \texttt{\textbackslash l\_nicematrix} 开头的都是公共变量，以 \texttt{\textbackslash g\_\_nicematrix} 或 \texttt{\textbackslash l\_\_nicematrix} 开头的变量都是私有变量。}：
\begin{itemize}
\item |\g_nicematrix_code_before_tl|
\item |\g_nicematrix_code_after_tl|
\end{itemize}


\medskip
%These variables contain the code of what we have called the ``|code-before|''
%and the ``|code-after|''. The developper can use them to add code from a cell
%of the array (the affectation must be global, allowing to exit the cell, which
%is a TeX group).
这两个变量保存了前文所述 “|code-before|” 和 “|code-after|”的代码。
开发者可以使用它们在单元格中添加代码（代码的影响必须是全局的，允许退出该单元格，即 TeX 组）。

\medskip
%One should remark that the use of |\g_nicematrix_code_before_tl| needs one
%compilation more (because the instructions are written on the |aux| file to be
%used during the next run).
需要指出的是， |\g_nicematrix_code_before_tl| 会将有关内容写入 |.aux| 文件供再次编译使用。因此，在使用 |\g_nicematrix_code_before_tl| 时，源文件可能需要 2 次编译才能输出预期的结果。

\bigskip
%\emph{Example} : We want to write a command |\hatchcell| to hatch the current
%cell (with an optional argument between brackets for the color). It's possible
%to program such command |\hatchcell| as follows, explicitely using the public
%variable |\g_nicematrix_code_before_tl| (this code requires the Tikz library
%\pkg{patterns}: |\usetikzlibrary{patterns}|).
\emph{例}：定义 1 个名为 |\hatchcell| 的命令，作用是为当前单元格添加阴影线效果，命令可以接受 1 个用方括号标识的可选参数，用于指定阴影线的颜色。

以下是使用 |\g_nicematrix_code_before_tl| 实现上述需求的代码。为实现阴影效果，使用了 \tikzname 的 \pkg{patterns} 库。


\begin{scope}
\fvset{commandchars=\§\¤\μ}
\begin{Verbatim}
\ExplSyntaxOn
\cs_new_protected:Nn \__pantigny_hatch:nnn
 {
   \tikz \fill [ pattern = north~west~lines , pattern~color = #3 ]
   ( #1 -| #2) rectangle ( \int_eval:n { #1 + 1 } -| \int_eval:n { #2 + 1 } ) ;
 }

\NewDocumentCommand \hatchcell { ! O { black } }
 {
   \tl_gput_right:Nx §emphase¤\g_nicematrix_code_before_tlμ
     { \__pantigny_hatch:nnn { \arabic { iRow } } { \arabic { jCol } } { #1 } }
 }
\ExplSyntaxOff
\end{Verbatim}
\end{scope}


\ExplSyntaxOn
\cs_new_protected:Nn \__pantigny_hatch:nnn
 {
   \tikz \fill [ pattern = north~west~lines , pattern~color = #3 ]
   ( #1 -| #2 ) rectangle ( \int_eval:n { #1 + 1 } -| \int_eval:n { #2 + 1 } ) ;
 }

\NewDocumentCommand \hatchcell { ! O { black } }
 {
   \tl_gput_right:Nx \g_nicematrix_code_before_tl
     { \__pantigny_hatch:nnn { \arabic { iRow } } { \arabic { jCol } } { #1 } }
 }
\ExplSyntaxOff

\bigskip
%Here is an example of use:
|\hatchcell| 命令的应用示例如下：

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=9cm]
\begin{NiceTabular}{ccc}[hvlines]
Tokyo & Paris & London \\
Lima & ~emphase#\hatchcell[blue!30]@Oslo & Miami \\
Los Angeles & Madrid & Roma
\end{NiceTabular}
\end{BVerbatim}
\begin{NiceTabular}{ccc}[hvlines]
Tokyo & Paris & London \\
Lima & \hatchcell[blue!30]Oslo & Miami \\
Los Angeles & Madrid & Roma
\end{NiceTabular}

%\section{Technical remarks}
\section{注记}

%\subsection{Definition of new column types}
\subsection{自定义新的列类型}

\label{OnlyMainNiceMatrix}

%The package \pkg{nicematrix} provides the command |\OnlyMainNiceMatrix|
%which is meant to be used in definitions of new column types. Its argument is
%evaluated if and only if we are in the main part of the array, that is to say
%not in a potential exterior row.
|nicematrix| 提供了 |\OnlyMainNiceMatrix| 命令用于定义新的列类型。
该命令只能新定义阵列主体部分的列类型，
不能用于自定义阵列外部列的类型。
 
%For example, one may wish to define a new column type |?| in order to draw a
%(black) heavy rule of width 1~pt. The following definition will do the
%job\footnote{The command |\vrule| is a TeX (and not LaTeX) command.}:
如，定义新的列类型“|?|”用于绘制宽度为 $1$~pt 的垂直框线。
针对上述需求，可使用如下代码\footnote{|\textbackslash vrule| 是\TeX 的原生命令。}：

\begin{Verbatim}
\newcolumntype{?}{!{\OnlyMainNiceMatrix{\vrule width 1 pt}}}
\end{Verbatim}

%The heavy vertical rule won't extend in the exterior rows.\footnote{Of course,
%such rule is defined by the classical technics of \pkg{nicematrix} and, for
%this reason, won't cross the double rules of |\hline\hline|.}
上例中，新定义的竖线不会延伸至阵列外部的行中\footnote{此处定义的竖线与 |nicematrix| 中的默认行为一致，即也不能穿过由 |\textbackslash hline\textbackslash hline| 绘制的双行线。}。
\medskip
\begin{scope}
\newcolumntype{?}{!{\OnlyMainNiceMatrix{\vrule width 1 pt}}}

\begin{BVerbatim}[baseline = c, boxwidth = 10.5cm]
$\begin{pNiceArray}{cc?cc}[first-row,last-row=3]
  C_1 & C_2 & C_3 & C_4 \\
  a   & b   & c   & d \\
  e   & f   & g   & h \\
  C_1 & C_2 & C_3 & C_4
\end{pNiceArray}$
\end{BVerbatim}
$\begin{pNiceArray}{cc?cc}[first-row,last-row=3]
C_1 & C_2 & C_3 & C_4 \\
a & b & c & d \\
e & f & g & h \\
C_1 & C_2 & C_3 & C_4
\end{pNiceArray}$
\end{scope}

\bigskip
%This specifier |?| may be used in the standard environments |{tabular}| and
%|{array}| (of the package \pkg{array}) and, in this case, the command
%|\OnlyMainNiceMatrix| is no-op.
上例中定义的新列格式“|?|”也可以在 |{tabular}| 和
|{array}| （需 \pkg{array} 宏包支持）环境中使用。

%\subsection{Diagonal lines} 
\subsection{对角线} 
\label{zm:对角线}

%By default, all the diagonal lines\footnote{We speak of the lines created by
%|\Ddots| and not the lines created by a command |\line| in |code-after|.} of a
%same array are ``parallelized''. That means that the first diagonal line is
%drawn and, then, the other lines are drawn parallel to the first one (by
%rotation around the left-most extremity of the line). That's why the position
%of the instructions |\Ddots| in the array can have a marked effect on the
%final result.
默认情况下，同一表格内的所有对角线\footnote{这里的对角线指的是用 |\textbackslash Ddots| 命令绘制，而不是在 |code-after| 中用 |\textbackslash line| 命令绘制的线条。}都是“平行的”。这意味着先绘制第一条对角线，然后再绘制其他与第一条对角线平行的线（通过围绕线条的最左端旋转实现）。这也是 |\Ddots| 命令在阵列中的位置会对阵列的最终排布结果产生明显影响的原因。

\medskip
%In the following examples, the first |\Ddots| instruction is written in color:
在以下的几个示例中，第 1 个 |\Ddots| 命令都高亮显示：

\bigskip
\begin{scope}
\begin{minipage}{9.5cm}
%Example with parallelization (default):
平行对角线（默认效果）示例：
\begin{Verbatim}
$A = \begin{pNiceMatrix}
  1      & \Cdots &        & 1      \\
  a+b    & ~emphase#\Ddots@~ &        & \Vdots \\
  \Vdots & \Ddots &        &        \\
  a+b    & \Cdots & a+b    & 1
\end{pNiceMatrix}$
\end{Verbatim}
\end{minipage}
$A = \begin{pNiceMatrix}
1      & \Cdots &     & 1      \\
a+b    & \Ddots &     & \Vdots \\
\Vdots & \Ddots &     &        \\
a+b    & \Cdots & a+b & 1
\end{pNiceMatrix}$

\bigskip
\NiceMatrixOptions{parallelize-diags=true}%
\begin{minipage}{9.5cm}
 \begin{Verbatim}
$A = \begin{pNiceMatrix}
  1      & \Cdots &        & 1      \\
  a+b    &        &        & \Vdots \\
  \Vdots & ~emphase#\Ddots@~ & \Ddots &        \\
  a+b    & \Cdots & a+b    & 1
\end{pNiceMatrix}$
\end{Verbatim}
\end{minipage}
$A = \begin{pNiceMatrix}
1      & \Cdots &        & 1      \\
a+b    &        &        & \Vdots \\
\Vdots & \Ddots & \Ddots &        \\
a+b    & \Cdots & a+b    & 1
\end{pNiceMatrix}$

\FTN{在上列 2 个平行对角线的示例中，阵列中第 1 个 \texttt{\textbackslash Ddots} 命令（用于绘制第 1 条虚线）的位置不同，矩阵的最终排布效果也不同。}

\bigskip
%It's possible to turn off the parallelization with the option
%|parallelize-diags| set to |false|: \par\nobreak
可以通过将 |parallelize-diags| 选项设置为 |false| 来关闭对角线平行效果：\par\nobreak

\medskip
\NiceMatrixOptions{parallelize-diags=false}%
\begin{minipage}{9.5cm}
%The same example without parallelization:
与第 1 个例子代码相同，但将 |parallelize-diags| 选项设置为 |false| 的效果：
\end{minipage}
$A = \begin{pNiceMatrix}
1      & \Cdots  &     & 1      \\
a+b    & \Ddots  &     & \Vdots \\
\Vdots & \Ddots  &     &        \\
a+b    & \Cdots  & a+b & 1
\end{pNiceMatrix}$

\end{scope}

%It's possible to specify the instruction |\Ddots| which will be drawn first
%(and which will be used to draw the other diagonal dotted lines when the
%parallelization is in force) with the key |draw-first|: |\Ddots[draw-first]|.
\medskip

可以使用 |\Ddots[draw-first]| 命令指定首先绘制的 |\Ddots| 命令（当 |parallelize-diags| 为 |true| （默认）时），并且将该虚线作为后续绘制其他对角虚线的参照。

%\subsection{The ``empty'' cells}
\subsection{“空”单元格（“empty” cell）}

\label{empty-cells}
%An instruction like |\Ldots|, |\Cdots|, etc. tries to determine the first
%non-empty cell on both sides. However, an ``empty cell'' is not necessarily a
%cell with no TeX content (that is to say a cell with no token between the two 
%ampersands~|&|). The precise rules are as follow.
|\Ldots| 和 |\Cdots| 等绘制虚线的命令会扩展至其两端的第一个非空单元格。在 |nicematrix| 中，“空”单元格不一定是没有内容的单元格（即在两个单元格内容分隔符（“|&|”）之间没有内容的单元格），而是由如下规则确定：

\begin{itemize}
%\item An implicit cell is empty. For example, in the following matrix:
\item “隐式”（implicit）单元格是空单元格。 例如，在下方的矩阵中：

\begin{Verbatim}
\begin{pmatrix}
a & b \\
c \\
\end{pmatrix}
\end{Verbatim}

%the last cell (second row and second column) is empty.
最后一个单元格（位于第 2 行第 2 列的单元格）为空。

\medskip
%\item Each cell whose TeX ouput has a width equal to zero is empty.
\item \TeX 输出的宽度等于零的单元格是空元格。

\medskip
%\item A cell containing the command |\NotEmpty| is not empty (and a PGF/Tikz
%node) is created in that cell.
\item 内容中包含 |\NotEmpty| 命令的单元格中会被创建一个 \textsc{pgf}/\tikzname 节点，因此它不是空单元格。

\medskip
%\item A cell with a command |\Hspace| (or |\Hspace*|) is empty. This command
%|\Hspace| is a command defined by the package \pkg{nicematrix} with the same
%meaning as |\hspace| except that the cell where it is used is considered as
%empty. This command can be used to fix the width of some columns of the matrix
%without interfering with \pkg{nicematrix}.
\item 内容中包含 |\Hspace| （或 |\Hspace*| ）命令的单元格是空单元格。 |\Hspace| 是 |nicematrix| 定义的命令，它的功能与 |\hspace| 命令基本相同，区别在于前者所在单元格被 |nicematrix| 视为空单元格。 |\Hspace| 命令主要用于固定某些列的单元格，同时不会干扰 |nicematrix| 的正常工作。
\end{itemize}


%\subsection{The option exterior-arraycolsep}
%\subsection{exterior-arraycolsep 选项}
\subsection{NiceArray 环境两侧的空白（exterior-arraycolsep选项）}
\label{zm:arraycolsep}

%The environment |{array}| inserts an horizontal space equal to |\arraycolsep|
%before and after each column. In particular, there is a space equal to
%|\arraycolsep| before and after the array. This feature of the environment
%|{array}| was probably not a good idea\footnote{In the documentation of
%|{amsmath}|, we can read: {\itshape The extra space of |\arraycolsep| that
%\pkg{array} adds on each side is a waste so we remove it [in |{matrix}|]
%(perhaps we should instead remove it from array in general, but that's a
%harder task).}}. The environment |{matrix}| of
%\pkg{amsmath} and its variants (|{pmatrix}|, |{vmatrix}|, etc.) of
%\pkg{amsmath} prefer to delete these spaces with explicit instructions 
%|\hskip -\arraycolsep|\footnote{And not by inserting |@{}| on both sides of the
%preamble of the array. As a consequence, the length of the |\hline| is not
%modified and may appear too long, in particular when using square brackets}.
%The package \pkg{nicematrix} does the same in all its environments,
%|{NiceArray}| included. However, if the user wants the environment
%|{NiceArray}| behaving by default like the environment |{array}| of
%\pkg{array} (for example, when adapting an existing document) it's possible to
%control this behaviour with the option |exterior-arraycolsep|, set by the
%command |\NiceMatrixOptions|. With this option, exterior spaces of length
%|\arraycolsep| will be inserted in the environments |{NiceArray}| (the other
%environments of \pkg{nicematrix} are not affected).

|{array}| 环境会在每个列（线）的左右各插入一个宽度等于 |\arraycolsep| 的水平空白。因此，在 |{array}| 环境的前后也各有一个宽度等于 |\arraycolsep| 的水平空白。  |{array}| 环境的这个功能可能不是一个好的主意\footnote{在 \pkg{amsmath} 宏包的文档中，有如下表述：{\itshape |array| 宏包在列两侧添加的 |\textbackslash arraycolsep| 的额外空间是浪费的，因此 \pkg{amsmath} 宏包在 |matrix| 及其变体环境中将其删除了（也许可以将水平空白全部从 |array| 中删除，但是这是一项艰巨的任务）。} }。在 \pkg{amsmath} 宏包的 |matrix| 及其变体环境（如 |{pmatrix}|、|{vmatrix}| 等）中，使用 |\hskip -\arraycolsep| 命令删除了矩阵两侧的水平空白\footnote{不是通过在矩阵导言的两侧插入  |@{}| 来实现。因此，|\textbackslash hline| 的长度不会被修改，并且可能显得过长，特别是在使用方括号时。 }。默认情况下，|nicematrix| 在其所有环境中均删除了阵列两侧的水平空白。如需使 |nicematrix| 中的 |{NiceArray}| 环境与 |array| 宏包 |{array}| 环境相同（如在修改现有文档时），可以通过 |\NiceMatrixOptions| 设置 |exterior-arraycolsep| 选项。此时 |{NiceArray}| 环境两侧会增加宽度为 |\arraycolsep| 的水平空白，而 |nicematrix| 的其他环境不受影响。


%\subsection{Incompatibilities}
\subsection{nicematrix 与其它宏包的兼容性问题}

%The package \pkg{nicematrix} is not fully compatible with the package
%\pkg{arydshln} (because this package redefines many internal of \pkg{array}).
\pkg{nicematrix} 与 \pkg{arydshln} 宏包不完全兼容，因为后者大量重定义了 \pkg{array} 宏包的内部实现。

%Anyway, in order to use \pkg{arydshln}, one must first free the letter ``|:|''
%by giving a new letter for the vertical dotted rules of \pkg{nicematrix}:
如果需要将 \pkg{nicematrix} 与 \pkg{arydshln} 一起使用，首先应在 \pkg{nicematrix} 中将用于标识垂直虚线的冒号（ ``|:|''）释放，具体可使用以下命令：


\begin{Verbatim}
\NiceMatrixOptions{letter-for-dotted-lines=;}
\end{Verbatim}

\bigskip
%As for now, the package \pkg{nicematrix} is not compatible with
%\cls{aastex63}. If you want to use \pkg{nicematrix} with \cls{aastex63}, send
%me an email and I will try to solve the incompatibilies.

目前， \pkg{nicematrix} 宏包与 \cls{aastex63} 文类不兼容。如需将 \pkg{nicematrix} 与 \cls{aastex63} 一起使用，可以给宏包作者发邮件。作者将尝试解决兼容性问题。

 \FTN{ aastex63 文类指 American Astronomical Society Journals（美国天文协会期刊）文类 v6.3，该版本发布于 2020 年 8 月 7 日。本文翻译时 \cls{aastex} 文类的最新版本是2021年3月1日发布的 \cls{aastex631} （v6.31）。}

%\section{Examples}
\section{示例汇总}

%\subsection{Notes in the tabulars}
\subsection{表格中的注释}

\label{ex:notes}

%The tools provided by \pkg{nicematrix} for the composition of the tabular
%notes have been presented in the section \ref{s:notes} p.~\pageref{s:notes}.
在第 \ref{s:notes} 节~p.~\pageref{s:notes} 中介绍了如何在  \pkg{nicematrix} 为表格添加注释。

\medskip
%Let's consider that we wish to number the notes of a tabular with
%stars.\footnote{Of course, it's realistic only when there is very few notes in
%the tabular.}
这里我们尝试将表格注释的标签改为星号（$\star$），且星号的数量与注释的编号相同\footnote{当然，这只有在表格中的注释数量较少时才有实际应用意义。}。

\medskip
%First, we write a command |\stars| similar the well-known commands 
%|\arabic|, |\alph|, |\Alph|, etc. which produces a number of stars equal to
%its argument \footnote{In fact: the value of its argument.}
首先，我们自定义一个命令 |\stars| ，该命令类似于 |\arabic|、|\alph| 和 |\Alph|等，它的功能是产生数量与其参数\footnote{实际上是 \textbackslash stars 命令参数的值。}相等的星号。
\begin{Verbatim}
\ExplSyntaxOn
\NewDocumentCommand ~emphase#\stars@ { m }
 { \prg_replicate:nn { \value { ~#1 } } { $ \star $ } } 
\ExplSyntaxOff
\end{Verbatim}
%
%Of course, we change the style of the labels with the key |notes/style|.
%However, it would be interesting to change also some parameters in the type of
%list used to compose the notes at the end of the tabular.
%First, we required a composition flush right for the labels with the setting
%|align=right|.
%Moreover, we want the labels to be composed on a width equal to the width of
%the widest label. The widest label is, of course, the label with the greatest
%number of stars. We know that number: it is equal to |\value{tabularnote}|
%(because |tabularnote| is the LaTeX counter used by |\tabularnote| and,
%therefore, at the end of the tabular, its value is equal to the total number
%of tabular notes). We use the key |widest*| of \pkg{enumitem} in order to
%require a width equal to that value: |widest*=\value{tabularnote}|. 

其次，我们可通过 |notes/style| 来更改标签的样式，同时也有必要更改在表格末尾用于排布注释的列表类型中的使注释标签对齐的一些参数。如可使用 |align = right| 使注释的标签右对齐。 此外，我们希望所有注释里标签的宽度一致（即都与星号最多的标签的宽度相同）。在最宽的标签中，星号的数量等于 |\value{tabularnote}|（|tabularnote| 是 |\tabularnote| 使用的\LaTeX 计数器。在表格的末尾，其值等于表格注释的数量）。 在 \pkg{enumitem} 中可使用 |widest*| 选项设置标签的宽度：|widest*=\value{tabularnote}|。
\begin{Verbatim}
\NiceMatrixOptions 
 {
   notes = 
    {
      ~emphase#style = \stars{~#1} , @
      ~emphase#enumitem-keys = @
      ~emphase# { @
      ~emphase#   widest* = \value{tabularnote} ,@
      ~emphase#   align = right @
      ~emphase# } @
    }
 }
\end{Verbatim}

完整的示例如下：

\begin{scope}
\ExplSyntaxOn
\NewDocumentCommand \stars { m }
 { \prg_replicate:nn { \value { #1 } } { $ \star $ } } 
\NiceMatrixOptions 
 {
   notes = 
    {
      style = \stars{#1} ,
      enumitem-keys = 
       {
         widest* = \value{tabularnote} ,
         align = right 
       }
    }
 }
\ExplSyntaxOff
\begin{Verbatim}
\begin{NiceTabular}{~@{}llr~@{}}[first-row,code-for-first-row = \bfseries]
\toprule
Last name & First name & Birth day \\
\midrule
Achard\tabularnote{~emphase#Achard is an old family of the Poitou.@} 
& Jacques & 5 juin 1962 \\
Lefebvre\tabularnote{~emphase#The name Lefebvre is an alteration of the name Lefebure.@} 
& Mathilde & 23 mai 1988 \\
Vanesse & Stephany & 30 octobre 1994 \\
Dupont & Chantal & 15 janvier 1998 \\
\bottomrule
\end{NiceTabular}
\end{Verbatim}

\begin{center}
\begin{NiceTabular}{@{}llr@{}}[first-row,code-for-first-row = \bfseries]
\toprule
Last name & First name & Birth day \\
\midrule
Achard\tabularnote{Achard is an old family of the Poitou.} 
& Jacques & June 5, 2005 \\
Lefebvre\tabularnote{The name Lefebvre is an alteration of the name Lefebure.} 
& Mathilde & January 23, 1975 \\
Vanesse & Stephany & October 30, 1994 \\
Dupont & Chantal & January 15, 1998 \\
\bottomrule
\end{NiceTabular}
\end{center}
\end{scope}


%\subsection{Dotted lines}
\subsection{虚线（dotted line）}

%\todo{此句未翻译}An example with the resultant of two polynoms:\par\nobreak

示例1如下：

\bigskip
\begin{BVerbatim}
\setlength{\extrarowheight}{1mm}
\[\begin{vNiceArray}{cccc:ccc}[columns-width=6mm]
  a_0   &      &  &       &b_0    &      &     \\
  a_1   &\Ddots&  &       &b_1    &\Ddots&     \\
  \Vdots&\Ddots&  &       &\Vdots &\Ddots&b_0  \\
  a_p   &      &  &a_0    &       &      &b_1   \\
        &\Ddots&  &a_1    &b_q    &      &\Vdots\\
        &      &  &\Vdots &       &\Ddots&      \\
        &      &  &a_p    &       &      &b_q
\end{vNiceArray}\]
\end{BVerbatim}

\bigskip

\begin{scope}
\setlength{\extrarowheight}{1mm}
\[\begin{vNiceArray}{cccc:ccc}[columns-width=6mm]
a_0   &      &&       &b_0    &      &     \\
a_1   &\Ddots&&       &b_1    &\Ddots&     \\
\Vdots&\Ddots&&       &\Vdots &\Ddots&b_0  \\
a_p   &      &&a_0    &       &      &b_1   \\
     &\Ddots&&a_1    &b_q    &      &\Vdots\\
     &      &&\Vdots &       &\Ddots&      \\
     &      &&a_p     &       &      &b_q    
\end{vNiceArray}\]
\end{scope}   

\vspace{2cm}
%\todo{此句未翻译}An example for a linear system:\par\nobreak
示例2如下：

\begin{Verbatim}
$\begin{pNiceArray}{*6c|c}[nullify-dots,last-col,code-for-last-col=\scriptstyle]
  1      & 1 & 1 &\Cdots &   & 1      & 0      & \\
  0      & 1 & 0 &\Cdots &   & 0      &        & L_2 \gets L_2-L_1 \\
  0      & 0 & 1 &\Ddots &   & \Vdots &        & L_3 \gets L_3-L_1 \\
         &   &   &\Ddots &   &        & \Vdots & \Vdots \\
  \Vdots &   &   &\Ddots &   & 0      & \\
  0      &   &   &\Cdots & 0 & 1      & 0      & L_n \gets L_n-L_1 
\end{pNiceArray}$
\end{Verbatim}


\[\begin{pNiceArray}{*6c|c}[nullify-dots,last-col,code-for-last-col=\scriptstyle]
1      & 1 & 1 &\Cdots &   & 1      & 0      & \\
0      & 1 & 0 &\Cdots &   & 0      &        & L_2 \gets L_2-L_1 \\
0      & 0 & 1 &\Ddots &   & \Vdots &        & L_3 \gets L_3-L_1 \\
       &   &   &\Ddots &   &        & \Vdots & \Vdots \\
\Vdots &   &   &\Ddots &   & 0      & \\
0      &   &   &\Cdots & 0 & 1      & 0      & L_n \gets L_n-L_1 
\end{pNiceArray}\]

%\subsection{Dotted lines which are no longer dotted}
\subsection{虚线样式的定制}

%The option |line-style| controls the style of the lines drawn by |\Ldots|,
%|\Cdots|, etc. Thus, it's possible with these commands to draw lines which are
%not longer dotted.

选项 |line-style| 可以用来设置 |\Ldots|、|\Cdots| 等命令绘制的线条的样式。%因此，可以通过设置 |line-style| 的值改变上述命令绘制的线条的样式。


\begin{Verbatim}[formatcom=\small\color{gray}]
\NiceMatrixOptions{code-for-first-row = \scriptstyle,code-for-first-col = \scriptstyle }
\setcounter{MaxMatrixCols}{12}
\newcommand{\blue}{\color{blue}}
\[\begin{pNiceMatrix}[last-row,last-col,nullify-dots,~emphase#xdots/line-style={dashed,blue}@]
1& & & \Vdots & & & & \Vdots \\
& \Ddots[line-style=standard] \\
& & 1 \\
\Cdots[color=blue,line-style=dashed]&   &  & \blue 0 &
\Cdots & & & \blue 1 & & & \Cdots & \blue \leftarrow i \\
& & & & 1 \\
& & &\Vdots & & \Ddots[line-style=standard] & & \Vdots \\
& & & & & & 1 \\
\Cdots & & & \blue 1 & \Cdots & & \Cdots & \blue 0 & & & \Cdots & \blue \leftarrow j \\
& & & & & & & & 1 \\
& & & & & & & & & \Ddots[line-style=standard] \\
& & & \Vdots & & & & \Vdots & & & 1 \\
& & & \blue \overset{\uparrow}{i} & & & & \blue \overset{\uparrow}{j} \\
\end{pNiceMatrix}\]
\end{Verbatim}


\begin{scope}
\NiceMatrixOptions{code-for-first-row = \scriptstyle,code-for-first-col = \scriptstyle }
\setcounter{MaxMatrixCols}{12}
\newcommand{\blue}{\color{blue}}
\[\begin{pNiceMatrix}[last-row,last-col,nullify-dots,xdots/line-style={dashed,blue}]
1& & & \Vdots & & & & \Vdots \\
& \Ddots[line-style=standard] \\
& & 1 \\
\Cdots[color=blue,line-style=dashed]&   &  & \blue 0 &
\Cdots & & & \blue 1 & & & \Cdots & \blue \leftarrow i \\
& & & & 1 \\
& & &\Vdots & & \Ddots[line-style=standard] & & \Vdots \\
& & & & & & 1 \\
\Cdots & & & \blue 1 & \Cdots & & \Cdots & \blue 0 & & & \Cdots & \blue \leftarrow j \\
& & & & & & & & 1 \\
& & & & & & & & & \Ddots[line-style=standard] \\
& & & \Vdots & & & & \Vdots & & & 1 \\
& & & \blue \overset{\uparrow}{i} & & & & \blue \overset{\uparrow}{j} \\
\end{pNiceMatrix}\]
\end{scope}

\interitem
%In fact, it's even possible to draw solid lines with the commands |\Cdots|,
%|\Vdots|, etc.
甚至还可以用 |\Cdots| 和 |\Vdots| 等命令绘制实线。

\begin{Verbatim}
\NiceMatrixOptions
 {nullify-dots,code-for-first-col = \color{blue},code-for-first-col=\color{blue}}
$\begin{pNiceMatrix}[first-row,first-col]
      &   & \Ldots~emphase#[line-style={solid,<->},shorten=0pt]@^{n \text{ columns}} \\
      & 1 & 1 & 1 & \Ldots & 1 \\
      & 1 & 1 & 1 &  & 1 \\
\Vdots~emphase#[line-style={solid,<->}]@_{n \text{ rows}} & 1 & 1 & 1 &  & 1 \\
      & 1 & 1 & 1 &  & 1 \\
      & 1 & 1 & 1 & \Ldots & 1 
\end{pNiceMatrix}$
\end{Verbatim}


\begin{scope}
\NiceMatrixOptions
 {nullify-dots,code-for-first-col = \color{blue},code-for-first-row=\color{blue}}
\[\begin{pNiceMatrix}[first-row,first-col]
      &   & \Ldots[line-style={solid,<->},shorten=0pt]^{n \text{ columns}} \\
      & 1 & 1 & 1 & \Ldots & 1 \\
      & 1 & 1 & 1 &  & 1 \\
\Vdots[line-style={solid,<->}]_{n \text{ rows}} & 1 & 1 & 1 &  & 1 \\
      & 1 & 1 & 1 &  & 1 \\
      & 1 & 1 & 1 & \Ldots & 1 
\end{pNiceMatrix}\]
\end{scope}


% \subsection{Stacks of matrices}
\subsection{矩阵的堆叠 --- NiceMatrixBlock 环境}
\label{zm:NiceMatrixBlock2}

%
% We often need to compose mathematical matrices on top on each other (for
% example for the resolution of linear systems).

有时需要将矩阵堆叠在一起，如求解线性方程组。
% \medskip
% In order to have the columns aligned one above the other, it's possible to
% fix a width for all the columns. That's what is done in the following example
% with the environment |{NiceMatrixBlock}| and its option |auto-columns-width|.
为了使多个矩阵的列彼此对齐，一种方法是固定所有矩阵中列的宽度。
|nicematrix| 的 |{NiceMatrixBlock}| 环境及其 |auto-columns-width| 选项可以实现上述目标。
如下例示：

\begin{Verbatim}[formatcom=\small\color{gray}]
~emphase#\begin{NiceMatrixBlock}[auto-columns-width]@
\NiceMatrixOptions
  {
    light-syntax,
    last-col, code-for-last-col = \color{blue} \scriptstyle,
  }
\setlength{\extrarowheight}{1mm}

$\begin{pNiceArray}{rrrr|r}
  12  -8  7  5   3 {} ;
   3 -18 12  1   4    ;
  -3 -46 29 -2 -15    ;
   9  10 -5  4   7 
\end{pNiceArray}$

\smallskip
$\begin{pNiceArray}{rrrr|r}
  12  -8   7  5   3                          ;
  0   64 -41  1  19  { L_2 \gets L_1-4L_2  } ;
  0 -192 123 -3 -57  { L_3 \gets L_1+4L_3  } ;
  0 -64   41 -1 -19  { L_4 \gets 3L_1-4L_4 } ;
\end{pNiceArray}$

\smallskip
$\begin{pNiceArray}{rrrr|r}
  12 -8   7 5  3 ;
   0 64 -41 1 19 ;
   0  0   0 0  0 { L_3 \gets 3 L_2 + L_3 }
\end{pNiceArray}$

\smallskip
$\begin{pNiceArray}{rrrr|r}
  12 -8   7 5  3 {} ;
  0  64 -41 1 19    ;
\end{pNiceArray}$

~emphase#\end{NiceMatrixBlock}@
\end{Verbatim}

\bigskip
\begin{NiceMatrixBlock}[auto-columns-width]
\NiceMatrixOptions
 { 
   light-syntax,
   last-col, code-for-last-col = \color{blue} \scriptstyle ,
 }
\setlength{\extrarowheight}{1mm}

\quad $\begin{pNiceArray}{rrrr|r}
12  -8  7  5   3 {} ;
3 -18 12  1   4    ;
-3 -46 29 -2 -15    ;
9  10 -5  4   7 
\end{pNiceArray}$

\smallskip
\quad $\begin{pNiceArray}{rrrr|r}
12  -8   7  5   3                          ;
0   64 -41  1  19  { L_2 \gets L_1-4L_2  } ;
0 -192 123 -3 -57  { L_3 \gets L_1+4L_3  } ;
0 -64   41 -1 -19  { L_4 \gets 3L_1-4L_4 } ;
\end{pNiceArray}$

\smallskip
\quad $\begin{pNiceArray}{rrrr|r}
12 -8   7 5  3 ;
0  64 -41 1 19 ;
0   0   0 0  0 { L_3 \gets 3 L_2 + L_3 } 
\end{pNiceArray}$

\smallskip
\quad $\begin{pNiceArray}{rrrr|r}
12 -8   7 5  3 {} ;
0  64 -41 1 19    ;
\end{pNiceArray}$
\end{NiceMatrixBlock}

\bigskip
\NFTN 关于 |\NiceMatrixBlock| 命令的另1个示例见~p.~\pageref{zm:NiceMatrixBlock1} 。

\bigskip
% However, one can see that the last matrix is not perfectly aligned with the
% other. That's why, in LaTeX, the parenthesis have not exactly the same width
% (smaller parenthesis are a bit slimer).
但是，上例中最后一个矩阵与其它矩阵没有精确对齐。原因是在\LaTeX 中，
括号的宽度不完全相同，尺寸较小的括号其宽度也较细。

%
% \medskip
% \colorbox{yellow!50}{\textbf{New 5.12}}\enskip In order the solve that
% problem, it's possible to require the delimiters to be composed with the
% maximal width, thanks to the boolean key |delimiters/max-width|.

\colorbox{yellow!50}{\textbf{v5.12新增}}\enskip 为解决上述问题， 
|nicematrix| 提供了 |delimiters/max-width| 选项，以使矩阵定界符（如上例中的括号）的宽度相同。

\begin{Verbatim}[formatcom=\small\color{gray}]
~emphase#\begin{NiceMatrixBlock}[auto-columns-width]@
\NiceMatrixOptions
{ 
    ~emphase#delimiters/max-width@,
    light-syntax,
    last-col, code-for-last-col = \color{blue}\scriptstyle,
}
\setlength{\extrarowheight}{1mm}

$\begin{pNiceArray}{rrrr|r}
  12  -8  7  5   3 {} ;
   3 -18 12  1   4    ;
  -3 -46 29 -2 -15    ;
   9  10 -5  4   7 
\end{pNiceArray}$

...
~emphase#\end{NiceMatrixBlock}@
\end{Verbatim}

\bigskip
\begin{NiceMatrixBlock}[auto-columns-width]
\NiceMatrixOptions
 { 
   delimiters/max-width,
   light-syntax,
   last-col, code-for-last-col = \color{blue}\scriptstyle,
 }
\setlength{\extrarowheight}{1mm}

\quad $\begin{pNiceArray}{rrrr|r}
12  -8  7  5   3 {} ;
3 -18 12  1   4    ;
-3 -46 29 -2 -15    ;
9  10 -5  4   7 
\end{pNiceArray}$

\smallskip
\quad $\begin{pNiceArray}{rrrr|r}
12  -8   7  5   3                      ;
0   64 -41  1  19  { L_2 \gets L_1-4L_2  } ;
0 -192 123 -3 -57  { L_3 \gets L_1+4L_3  } ;
0 -64   41 -1 -19  { L_4 \gets 3L_1-4L_4 } ;
\end{pNiceArray}$

\smallskip
\quad $\begin{pNiceArray}{rrrr|r}
12 -8   7 5  3 ;
0  64 -41 1 19 ;
0   0   0 0  0 { L_3 \gets 3 L_2 + L_3 } 
\end{pNiceArray}$

\smallskip
\quad $\begin{pNiceArray}{rrrr|r}
12 -8   7 5  3 {} ;
0  64 -41 1 19    ;
\end{pNiceArray}$

\end{NiceMatrixBlock}
%
\interitem
% If you wish an alignment of the different matrices without the same width
% for all the columns, you can construct a unique array and place the
% parenthesis with commands |\SubMatrix| in the |\CodeAfter|. Of course, that
% array can't be broken by a page break.
如果需要使多个不同列宽的矩阵能对齐，可以首先将所有内容构造为一个大的数组（array），
然后在 |\CodeAfter| 中通过 |\SubMatrix| 命令在大数组中放置括号。
需要注意的是，上述大数组不能跨页。

%
\medskip
\begin{Verbatim}
\setlength{\extrarowheight}{1mm}
\[\begin{NiceMatrix}[ r, last-col=6, code-for-last-col = \scriptstyle \color{blue} ]
  12 &  -8  &  7 & 5 &  3 \\
  3  & -18  & 12 & 1 &  4 \\
  -3 & -46  & 29 &-2 &-15 \\
  9  & 10   &-5  &4  & 7 \\[1mm]
  12 & -8   & 7  &5  & 3 \\
  0  & 64   &-41 & 1 & 19 & L_2 \gets L_1-4L_2  \\
  0  & -192 &123 &-3 &-57 & L_3 \gets L_1+4L_3  \\
  0  & -64  & 41 &-1 &-19 & L_4 \gets 3L_1-4L_4 \\[1mm]
  12 & -8   &7   &5  & 3 \\
  0  & 64   &-41 &1  &19 \\
  0  &  0   &0   &0  & 0  & L_3 \gets 3L_2+L_3 \\[1mm]
  12 & -8   &7   &5  & 3 \\
  0  & 64   &-41 & 1 & 19 \\
  ~emphase#\CodeAfter [sub-matrix/vlines=4]@ 
  ~emphase#   \SubMatrix({1-1}{4-5})@
  ~emphase#   \SubMatrix({5-1}{8-5})@
  ~emphase#   \SubMatrix({9-1}{11-5})@
  ~emphase#   \SubMatrix({12-1}{13-5})@
\end{NiceMatrix}\]
\end{Verbatim}

\medskip
\begin{scope}
\setlength{\extrarowheight}{1mm}
\[\begin{NiceMatrix}[ r, last-col=6, code-for-last-col = \scriptstyle \color{blue} ]
12 &  -8  &  7 & 5 &  3 \\
3 & -18  & 12 & 1 &  4 \\
-3 & -46  & 29 &-2 &-15 \\
9 & 10   &-5  &4  & 7 \\[1mm]
12 & -8   & 7  &5  & 3 \\
0  & 64   &-41 & 1 & 19 & L_2 \gets L_1-4L_2  \\
0  & -192 &123 &-3 &-57 & L_3 \gets L_1+4L_3  \\
0  & -64  & 41 &-1 &-19 & L_4 \gets 3L_1-4L_4 \\[1mm]
12 & -8   &7   &5  & 3 \\
0  & 64   &-41 &1  &19 \\
0  &  0   &0   &0  & 0 & L_3 \gets 3L_2+L_3 \\[1mm]
12 & -8   &7   &5  & 3 \\
0  & 64   &-41 & 1 & 19 \\
\CodeAfter  [sub-matrix/vlines=4]
  \SubMatrix({1-1}{4-5})
  \SubMatrix({5-1}{8-5})
  \SubMatrix({9-1}{11-5})
  \SubMatrix({12-1}{13-5})
\end{NiceMatrix}\]
\end{scope}

%\subsection{How to highlight cells of a matrix}
\subsection{高亮显示单元格}


\label{highlight}

\medskip
%In order to highlight a cell of a matrix, it's possible to ``draw'' that cell
%with the key |draw| of the command |\Block| (this is one of the uses of a
%mono-cell block\footnote{We recall that, if the first mandatory argument of
%the command |\Block| is left empty, that means that the block is a mono-cell block}).
为了突出显示阵列中的某一单元格，可以使用 |\Block[draw]| 命令来“绘制”该单元格（这也是单元格“块”\footnote{如果 |\textbackslash Block| 命令的第 1 个必选参数留空，表示这是一个单元格块（“mono-cell”）。}的应用场景之一）。
\label{example-CodeAfter}

\NFTN 关于单元格“块”的详细内容见~p.~\pageref{subsec:mono-cell-block} 。


\begin{Verbatim}
$\begin{pNiceArray}{>{\strut}cccc}[margin,rules/color=blue]
  ~emphase#\Block[draw]{}{a_{11}}@ & a_{12} & a_{13} & a_{14} \\
  a_{21} & ~emphase#\Block[draw]{}{a_{22}}@ & a_{23} & a_{24} \\
  a_{31} & a_{32} & ~emphase#\Block[draw]{}{a_{33}}@ & a_{34} \\
  a_{41} & a_{42} & a_{43} & ~emphase#\Block[draw]{}{a_{44}}@ \\
\end{pNiceArray}$
\end{Verbatim}
\[\begin{pNiceArray}{>{\strut}cccc}[margin,rules/color=blue]
\Block[draw]{}{a_{11}} & a_{12} & a_{13} & a_{14} \\
a_{21} & \Block[draw]{}{a_{22}} & a_{23} & a_{24} \\
a_{31} & a_{32} & \Block[draw]{}{a_{33}} & a_{34} \\
a_{41} & a_{42} & a_{43} & \Block[draw]{}{a_{44}} \\
\end{pNiceArray}\]
\bigskip

%We should remark that the rules we have drawn are drawn \emph{after} the
%construction of the array and thus, they don't spread the cells of the array.
%We recall that, on the other side, the command |\hline|, the specifier ``"|"''
%and the options |hlines|, |vlines| and |hvlines| spread the
%cells.\footnote{For the command |\cline|, see the remark
%p.~\pageref{remark-cline}.}
需要指出的是，|\Block[draw]| 命令是在数组构造完成之后再行绘制线条，
因此它不会增加单元格的宽度。命令|\hline|、标识符 “\textbar”
以及选项 |hlines|、|vlines| 和 |hvlines| 会增加单元格的宽度。\footnote{关于 |\textbackslash cline| 命令，请参见~p.~\pageref{remark-cline}。}

%\vspace{1cm}
%It's possible to color a row with |\rowcolor| in the |code-before| (or with
%|\rowcolor| in the first cell of the row if the key |colortbl-like| is
%used−even when \pkg{colortbl} is not loaded).
可以在 |code-before| 中用 |\rowcolor| 为行着色（或在阵列的导言区中启用 |colortbl-like| 选项，
而后在行内需高亮区域的起始单元格处使用|\rowcolor|，无需载入 \pkg{colortbl} 宏包）。
\label{zm:rowcolor2}

\medskip
\begin{Verbatim}
\begin{pNiceArray}{>{\strut}cccc}[margin, extra-margin=2pt,~emphase#colortbl-like@]
 ~emphase#\rowcolor{red!15}@A_{11} & A_{12} & A_{13} & A_{14} \\
 A_{21} & ~emphase#\rowcolor{red!15}@A_{22} & A_{23} & A_{24} \\
 A_{31} & A_{32} & ~emphase#\rowcolor{red!15}@A_{33} & A_{34} \\
 A_{41} & A_{42} & A_{43} & ~emphase#\rowcolor{red!15}@A_{44}  
\end{pNiceArray}
\end{Verbatim}

\[\begin{pNiceArray}{>{\strut}cccc}[margin, extra-margin=2pt,colortbl-like]
 \rowcolor{red!15}A_{11} & A_{12} & A_{13} & A_{14} \\
 A_{21} & \rowcolor{red!15}A_{22} & A_{23} & A_{24} \\
 A_{31} & A_{32} & \rowcolor{red!15}A_{33} & A_{34} \\
 A_{41} & A_{42} & A_{43} & \rowcolor{red!15}A_{44}  
\end{pNiceArray}\]
\bigskip

\NFTN |\rowcolor| 命令的另一个示例见~p.~\pageref{zm:rowcolor} 。

\bigskip
%However, it's not possible to do a fine tuning. That's why we describe now a
%method to highlight a row of the matrix. We create a rectangular Tikz node
%which encompasses the nodes of the second row with the Tikz library \pkg{fit}.
%This Tikz node is filled after the construction of the matrix. In order to see
%the text \emph{under} this node, we have to use transparency with the 
%|blend mode| equal to |multiply|.
上述方法存在的缺点是无法对高亮的效果进行调整。这里介绍另一种突出显示矩阵行的方法。
在下例中，使用 \tikzname 的 \pkg{fit} 库创建一个包含了第 2 行的所有单元格的 \tikzname 节点，
并在矩阵构造完成后在单元格内容的上一图层中填充此 \tikzname 节点。为了能够看到该节点下的文字，必须在 \tikzname 中使用透明模式，并将混合模式 |blend mode| 设为 |multiply|。

\medskip
%\textbf{Caution} : Some \textsc{pdf} readers are not able to show
%transparency.\footnote{In Overleaf, the ``built-in'' \textsc{pdf} viewer does
%not show transparency. You can switch to the ``native'' viewer in that case.}
\textbf{注意}：某些 \textsc{pdf} 阅读器不支持透明模式的显示。\footnote{在 Overleaf 中，``built-in'' \textsc{pdf} 阅读器无法显示透明度，可以将其切换为 ``native'' 阅读器。}


\medskip
%That example and the following ones require Tikz (by default, \pkg{nicematrix}
%only loads \textsc{pgf}, which is a sub-layer of Tikz) and the Tikz library
%|fit|. The following lines in the preamble of your document do the job:
以下的所有示例均需 \tikzname 宏包（默认情况下 \pkg{nicematrix}
仅载入 \textsc{pgf} ）及其 |fit| 库。因此，在导言区应加入如下代码：
\begin{verbatim}
  \usepackage{tikz}
  \usetikzlibrary{fit}
\end{verbatim}

\tikzset{highlight/.style={rectangle,
                          fill=red!15,
                          blend mode = multiply, 
                          rounded corners = 0.5 mm, 
                          inner sep=1pt,
                          fit = #1}}

\medskip
\begin{Verbatim}
\tikzset{highlight/.style={rectangle,
                          fill=red!15,
                          ~emphase#blend mode = multiply@,
                          rounded corners = 0.5 mm, 
                          inner sep=1pt,
                          fit = ~#1}}
$\begin{bNiceMatrix}
  0 & \Cdots & 0 \\
  1 & \Cdots & 1 \\
  0 & \Cdots & 0 \\
  ~emphase#\CodeAfter \tikz \node [highlight = (2-1) (2-3)] {} ;@
\end{bNiceMatrix}$
\end{Verbatim}
\[\begin{bNiceMatrix}
0 & \Cdots & 0 \\
1 & \Cdots & 1 \\
0 & \Cdots & 0 \\
\CodeAfter \tikz \node [highlight = (2-1) (2-3)] {} ; 
\end{bNiceMatrix}\]



\vspace{1cm} 
%We recall that, for a rectangle of merged cells (with the command |\Block|), a
%Tikz node is created for the set of merged cells with the name
%$i$|-|$j$-|block| where $i$ and $j$ are the number of the row and the number
%of the column of the upper left cell (where the command |\Block| has been
%issued). If the user has required the creation of the |medium| nodes, a node
%of this type is also created with a name suffixed by |-medium|.
前文提及，对于使用命令 |\Block| 创建的“块”， |nicematrix| 将同时创建一个名为“$i$|-|$j$-|block|”的节点，其中 $i$ 是“块”左上角单元格合并前所在行的行号，$j$ 是“块”左上角单元格合并前所在列的列号。如果需要创建 |medium| 节点，需要在其名称前加 |-medium| 后缀。

\bigskip
\begin{BVerbatim}[baseline=c,boxwidth=10.5cm]
$\begin{pNiceMatrix}[margin,~emphase#create-medium-nodes@]
  \Block{3-3}<\Large>{A} & & & 0 \\
    & \hspace*{1cm} &        & \Vdots   \\
    &               &        & 0        \\
  0                 & \Cdots & 0      & 0
  \CodeAfter
    \tikz \node [~emphase#highlight = (1-1-block-medium)@] {} ;
\end{pNiceMatrix}$
\end{BVerbatim}
$\begin{pNiceMatrix}[margin,create-medium-nodes]
\Block{3-3}<\Large>{A} & & & 0 \\
& \hspace*{1cm} & & \Vdots \\
& & & 0 \\
0 & \Cdots& 0 & 0
\CodeAfter
\tikz \node [highlight = (1-1-block-medium)] {} ;
\end{pNiceMatrix}$
\bigskip

%\vspace{1cm}
%Consider now the following matrix which we have named |example|.
现在考虑下面的矩阵，我们将其命名为 |example|。

\bigskip
\begin{Verbatim}
$\begin{pNiceArray}{ccc}[~emphase#name=example@,last-col,create-medium-nodes]
a & a + b & a + b + c & L_1 \\
a & a     & a + b     & L_2 \\
a & a     & a         & L_3
\end{pNiceArray}$
\end{Verbatim}
                         
\[\begin{pNiceArray}{ccc}[last-col]
a & a + b & a + b + c & L_1 \\
a & a     & a + b     & L_2 \\
a & a     & a         & L_3
\end{pNiceArray}\]

\bigskip
%If we want to highlight each row of this matrix, we can use the previous
%technique three times. 
如果要突出显示上述矩阵的每一行，可使用如下代码：

\begin{Verbatim}
\tikzset{mes-options/.style={remember picture, 
                            overlay,
                            name prefix = exemple-,
                            highlight/.style = {fill = red!15,
                                                blend mode = multiply,
                                                inner sep = 0pt,
                                                fit = ~#1}}}
\end{Verbatim}


\tikzset{mes-options/.style={remember picture, 
                            overlay,
                            name prefix = exemple-,
                            highlight/.style = {fill = red!15,
                                                blend mode = multiply,
                                                inner sep = 0pt,
                                                fit = #1}}}

\begin{Verbatim}
\begin{tikzpicture}[mes-options]
\node [highlight = (1-1) (1-3)] {} ;
\node [highlight = (2-1) (2-3)] {} ;
\node [highlight = (3-1) (3-3)] {} ;
\end{tikzpicture}
\end{Verbatim}


\medskip
%We obtain the following matrix.
上述代码的运行结果如下：

\[\begin{pNiceArray}{ccc}[
    last-col,
    code-after = {\begin{tikzpicture}[every node/.style = {fill = red!15,
                                                           blend mode = multiply,
                                                           inner sep = 0pt}]
                  \node [fit = (1-1) (1-3)] {} ;
                  \node [fit = (2-1) (2-3)] {} ;
                  \node [fit = (3-1) (3-3)] {} ;
                  \end{tikzpicture}}]
a & a + b & a + b + c & L_1\\
a & a     & a + b     & L_2 \\
a & a     & a         & L_3
\end{pNiceArray}\]

\medskip
%The result may seem disappointing. We can improve it by using the ``medium
%nodes'' instead of the ``normal nodes''. 
上述结果似乎不够美观。可以将矩阵中的“normal nodes”替换为“medium nodes”。

\begin{Verbatim}
\begin{tikzpicture}[mes-options, ~emphase#name suffix = -medium@]
\node [highlight = (1-1) (1-3)] {} ;
\node [highlight = (2-1) (2-3)] {} ;
\node [highlight = (3-1) (3-3)] {} ;
\end{tikzpicture}
\end{Verbatim}

\medskip
%We obtain the following matrix.
上述代码的运行结果如下：

\[\begin{pNiceArray}{ccc}[
    last-col,
    create-medium-nodes,
    code-after = {\begin{tikzpicture}[highlight/.style = {fill = red!15,
                                                          blend mode = multiply,
                                                          inner sep = 0pt,
                                                          fit = #1},
                                      name suffix = -medium]
                  \node [highlight = (1-1) (1-3)] {} ;
                  \node [highlight = (2-1) (2-3)] {} ;
                  \node [highlight = (3-1) (3-3)] {} ;
                  \end{tikzpicture}}]
a & a + b & a + b + c & L_1 \\
a & a     & a + b     & L_2 \\
a & a     & a         & L_3
\end{pNiceArray}\]


%\subsection{Utilisation of \textbackslash SubMatrix in the code-before}
%\subsection[在 code-before 中使用 \textbackslash SubMatrix 命令]{在 \texttt{code-before} 中使用 \texttt{\textbackslash SubMatrix}命令}
\subsection{在 code-before 中使用 \texttt{\textbackslash}SubMatrix 命令}
\label{zm:Submatrix}

%In the following example, we illustrate the mathematical product of two
%matrices. 
下面的示例展示了两个矩阵的乘积。

%The whole figure is an environment |{NiceArray}| and the three pairs of
%parenthesis have been added with |\SubMatrix| in the |code-before|.

整个图是一个 |{NiceArray}| 环境，并在 |code-before| 中使用 |\SubMatrix| 生成了3个子矩阵。

%You will find the LaTeX code of that figure in the source file of this
%document.
实现代码请参阅源文件。

\[\begin{NiceArray}{*{6}{c}@{\hspace{6mm}}*{5}{c}}[nullify-dots]
\CodeBefore
 \SubMatrix({2-7}{6-11})
 \SubMatrix({7-2}{11-6})
 \SubMatrix({7-7}{11-11})
\Body
   &        &        &        &        &        &        &        & \color{blue}\scriptstyle C_j \\
   &        &        &        &        &        & b_{11} & \Cdots & b_{1j} & \Cdots & b_{1n} \\
   &        &        &        &        &        & \Vdots &        & \Vdots &        & \Vdots \\
   &        &        &        &        &        &        &        & b_{kj} \\
   &        &        &        &        &        &        &        & \Vdots \\
   &        &        &        &        &        & b_{n1} & \Cdots & b_{nj} & \Cdots & b_{nn} \\[3mm]
   & a_{11} & \Cdots &        &        & a_{1n} \\
   & \Vdots &        &        &        & \Vdots &        &        & \Vdots \\
\color{blue}\scriptstyle L_i 
   & a_{i1} & \Cdots & a_{ik} & \Cdots & a_{in} & \Cdots &        & c_{ij} \\
   & \Vdots &        &        &        & \Vdots \\
   & a_{n1} & \Cdots &        &        & a_{nn}  \\
\CodeAfter
 \begin{tikzpicture}
 \node [highlight = (9-2) (9-6)] { } ;
 \node [highlight = (2-9) (6-9)] { } ;
 \draw [gray,shorten > = 1mm, shorten < = 1mm] (9-4.north) to [bend left] (4-9.west) ;
 \end{tikzpicture}
\end{NiceArray}\]

\section{本译文更新历史}

\textbullet 2021-03-14，v1.00，对应原文v5.12（2021-03-10），摘要：首次公开发布。

\textbullet
2021-03-28，v2.00，对应原文v5.13（2021-03-23），摘要：\resetcstep\cstep 译文对应原文更新至 v\nicematrixfileversion；\cstep 脚注编号格式改为更符合中文习惯的圈码编号; \cstep 对v1.00中部分错情进行修正，对个别用语进行调整，调整部分标题的格式等。

\end{document}

% Local Variables:
% TeX-fold-mode: t
% TeX-fold-preserve-comments: nil
% fill-column: 80
% End: